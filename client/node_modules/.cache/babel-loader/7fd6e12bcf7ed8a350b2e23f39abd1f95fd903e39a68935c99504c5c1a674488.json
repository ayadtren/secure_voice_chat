{"ast":null,"code":"/**\n * WebRTC Quality Monitor\n * \n * Monitors WebRTC connection quality and provides adaptive streaming capabilities\n */\nexport class WebRTCQualityMonitor {\n  /**\n   * Create a new WebRTC Quality Monitor\n   * @param {Object} options - Configuration options\n   */\n  constructor(options = {}) {\n    // Quality presets\n    this.qualityPresets = {\n      low: {\n        id: 'low',\n        width: 640,\n        height: 360,\n        frameRate: 15,\n        bitrate: 400000\n      },\n      medium: {\n        id: 'medium',\n        width: 854,\n        height: 480,\n        frameRate: 24,\n        bitrate: 800000\n      },\n      high: {\n        id: 'high',\n        width: 1280,\n        height: 720,\n        frameRate: 30,\n        bitrate: 1500000\n      },\n      hd: {\n        id: 'hd',\n        width: 1920,\n        height: 1080,\n        frameRate: 30,\n        bitrate: 3000000\n      }\n    };\n\n    // Current quality setting\n    this.currentQuality = options.initialQuality || 'high';\n    this.adaptiveQuality = options.adaptiveQuality !== false;\n\n    // Callbacks\n    this.onQualityChange = options.onQualityChange || null;\n    this.onNetworkQualityChange = options.onNetworkQualityChange || null;\n\n    // Stats\n    this.lastStats = {};\n    this.networkQuality = 100;\n    this.monitorInterval = null;\n  }\n\n  /**\n   * Start monitoring network quality\n   * @param {RTCPeerConnection} peerConnection - WebRTC peer connection to monitor\n   * @param {string} peerId - ID of the peer\n   */\n  startMonitoring(peerConnection, peerId) {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n    this.monitorInterval = setInterval(async () => {\n      try {\n        if (!peerConnection) return;\n\n        // Get connection stats\n        const stats = await peerConnection.getStats();\n        const videoStats = {};\n        const connectionStats = {};\n        stats.forEach(stat => {\n          // Collect video stats\n          if (stat.type === 'outbound-rtp' && stat.kind === 'video') {\n            videoStats.bytesSent = stat.bytesSent;\n            videoStats.packetsSent = stat.packetsSent;\n            videoStats.framesEncoded = stat.framesEncoded;\n            videoStats.framesSent = stat.framesSent;\n            videoStats.timestamp = stat.timestamp;\n          }\n\n          // Collect connection stats\n          if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {\n            connectionStats.currentRoundTripTime = stat.currentRoundTripTime;\n            connectionStats.availableOutgoingBitrate = stat.availableOutgoingBitrate;\n            connectionStats.timestamp = stat.timestamp;\n          }\n        });\n\n        // Calculate network quality\n        if (this.lastStats.timestamp) {\n          var _this$qualityPresets$, _this$qualityPresets$2;\n          // Calculate bitrate\n          const timeDiff = (videoStats.timestamp - this.lastStats.timestamp) / 1000;\n          const bytesSent = videoStats.bytesSent - this.lastStats.bytesSent;\n          const bitrate = bytesSent * 8 / timeDiff; // bps\n\n          // Calculate packet loss\n          const packetsSent = videoStats.packetsSent - this.lastStats.packetsSent;\n          const packetLoss = 0; // TODO: Calculate actual packet loss\n\n          // Calculate frame rate\n          const framesSent = videoStats.framesSent - this.lastStats.framesSent;\n          const frameRate = framesSent / timeDiff;\n\n          // Calculate round trip time (in ms)\n          const rtt = connectionStats.currentRoundTripTime * 1000;\n\n          // Calculate overall quality score (0-100)\n          let qualityScore = 100;\n\n          // Reduce score based on RTT\n          if (rtt > 500) qualityScore -= 40;else if (rtt > 300) qualityScore -= 25;else if (rtt > 150) qualityScore -= 10;else if (rtt > 100) qualityScore -= 5;\n\n          // Reduce score based on bitrate\n          const targetBitrate = ((_this$qualityPresets$ = this.qualityPresets[this.currentQuality]) === null || _this$qualityPresets$ === void 0 ? void 0 : _this$qualityPresets$.bitrate) || 1500000;\n          if (bitrate < targetBitrate * 0.3) qualityScore -= 40;else if (bitrate < targetBitrate * 0.5) qualityScore -= 25;else if (bitrate < targetBitrate * 0.7) qualityScore -= 10;\n\n          // Reduce score based on frame rate\n          const targetFrameRate = ((_this$qualityPresets$2 = this.qualityPresets[this.currentQuality]) === null || _this$qualityPresets$2 === void 0 ? void 0 : _this$qualityPresets$2.frameRate) || 30;\n          if (frameRate < targetFrameRate * 0.3) qualityScore -= 30;else if (frameRate < targetFrameRate * 0.5) qualityScore -= 20;else if (frameRate < targetFrameRate * 0.7) qualityScore -= 10;\n\n          // Ensure score is between 0-100\n          qualityScore = Math.max(0, Math.min(100, qualityScore));\n\n          // Update network quality\n          this.networkQuality = qualityScore;\n\n          // Notify about quality change\n          if (this.onNetworkQualityChange) {\n            this.onNetworkQualityChange(peerId, qualityScore, {\n              bitrate,\n              rtt,\n              frameRate,\n              packetLoss\n            });\n          }\n\n          // Apply adaptive quality if enabled\n          if (this.adaptiveQuality) {\n            this.adaptVideoQuality(qualityScore, bitrate, rtt);\n          }\n        }\n\n        // Store current stats for next comparison\n        this.lastStats = {\n          ...videoStats,\n          ...connectionStats\n        };\n      } catch (error) {\n        console.warn('Error monitoring network quality:', error);\n      }\n    }, 2000); // Check every 2 seconds\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stopMonitoring() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n  }\n\n  /**\n   * Adapt video quality based on network conditions\n   * @param {number} qualityScore - Overall quality score (0-100)\n   * @param {number} bitrate - Current bitrate in bps\n   * @param {number} rtt - Round trip time in ms\n   */\n  adaptVideoQuality(qualityScore, bitrate, rtt) {\n    try {\n      let targetQuality;\n\n      // Determine target quality based on network conditions\n      if (qualityScore < 30 || rtt > 300) {\n        targetQuality = 'low';\n      } else if (qualityScore < 60 || rtt > 150) {\n        targetQuality = 'medium';\n      } else if (qualityScore < 85 || rtt > 100) {\n        targetQuality = 'high';\n      } else {\n        targetQuality = 'hd';\n      }\n\n      // Only change quality if it's different from current\n      if (targetQuality !== this.currentQuality) {\n        console.log(`Adapting video quality to ${targetQuality} due to network conditions`);\n        this.setQuality(targetQuality);\n      }\n    } catch (error) {\n      console.warn('Error adapting video quality:', error);\n    }\n  }\n\n  /**\n   * Set video quality preset\n   * @param {string|Object} preset - Quality preset id or custom preset object\n   * @returns {Object} - The quality settings\n   */\n  setQuality(preset) {\n    try {\n      let qualitySettings;\n      if (typeof preset === 'string') {\n        // Use predefined preset\n        qualitySettings = this.qualityPresets[preset];\n        if (!qualitySettings) {\n          throw new Error(`Unknown quality preset: ${preset}`);\n        }\n        this.currentQuality = preset;\n      } else if (typeof preset === 'object') {\n        // Use custom settings\n        qualitySettings = preset;\n        this.currentQuality = 'custom';\n      } else {\n        throw new Error('Invalid quality preset');\n      }\n\n      // If preset is 'auto', enable adaptive quality\n      if (preset === 'auto') {\n        this.adaptiveQuality = true;\n        return null;\n      }\n      this.adaptiveQuality = false;\n\n      // Notify about quality change\n      if (this.onQualityChange) {\n        this.onQualityChange(qualitySettings);\n      }\n      return qualitySettings;\n    } catch (error) {\n      console.error('Error setting video quality:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get current quality settings\n   * @returns {Object} - Current quality settings\n   */\n  getCurrentQuality() {\n    return this.qualityPresets[this.currentQuality] || null;\n  }\n\n  /**\n   * Get all available quality presets\n   * @returns {Object} - Quality presets\n   */\n  getQualityPresets() {\n    return this.qualityPresets;\n  }\n}","map":{"version":3,"names":["WebRTCQualityMonitor","constructor","options","qualityPresets","low","id","width","height","frameRate","bitrate","medium","high","hd","currentQuality","initialQuality","adaptiveQuality","onQualityChange","onNetworkQualityChange","lastStats","networkQuality","monitorInterval","startMonitoring","peerConnection","peerId","clearInterval","setInterval","stats","getStats","videoStats","connectionStats","forEach","stat","type","kind","bytesSent","packetsSent","framesEncoded","framesSent","timestamp","state","currentRoundTripTime","availableOutgoingBitrate","_this$qualityPresets$","_this$qualityPresets$2","timeDiff","packetLoss","rtt","qualityScore","targetBitrate","targetFrameRate","Math","max","min","adaptVideoQuality","error","console","warn","stopMonitoring","targetQuality","log","setQuality","preset","qualitySettings","Error","getCurrentQuality","getQualityPresets"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcQualityMonitor.js"],"sourcesContent":["/**\n * WebRTC Quality Monitor\n * \n * Monitors WebRTC connection quality and provides adaptive streaming capabilities\n */\nexport class WebRTCQualityMonitor {\n  /**\n   * Create a new WebRTC Quality Monitor\n   * @param {Object} options - Configuration options\n   */\n  constructor(options = {}) {\n    // Quality presets\n    this.qualityPresets = {\n      low: {\n        id: 'low',\n        width: 640,\n        height: 360,\n        frameRate: 15,\n        bitrate: 400000\n      },\n      medium: {\n        id: 'medium',\n        width: 854,\n        height: 480,\n        frameRate: 24,\n        bitrate: 800000\n      },\n      high: {\n        id: 'high',\n        width: 1280,\n        height: 720,\n        frameRate: 30,\n        bitrate: 1500000\n      },\n      hd: {\n        id: 'hd',\n        width: 1920,\n        height: 1080,\n        frameRate: 30,\n        bitrate: 3000000\n      }\n    };\n    \n    // Current quality setting\n    this.currentQuality = options.initialQuality || 'high';\n    this.adaptiveQuality = options.adaptiveQuality !== false;\n    \n    // Callbacks\n    this.onQualityChange = options.onQualityChange || null;\n    this.onNetworkQualityChange = options.onNetworkQualityChange || null;\n    \n    // Stats\n    this.lastStats = {};\n    this.networkQuality = 100;\n    this.monitorInterval = null;\n  }\n  \n  /**\n   * Start monitoring network quality\n   * @param {RTCPeerConnection} peerConnection - WebRTC peer connection to monitor\n   * @param {string} peerId - ID of the peer\n   */\n  startMonitoring(peerConnection, peerId) {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n    \n    this.monitorInterval = setInterval(async () => {\n      try {\n        if (!peerConnection) return;\n        \n        // Get connection stats\n        const stats = await peerConnection.getStats();\n        const videoStats = {};\n        const connectionStats = {};\n        \n        stats.forEach(stat => {\n          // Collect video stats\n          if (stat.type === 'outbound-rtp' && stat.kind === 'video') {\n            videoStats.bytesSent = stat.bytesSent;\n            videoStats.packetsSent = stat.packetsSent;\n            videoStats.framesEncoded = stat.framesEncoded;\n            videoStats.framesSent = stat.framesSent;\n            videoStats.timestamp = stat.timestamp;\n          }\n          \n          // Collect connection stats\n          if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {\n            connectionStats.currentRoundTripTime = stat.currentRoundTripTime;\n            connectionStats.availableOutgoingBitrate = stat.availableOutgoingBitrate;\n            connectionStats.timestamp = stat.timestamp;\n          }\n        });\n        \n        // Calculate network quality\n        if (this.lastStats.timestamp) {\n          // Calculate bitrate\n          const timeDiff = (videoStats.timestamp - this.lastStats.timestamp) / 1000;\n          const bytesSent = videoStats.bytesSent - this.lastStats.bytesSent;\n          const bitrate = (bytesSent * 8) / timeDiff; // bps\n          \n          // Calculate packet loss\n          const packetsSent = videoStats.packetsSent - this.lastStats.packetsSent;\n          const packetLoss = 0; // TODO: Calculate actual packet loss\n          \n          // Calculate frame rate\n          const framesSent = videoStats.framesSent - this.lastStats.framesSent;\n          const frameRate = framesSent / timeDiff;\n          \n          // Calculate round trip time (in ms)\n          const rtt = connectionStats.currentRoundTripTime * 1000;\n          \n          // Calculate overall quality score (0-100)\n          let qualityScore = 100;\n          \n          // Reduce score based on RTT\n          if (rtt > 500) qualityScore -= 40;\n          else if (rtt > 300) qualityScore -= 25;\n          else if (rtt > 150) qualityScore -= 10;\n          else if (rtt > 100) qualityScore -= 5;\n          \n          // Reduce score based on bitrate\n          const targetBitrate = this.qualityPresets[this.currentQuality]?.bitrate || 1500000;\n          if (bitrate < targetBitrate * 0.3) qualityScore -= 40;\n          else if (bitrate < targetBitrate * 0.5) qualityScore -= 25;\n          else if (bitrate < targetBitrate * 0.7) qualityScore -= 10;\n          \n          // Reduce score based on frame rate\n          const targetFrameRate = this.qualityPresets[this.currentQuality]?.frameRate || 30;\n          if (frameRate < targetFrameRate * 0.3) qualityScore -= 30;\n          else if (frameRate < targetFrameRate * 0.5) qualityScore -= 20;\n          else if (frameRate < targetFrameRate * 0.7) qualityScore -= 10;\n          \n          // Ensure score is between 0-100\n          qualityScore = Math.max(0, Math.min(100, qualityScore));\n          \n          // Update network quality\n          this.networkQuality = qualityScore;\n          \n          // Notify about quality change\n          if (this.onNetworkQualityChange) {\n            this.onNetworkQualityChange(peerId, qualityScore, {\n              bitrate,\n              rtt,\n              frameRate,\n              packetLoss\n            });\n          }\n          \n          // Apply adaptive quality if enabled\n          if (this.adaptiveQuality) {\n            this.adaptVideoQuality(qualityScore, bitrate, rtt);\n          }\n        }\n        \n        // Store current stats for next comparison\n        this.lastStats = {\n          ...videoStats,\n          ...connectionStats\n        };\n      } catch (error) {\n        console.warn('Error monitoring network quality:', error);\n      }\n    }, 2000); // Check every 2 seconds\n  }\n  \n  /**\n   * Stop monitoring\n   */\n  stopMonitoring() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n  }\n  \n  /**\n   * Adapt video quality based on network conditions\n   * @param {number} qualityScore - Overall quality score (0-100)\n   * @param {number} bitrate - Current bitrate in bps\n   * @param {number} rtt - Round trip time in ms\n   */\n  adaptVideoQuality(qualityScore, bitrate, rtt) {\n    try {\n      let targetQuality;\n      \n      // Determine target quality based on network conditions\n      if (qualityScore < 30 || rtt > 300) {\n        targetQuality = 'low';\n      } else if (qualityScore < 60 || rtt > 150) {\n        targetQuality = 'medium';\n      } else if (qualityScore < 85 || rtt > 100) {\n        targetQuality = 'high';\n      } else {\n        targetQuality = 'hd';\n      }\n      \n      // Only change quality if it's different from current\n      if (targetQuality !== this.currentQuality) {\n        console.log(`Adapting video quality to ${targetQuality} due to network conditions`);\n        this.setQuality(targetQuality);\n      }\n    } catch (error) {\n      console.warn('Error adapting video quality:', error);\n    }\n  }\n  \n  /**\n   * Set video quality preset\n   * @param {string|Object} preset - Quality preset id or custom preset object\n   * @returns {Object} - The quality settings\n   */\n  setQuality(preset) {\n    try {\n      let qualitySettings;\n      \n      if (typeof preset === 'string') {\n        // Use predefined preset\n        qualitySettings = this.qualityPresets[preset];\n        if (!qualitySettings) {\n          throw new Error(`Unknown quality preset: ${preset}`);\n        }\n        this.currentQuality = preset;\n      } else if (typeof preset === 'object') {\n        // Use custom settings\n        qualitySettings = preset;\n        this.currentQuality = 'custom';\n      } else {\n        throw new Error('Invalid quality preset');\n      }\n      \n      // If preset is 'auto', enable adaptive quality\n      if (preset === 'auto') {\n        this.adaptiveQuality = true;\n        return null;\n      }\n      \n      this.adaptiveQuality = false;\n      \n      // Notify about quality change\n      if (this.onQualityChange) {\n        this.onQualityChange(qualitySettings);\n      }\n      \n      return qualitySettings;\n    } catch (error) {\n      console.error('Error setting video quality:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Get current quality settings\n   * @returns {Object} - Current quality settings\n   */\n  getCurrentQuality() {\n    return this.qualityPresets[this.currentQuality] || null;\n  }\n  \n  /**\n   * Get all available quality presets\n   * @returns {Object} - Quality presets\n   */\n  getQualityPresets() {\n    return this.qualityPresets;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}