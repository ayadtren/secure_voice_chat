{"ast":null,"code":"import { WebRTCQualityMonitor } from './webrtcQualityMonitor';\nimport { getOptimalVideoConstraints, isMobileDevice } from './responsiveHelper';\n\n/**\n * WebRTC Manager class\n * Handles WebRTC connections and media streams\n */\nexport class WebRTCManager {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.userId = options.userId || `user-${Math.floor(Math.random() * 10000)}`;\n    this.roomId = null;\n    this.peerConnections = new Map();\n    this.audioQualityMonitors = new Map();\n    this.localStream = null;\n    this.localVideoStream = null;\n    this.localScreenStream = null; // For screen sharing\n    this.isScreenSharing = false; // Screen sharing status\n    this.speakingDetector = null;\n    this.iceServers = options.iceServers || [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }, {\n      urls: 'stun:stun2.l.google.com:19302'\n    }];\n    this.onRemoteStreamAdded = options.onRemoteStreamAdded;\n    this.onRemoteStreamRemoved = options.onRemoteStreamRemoved;\n    this.onPeerConnected = options.onPeerConnected;\n    this.onPeerDisconnected = options.onPeerDisconnected;\n    this.onAudioLevelChange = options.onAudioLevelChange;\n    this.onVideoStatusChange = options.onVideoStatusChange;\n    this.onScreenSharingChange = options.onScreenSharingChange;\n    this.onNetworkQualityChange = options.onNetworkQualityChange;\n\n    // Initialize WebRTC quality monitor\n    this.qualityMonitor = new WebRTCQualityMonitor({\n      onQualityChange: this._handleQualityChange.bind(this),\n      adaptiveMode: options.adaptiveMode || true\n    });\n\n    // Current video quality preset\n    this.currentQuality = 'medium';\n\n    // Setup socket event listeners\n    this._setupSocketListeners();\n  }\n\n  /**\n   * Initialize WebRTC and join room\n   * @param {string} roomId - Room ID to join\n   * @returns {Promise<void>}\n   */\n  async initialize(roomId) {\n    this.roomId = roomId;\n    try {\n      // Get user media\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: false\n      });\n      this.localStream = stream;\n\n      // Join room\n      this.socket.emit('join-room', {\n        roomId: this.roomId,\n        userId: this.userId\n      });\n\n      // Setup audio level detection\n      this._setupAudioLevelDetection(stream);\n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error initializing WebRTC:', error);\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n   * Enable video\n   * @param {MediaTrackConstraints} constraints - Video constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async enableVideo(constraints = {\n    width: 640,\n    height: 480\n  }) {\n    try {\n      // Get video stream\n      const videoStream = await navigator.mediaDevices.getUserMedia({\n        video: constraints\n      });\n      this.localVideoStream = videoStream;\n\n      // Add video tracks to all peer connections\n      for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (videoTrack) {\n          peerConnection.addTrack(videoTrack, videoStream);\n\n          // Renegotiate the connection\n          await this._createAndSendOffer(peerId);\n        }\n      }\n\n      // Notify about video status change\n      if (this.onVideoStatusChange) {\n        this.onVideoStatusChange(true, videoStream);\n      }\n      return videoStream;\n    } catch (error) {\n      console.error('Error enabling video:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Disable video\n   */\n  disableVideo() {\n    if (!this.localVideoStream) {\n      return;\n    }\n\n    // Stop all video tracks\n    this.localVideoStream.getVideoTracks().forEach(track => {\n      track.stop();\n    });\n\n    // Remove video tracks from all peer connections\n    for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n      const senders = peerConnection.getSenders();\n      const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');\n      if (videoSender) {\n        peerConnection.removeTrack(videoSender);\n\n        // Renegotiate the connection\n        this._createAndSendOffer(peerId).catch(console.error);\n      }\n    }\n\n    // Reset local video stream\n    this.localVideoStream = null;\n\n    // Notify about video status change\n    if (this.onVideoStatusChange) {\n      this.onVideoStatusChange(false, null);\n    }\n  }\n\n  /**\n   * Set video quality\n   * @param {string} preset - Quality preset (low, medium, high, hd, auto)\n   * @returns {Promise<void>}\n   */\n  async setVideoQuality(preset) {\n    // Use responsive helper to get optimal constraints based on device and quality\n    const optimalConstraints = getOptimalVideoConstraints(preset);\n\n    // For backward compatibility, keep the switch but use optimal constraints\n    let constraints = optimalConstraints;\n    switch (preset) {\n      case 'low':\n        constraints = {\n          ...optimalConstraints,\n          width: {\n            ideal: optimalConstraints.width\n          },\n          height: {\n            ideal: optimalConstraints.height\n          },\n          frameRate: {\n            ideal: optimalConstraints.frameRate\n          }\n        };\n        break;\n      case 'medium':\n        constraints = {\n          ...optimalConstraints,\n          width: {\n            ideal: optimalConstraints.width\n          },\n          height: {\n            ideal: optimalConstraints.height\n          },\n          frameRate: {\n            ideal: optimalConstraints.frameRate\n          }\n        };\n        break;\n      case 'high':\n        constraints = {\n          ...optimalConstraints,\n          width: {\n            ideal: optimalConstraints.width\n          },\n          height: {\n            ideal: optimalConstraints.height\n          },\n          frameRate: {\n            ideal: optimalConstraints.frameRate\n          }\n        };\n        break;\n      case 'hd':\n        constraints = {\n          ...optimalConstraints,\n          width: {\n            ideal: optimalConstraints.width\n          },\n          height: {\n            ideal: optimalConstraints.height\n          },\n          frameRate: {\n            ideal: optimalConstraints.frameRate\n          }\n        };\n        break;\n      case 'auto':\n      default:\n        // Use adaptive quality based on network conditions\n        this.qualityMonitor.setAdaptiveMode(true);\n        constraints = {\n          width: 1280,\n          height: 720,\n          frameRate: 30\n        };\n        break;\n    }\n\n    // Store current quality\n    this.currentQuality = preset;\n\n    // Disable adaptive mode if not auto\n    if (preset !== 'auto') {\n      this.qualityMonitor.setAdaptiveMode(false);\n    }\n\n    // If video is already enabled, update constraints\n    if (this.localVideoStream) {\n      // Get current video track\n      const videoTrack = this.localVideoStream.getVideoTracks()[0];\n      if (videoTrack) {\n        // Apply new constraints\n        try {\n          await videoTrack.applyConstraints(constraints);\n\n          // Notify about quality change\n          if (this.onNetworkQualityChange) {\n            this.onNetworkQualityChange(100, {\n              preset\n            });\n          }\n        } catch (error) {\n          console.error('Error applying video constraints:', error);\n\n          // Fallback: restart video with new constraints\n          this.disableVideo();\n          await this.enableVideo(constraints);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get available video devices\n   * @returns {Promise<MediaDeviceInfo[]>}\n   */\n  async getVideoDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'videoinput');\n    } catch (error) {\n      console.error('Error getting video devices:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Change video device\n   * @param {string} deviceId - Device ID\n   * @returns {Promise<MediaStream>}\n   */\n  async changeVideoDevice(deviceId) {\n    try {\n      // Get current constraints\n      let constraints = {\n        deviceId: {\n          exact: deviceId\n        }\n      };\n\n      // Add quality constraints if available\n      if (this.currentQuality) {\n        const qualityConstraints = getOptimalVideoConstraints(this.currentQuality);\n        constraints = {\n          ...constraints,\n          width: {\n            ideal: qualityConstraints.width\n          },\n          height: {\n            ideal: qualityConstraints.height\n          },\n          frameRate: {\n            ideal: qualityConstraints.frameRate\n          }\n        };\n      }\n\n      // Disable current video\n      this.disableVideo();\n\n      // Enable video with new device\n      return await this.enableVideo(constraints);\n    } catch (error) {\n      console.error('Error changing video device:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Leave room\n   */\n  leaveRoom() {\n    // Emit leave room event\n    this.socket.emit('leave-room', {\n      roomId: this.roomId,\n      userId: this.userId\n    });\n\n    // Reset room ID\n    this.roomId = null;\n\n    // Disconnect from all peers\n    this.disconnect();\n  }\n\n  /**\n   * Disconnect from all peers\n   */\n  disconnect() {\n    // Stop all local streams\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    if (this.localVideoStream) {\n      this.localVideoStream.getTracks().forEach(track => track.stop());\n      this.localVideoStream = null;\n    }\n    if (this.localScreenStream) {\n      this.localScreenStream.getTracks().forEach(track => track.stop());\n      this.localScreenStream = null;\n      this.isScreenSharing = false;\n    }\n\n    // Close all peer connections\n    for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n      if (peerConnection) {\n        peerConnection.close();\n      }\n    }\n    this.peerConnections.clear();\n    this.audioQualityMonitors.clear();\n\n    // Remove socket listeners\n    this.socket.off('user-connected');\n    this.socket.off('user-disconnected');\n    this.socket.off('receive-signal');\n  }\n\n  /**\n   * Handle quality change from WebRTCQualityMonitor\n   * @param {number} quality - Quality score (0-100)\n   * @param {Object} metrics - Quality metrics\n   * @private\n   */\n  _handleQualityChange(quality, metrics) {\n    // Notify about quality change\n    if (this.onNetworkQualityChange) {\n      this.onNetworkQualityChange(quality, metrics);\n    }\n\n    // If in adaptive mode, adjust video quality\n    if (this.qualityMonitor.isAdaptiveMode() && this.localVideoStream) {\n      const videoTrack = this.localVideoStream.getVideoTracks()[0];\n      if (videoTrack) {\n        // Get target constraints based on quality\n        const constraints = this.qualityMonitor.getTargetConstraints(quality);\n        if (constraints) {\n          // Apply constraints\n          videoTrack.applyConstraints(constraints).catch(console.error);\n        }\n      }\n    }\n  }\n\n  /**\n   * Setup socket event listeners\n   * @private\n   */\n  _setupSocketListeners() {\n    // Handle user connected event\n    this.socket.on('user-connected', async ({\n      userId\n    }) => {\n      console.log('User connected:', userId);\n\n      // Create peer connection\n      await this._createPeerConnection(userId);\n\n      // Notify about peer connected\n      if (this.onPeerConnected) {\n        this.onPeerConnected(userId);\n      }\n    });\n\n    // Handle user disconnected event\n    this.socket.on('user-disconnected', ({\n      userId\n    }) => {\n      console.log('User disconnected:', userId);\n\n      // Close peer connection\n      this._closePeerConnection(userId);\n\n      // Notify about peer disconnected\n      if (this.onPeerDisconnected) {\n        this.onPeerDisconnected(userId);\n      }\n    });\n\n    // Handle receive signal event\n    this.socket.on('receive-signal', async ({\n      userId,\n      signal\n    }) => {\n      try {\n        // Create peer connection if not exists\n        if (!this.peerConnections.has(userId)) {\n          await this._createPeerConnection(userId);\n        }\n        const peerConnection = this.peerConnections.get(userId);\n\n        // Handle signal\n        if (signal.type === 'offer') {\n          await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));\n          const answer = await peerConnection.createAnswer();\n          await peerConnection.setLocalDescription(answer);\n\n          // Send answer\n          this.socket.emit('send-signal', {\n            roomId: this.roomId,\n            userId: this.userId,\n            targetUserId: userId,\n            signal: answer\n          });\n        } else if (signal.type === 'answer') {\n          await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));\n        } else if (signal.candidate) {\n          await peerConnection.addIceCandidate(new RTCIceCandidate(signal));\n        }\n      } catch (error) {\n        console.error('Error handling signal:', error);\n      }\n    });\n  }\n\n  /**\n   * Create peer connection\n   * @param {string} peerId - Peer ID\n   * @returns {Promise<RTCPeerConnection>}\n   * @private\n   */\n  async _createPeerConnection(peerId) {\n    try {\n      // Create peer connection\n      const peerConnection = new RTCPeerConnection({\n        iceServers: this.iceServers\n      });\n\n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n\n      // Add local stream tracks\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n\n      // Add local video stream tracks\n      if (this.localVideoStream) {\n        this.localVideoStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localVideoStream);\n        });\n      }\n\n      // Add local screen stream tracks (if screen sharing is active)\n      if (this.isScreenSharing && this.localScreenStream) {\n        const screenTrack = this.localScreenStream.getVideoTracks()[0];\n        if (screenTrack) {\n          // Find existing video sender\n          const senders = peerConnection.getSenders();\n          const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');\n          if (videoSender) {\n            // Replace existing video track with screen track\n            await videoSender.replaceTrack(screenTrack);\n          } else {\n            // Add screen track if no video sender exists\n            peerConnection.addTrack(screenTrack, this.localScreenStream);\n          }\n        }\n      }\n\n      // Handle ICE candidate event\n      peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          // Send ICE candidate\n          this.socket.emit('send-signal', {\n            roomId: this.roomId,\n            userId: this.userId,\n            targetUserId: peerId,\n            signal: event.candidate\n          });\n        }\n      };\n\n      // Handle track event\n      peerConnection.ontrack = event => {\n        // Create remote stream if not exists\n        const remoteStream = new MediaStream();\n\n        // Add track to remote stream\n        remoteStream.addTrack(event.track);\n\n        // Notify about remote stream added\n        if (this.onRemoteStreamAdded) {\n          this.onRemoteStreamAdded(peerId, remoteStream);\n        }\n\n        // Setup audio level detection for remote stream\n        if (event.track.kind === 'audio') {\n          this._setupRemoteAudioLevelDetection(peerId, remoteStream);\n        }\n\n        // Setup quality monitoring\n        this.qualityMonitor.monitorConnection(peerConnection);\n      };\n\n      // Handle connection state change event\n      peerConnection.onconnectionstatechange = () => {\n        if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'closed') {\n          // Notify about remote stream removed\n          if (this.onRemoteStreamRemoved) {\n            this.onRemoteStreamRemoved(peerId);\n          }\n\n          // Remove audio level detection\n          if (this.audioQualityMonitors.has(peerId)) {\n            this.audioQualityMonitors.delete(peerId);\n          }\n        }\n      };\n\n      // Create and send offer\n      await this._createAndSendOffer(peerId);\n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create and send offer\n   * @param {string} peerId - Peer ID\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        throw new Error(`Peer connection not found for ${peerId}`);\n      }\n\n      // Create offer\n      const offer = await peerConnection.createOffer();\n\n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n\n      // Send offer\n      this.socket.emit('send-signal', {\n        roomId: this.roomId,\n        userId: this.userId,\n        targetUserId: peerId,\n        signal: offer\n      });\n    } catch (error) {\n      console.error('Error creating and sending offer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Close peer connection\n   * @param {string} peerId - Peer ID\n   * @private\n   */\n  _closePeerConnection(peerId) {\n    // Get peer connection\n    const peerConnection = this.peerConnections.get(peerId);\n    if (peerConnection) {\n      // Close peer connection\n      peerConnection.close();\n\n      // Remove peer connection\n      this.peerConnections.delete(peerId);\n\n      // Remove audio level detection\n      if (this.audioQualityMonitors.has(peerId)) {\n        this.audioQualityMonitors.delete(peerId);\n      }\n\n      // Notify about remote stream removed\n      if (this.onRemoteStreamRemoved) {\n        this.onRemoteStreamRemoved(peerId);\n      }\n    }\n  }\n\n  /**\n   * Setup audio level detection\n   * @param {MediaStream} stream - Media stream\n   * @private\n   */\n  _setupAudioLevelDetection(stream) {\n    try {\n      // Create audio context\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n      // Create analyser\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 512;\n      analyser.smoothingTimeConstant = 0.1;\n\n      // Create source\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Create data array\n      const dataArray = new Uint8Array(analyser.frequencyBinCount);\n\n      // Create speaking detector\n      this.speakingDetector = {\n        analyser,\n        dataArray,\n        threshold: 30,\n        speakingHistory: Array(5).fill(false),\n        isSpeaking: false\n      };\n\n      // Start detection loop\n      this._detectAudioLevel();\n    } catch (error) {\n      console.error('Error setting up audio level detection:', error);\n    }\n  }\n\n  /**\n   * Setup remote audio level detection\n   * @param {string} peerId - Peer ID\n   * @param {MediaStream} stream - Media stream\n   * @private\n   */\n  _setupRemoteAudioLevelDetection(peerId, stream) {\n    try {\n      // Create audio context\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n      // Create analyser\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 512;\n      analyser.smoothingTimeConstant = 0.1;\n\n      // Create source\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Create data array\n      const dataArray = new Uint8Array(analyser.frequencyBinCount);\n\n      // Create speaking detector\n      const speakingDetector = {\n        analyser,\n        dataArray,\n        threshold: 30,\n        speakingHistory: Array(5).fill(false),\n        isSpeaking: false\n      };\n\n      // Store speaking detector\n      this.audioQualityMonitors.set(peerId, speakingDetector);\n\n      // Start detection loop\n      this._detectRemoteAudioLevel(peerId);\n    } catch (error) {\n      console.error('Error setting up remote audio level detection:', error);\n    }\n  }\n\n  /**\n   * Detect audio level\n   * @private\n   */\n  _detectAudioLevel() {\n    if (!this.speakingDetector) {\n      return;\n    }\n\n    // Get speaking detector\n    const {\n      analyser,\n      dataArray,\n      threshold,\n      speakingHistory\n    } = this.speakingDetector;\n\n    // Get audio level\n    analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const average = sum / dataArray.length;\n\n    // Check if speaking\n    const isSpeakingNow = average > threshold;\n\n    // Update speaking history\n    speakingHistory.shift();\n    speakingHistory.push(isSpeakingNow);\n\n    // Check if speaking status changed\n    const isSpeakingMajority = speakingHistory.filter(Boolean).length > speakingHistory.length / 2;\n    if (isSpeakingMajority !== this.speakingDetector.isSpeaking) {\n      // Update speaking status\n      this.speakingDetector.isSpeaking = isSpeakingMajority;\n\n      // Notify about audio level change\n      if (this.onAudioLevelChange) {\n        this.onAudioLevelChange(this.userId, isSpeakingMajority, average);\n      }\n    }\n\n    // Continue detection loop\n    requestAnimationFrame(() => this._detectAudioLevel());\n  }\n\n  /**\n   * Detect remote audio level\n   * @param {string} peerId - Peer ID\n   * @private\n   */\n  _detectRemoteAudioLevel(peerId) {\n    // Get speaking detector\n    const speakingDetector = this.audioQualityMonitors.get(peerId);\n    if (!speakingDetector) {\n      return;\n    }\n\n    // Get audio level\n    const {\n      analyser,\n      dataArray,\n      threshold,\n      speakingHistory\n    } = speakingDetector;\n    analyser.getByteFrequencyData(dataArray);\n\n    // Calculate average level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const average = sum / dataArray.length;\n\n    // Check if speaking\n    const isSpeakingNow = average > threshold;\n\n    // Update speaking history\n    speakingHistory.shift();\n    speakingHistory.push(isSpeakingNow);\n\n    // Check if speaking status changed\n    const isSpeakingMajority = speakingHistory.filter(Boolean).length > speakingHistory.length / 2;\n    if (isSpeakingMajority !== speakingDetector.isSpeaking) {\n      // Update speaking status\n      speakingDetector.isSpeaking = isSpeakingMajority;\n\n      // Notify about audio level change\n      if (this.onAudioLevelChange) {\n        this.onAudioLevelChange(peerId, isSpeakingMajority, average);\n      }\n    }\n\n    // Continue detection loop\n    requestAnimationFrame(() => this._detectRemoteAudioLevel(peerId));\n  }\n\n  /**\n   * Start screen sharing\n   * @returns {Promise<boolean>} Success status\n   */\n  async startScreenSharing() {\n    try {\n      if (this.isScreenSharing) {\n        return true;\n      }\n\n      // Get screen sharing stream\n      const screenStream = await navigator.mediaDevices.getDisplayMedia({\n        video: {\n          cursor: 'always',\n          displaySurface: 'monitor',\n          logicalSurface: true,\n          frameRate: 30\n        },\n        audio: false\n      });\n\n      // Store screen stream\n      this.localScreenStream = screenStream;\n      this.isScreenSharing = true;\n\n      // Add screen track to all peer connections\n      for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n        const screenTrack = screenStream.getVideoTracks()[0];\n\n        // Find existing video sender\n        const senders = peerConnection.getSenders();\n        const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');\n        if (videoSender) {\n          // Replace existing video track with screen track\n          await videoSender.replaceTrack(screenTrack);\n        } else {\n          // Add screen track if no video sender exists\n          peerConnection.addTrack(screenTrack, screenStream);\n\n          // Renegotiate the connection\n          await this._createAndSendOffer(peerId);\n        }\n      }\n\n      // Handle screen sharing stop event\n      screenStream.getVideoTracks()[0].addEventListener('ended', () => {\n        this.stopScreenSharing();\n      });\n\n      // Notify about screen sharing\n      if (this.onScreenSharingChange) {\n        this.onScreenSharingChange(true, screenStream);\n      }\n      return true;\n    } catch (error) {\n      console.error('Error starting screen sharing:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Stop screen sharing\n   * @returns {Promise<boolean>} Success status\n   */\n  async stopScreenSharing() {\n    try {\n      if (!this.isScreenSharing || !this.localScreenStream) {\n        return false;\n      }\n\n      // Stop all screen tracks\n      this.localScreenStream.getTracks().forEach(track => track.stop());\n\n      // Reset screen sharing state\n      this.localScreenStream = null;\n      this.isScreenSharing = false;\n\n      // Restore video tracks in all peer connections\n      if (this.localVideoStream) {\n        const videoTrack = this.localVideoStream.getVideoTracks()[0];\n        for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n          const senders = peerConnection.getSenders();\n          const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');\n          if (videoSender && videoTrack) {\n            await videoSender.replaceTrack(videoTrack);\n          }\n        }\n      }\n\n      // Notify about screen sharing stop\n      if (this.onScreenSharingChange) {\n        this.onScreenSharingChange(false, null);\n      }\n      return true;\n    } catch (error) {\n      console.error('Error stopping screen sharing:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Toggle screen sharing\n   * @returns {Promise<boolean>} New screen sharing status\n   */\n  async toggleScreenSharing() {\n    if (this.isScreenSharing) {\n      return await this.stopScreenSharing();\n    } else {\n      return await this.startScreenSharing();\n    }\n  }\n\n  /**\n   * Check if screen sharing is enabled\n   * @returns {boolean} Screen sharing status\n   */\n  isScreenSharingEnabled() {\n    return this.isScreenSharing;\n  }\n}","map":{"version":3,"names":["WebRTCQualityMonitor","getOptimalVideoConstraints","isMobileDevice","WebRTCManager","constructor","socket","options","userId","Math","floor","random","roomId","peerConnections","Map","audioQualityMonitors","localStream","localVideoStream","localScreenStream","isScreenSharing","speakingDetector","iceServers","urls","onRemoteStreamAdded","onRemoteStreamRemoved","onPeerConnected","onPeerDisconnected","onAudioLevelChange","onVideoStatusChange","onScreenSharingChange","onNetworkQualityChange","qualityMonitor","onQualityChange","_handleQualityChange","bind","adaptiveMode","currentQuality","_setupSocketListeners","initialize","stream","navigator","mediaDevices","getUserMedia","audio","video","emit","_setupAudioLevelDetection","Promise","resolve","error","console","reject","enableVideo","constraints","width","height","videoStream","peerId","peerConnection","entries","videoTrack","getVideoTracks","addTrack","_createAndSendOffer","disableVideo","forEach","track","stop","senders","getSenders","videoSender","find","sender","kind","removeTrack","catch","setVideoQuality","preset","optimalConstraints","ideal","frameRate","setAdaptiveMode","applyConstraints","getVideoDevices","devices","enumerateDevices","filter","device","changeVideoDevice","deviceId","exact","qualityConstraints","leaveRoom","disconnect","getTracks","close","clear","off","quality","metrics","isAdaptiveMode","getTargetConstraints","on","log","_createPeerConnection","_closePeerConnection","signal","has","get","type","setRemoteDescription","RTCSessionDescription","answer","createAnswer","setLocalDescription","targetUserId","candidate","addIceCandidate","RTCIceCandidate","RTCPeerConnection","set","screenTrack","replaceTrack","onicecandidate","event","ontrack","remoteStream","MediaStream","_setupRemoteAudioLevelDetection","monitorConnection","onconnectionstatechange","connectionState","delete","Error","offer","createOffer","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","fftSize","smoothingTimeConstant","source","createMediaStreamSource","connect","dataArray","Uint8Array","frequencyBinCount","threshold","speakingHistory","Array","fill","isSpeaking","_detectAudioLevel","_detectRemoteAudioLevel","getByteFrequencyData","sum","i","length","average","isSpeakingNow","shift","push","isSpeakingMajority","Boolean","requestAnimationFrame","startScreenSharing","screenStream","getDisplayMedia","cursor","displaySurface","logicalSurface","addEventListener","stopScreenSharing","toggleScreenSharing","isScreenSharingEnabled"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcManager.js"],"sourcesContent":["import { WebRTCQualityMonitor } from './webrtcQualityMonitor';\nimport { getOptimalVideoConstraints, isMobileDevice } from './responsiveHelper';\n\n/**\n * WebRTC Manager class\n * Handles WebRTC connections and media streams\n */\nexport class WebRTCManager {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.userId = options.userId || `user-${Math.floor(Math.random() * 10000)}`;\n    this.roomId = null;\n    this.peerConnections = new Map();\n    this.audioQualityMonitors = new Map();\n    this.localStream = null;\n    this.localVideoStream = null;\n    this.localScreenStream = null; // For screen sharing\n    this.isScreenSharing = false; // Screen sharing status\n    this.speakingDetector = null;\n    this.iceServers = options.iceServers || [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' },\n      { urls: 'stun:stun2.l.google.com:19302' },\n    ];\n    this.onRemoteStreamAdded = options.onRemoteStreamAdded;\n    this.onRemoteStreamRemoved = options.onRemoteStreamRemoved;\n    this.onPeerConnected = options.onPeerConnected;\n    this.onPeerDisconnected = options.onPeerDisconnected;\n    this.onAudioLevelChange = options.onAudioLevelChange;\n    this.onVideoStatusChange = options.onVideoStatusChange;\n    this.onScreenSharingChange = options.onScreenSharingChange;\n    this.onNetworkQualityChange = options.onNetworkQualityChange;\n    \n    // Initialize WebRTC quality monitor\n    this.qualityMonitor = new WebRTCQualityMonitor({\n      onQualityChange: this._handleQualityChange.bind(this),\n      adaptiveMode: options.adaptiveMode || true\n    });\n    \n    // Current video quality preset\n    this.currentQuality = 'medium';\n    \n    // Setup socket event listeners\n    this._setupSocketListeners();\n  }\n\n  /**\n   * Initialize WebRTC and join room\n   * @param {string} roomId - Room ID to join\n   * @returns {Promise<void>}\n   */\n  async initialize(roomId) {\n    this.roomId = roomId;\n    \n    try {\n      // Get user media\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: false\n      });\n      \n      this.localStream = stream;\n      \n      // Join room\n      this.socket.emit('join-room', {\n        roomId: this.roomId,\n        userId: this.userId\n      });\n      \n      // Setup audio level detection\n      this._setupAudioLevelDetection(stream);\n      \n      return Promise.resolve();\n    } catch (error) {\n      console.error('Error initializing WebRTC:', error);\n      return Promise.reject(error);\n    }\n  }\n  \n  /**\n   * Enable video\n   * @param {MediaTrackConstraints} constraints - Video constraints\n   * @returns {Promise<MediaStream>}\n   */\n  async enableVideo(constraints = { width: 640, height: 480 }) {\n    try {\n      // Get video stream\n      const videoStream = await navigator.mediaDevices.getUserMedia({\n        video: constraints\n      });\n      \n      this.localVideoStream = videoStream;\n      \n      // Add video tracks to all peer connections\n      for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        \n        if (videoTrack) {\n          peerConnection.addTrack(videoTrack, videoStream);\n          \n          // Renegotiate the connection\n          await this._createAndSendOffer(peerId);\n        }\n      }\n      \n      // Notify about video status change\n      if (this.onVideoStatusChange) {\n        this.onVideoStatusChange(true, videoStream);\n      }\n      \n      return videoStream;\n    } catch (error) {\n      console.error('Error enabling video:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Disable video\n   */\n  disableVideo() {\n    if (!this.localVideoStream) {\n      return;\n    }\n    \n    // Stop all video tracks\n    this.localVideoStream.getVideoTracks().forEach(track => {\n      track.stop();\n    });\n    \n    // Remove video tracks from all peer connections\n    for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n      const senders = peerConnection.getSenders();\n      const videoSender = senders.find(sender => \n        sender.track && sender.track.kind === 'video'\n      );\n      \n      if (videoSender) {\n        peerConnection.removeTrack(videoSender);\n        \n        // Renegotiate the connection\n        this._createAndSendOffer(peerId).catch(console.error);\n      }\n    }\n    \n    // Reset local video stream\n    this.localVideoStream = null;\n    \n    // Notify about video status change\n    if (this.onVideoStatusChange) {\n      this.onVideoStatusChange(false, null);\n    }\n  }\n  \n  /**\n   * Set video quality\n   * @param {string} preset - Quality preset (low, medium, high, hd, auto)\n   * @returns {Promise<void>}\n   */\n  async setVideoQuality(preset) {\n    // Use responsive helper to get optimal constraints based on device and quality\n    const optimalConstraints = getOptimalVideoConstraints(preset);\n    \n    // For backward compatibility, keep the switch but use optimal constraints\n    let constraints = optimalConstraints;\n    \n    switch (preset) {\n      case 'low':\n        constraints = { ...optimalConstraints, width: { ideal: optimalConstraints.width }, height: { ideal: optimalConstraints.height }, frameRate: { ideal: optimalConstraints.frameRate } };\n        break;\n      case 'medium':\n        constraints = { ...optimalConstraints, width: { ideal: optimalConstraints.width }, height: { ideal: optimalConstraints.height }, frameRate: { ideal: optimalConstraints.frameRate } };\n        break;\n      case 'high':\n        constraints = { ...optimalConstraints, width: { ideal: optimalConstraints.width }, height: { ideal: optimalConstraints.height }, frameRate: { ideal: optimalConstraints.frameRate } };\n        break;\n      case 'hd':\n        constraints = { ...optimalConstraints, width: { ideal: optimalConstraints.width }, height: { ideal: optimalConstraints.height }, frameRate: { ideal: optimalConstraints.frameRate } };\n        break;\n      case 'auto':\n      default:\n        // Use adaptive quality based on network conditions\n        this.qualityMonitor.setAdaptiveMode(true);\n        constraints = { width: 1280, height: 720, frameRate: 30 };\n        break;\n    }\n    \n    // Store current quality\n    this.currentQuality = preset;\n    \n    // Disable adaptive mode if not auto\n    if (preset !== 'auto') {\n      this.qualityMonitor.setAdaptiveMode(false);\n    }\n    \n    // If video is already enabled, update constraints\n    if (this.localVideoStream) {\n      // Get current video track\n      const videoTrack = this.localVideoStream.getVideoTracks()[0];\n      \n      if (videoTrack) {\n        // Apply new constraints\n        try {\n          await videoTrack.applyConstraints(constraints);\n          \n          // Notify about quality change\n          if (this.onNetworkQualityChange) {\n            this.onNetworkQualityChange(100, { preset });\n          }\n        } catch (error) {\n          console.error('Error applying video constraints:', error);\n          \n          // Fallback: restart video with new constraints\n          this.disableVideo();\n          await this.enableVideo(constraints);\n        }\n      }\n    }\n  }\n  \n  /**\n   * Get available video devices\n   * @returns {Promise<MediaDeviceInfo[]>}\n   */\n  async getVideoDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'videoinput');\n    } catch (error) {\n      console.error('Error getting video devices:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * Change video device\n   * @param {string} deviceId - Device ID\n   * @returns {Promise<MediaStream>}\n   */\n  async changeVideoDevice(deviceId) {\n    try {\n      // Get current constraints\n      let constraints = { deviceId: { exact: deviceId } };\n      \n      // Add quality constraints if available\n      if (this.currentQuality) {\n        const qualityConstraints = getOptimalVideoConstraints(this.currentQuality);\n        constraints = {\n          ...constraints,\n          width: { ideal: qualityConstraints.width },\n          height: { ideal: qualityConstraints.height },\n          frameRate: { ideal: qualityConstraints.frameRate }\n        };\n      }\n      \n      // Disable current video\n      this.disableVideo();\n      \n      // Enable video with new device\n      return await this.enableVideo(constraints);\n    } catch (error) {\n      console.error('Error changing video device:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Leave room\n   */\n  leaveRoom() {\n    // Emit leave room event\n    this.socket.emit('leave-room', {\n      roomId: this.roomId,\n      userId: this.userId\n    });\n    \n    // Reset room ID\n    this.roomId = null;\n    \n    // Disconnect from all peers\n    this.disconnect();\n  }\n  \n  /**\n   * Disconnect from all peers\n   */\n  disconnect() {\n    // Stop all local streams\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    \n    if (this.localVideoStream) {\n      this.localVideoStream.getTracks().forEach(track => track.stop());\n      this.localVideoStream = null;\n    }\n    \n    if (this.localScreenStream) {\n      this.localScreenStream.getTracks().forEach(track => track.stop());\n      this.localScreenStream = null;\n      this.isScreenSharing = false;\n    }\n    \n    // Close all peer connections\n    for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n      if (peerConnection) {\n        peerConnection.close();\n      }\n    }\n    \n    this.peerConnections.clear();\n    this.audioQualityMonitors.clear();\n    \n    // Remove socket listeners\n    this.socket.off('user-connected');\n    this.socket.off('user-disconnected');\n    this.socket.off('receive-signal');\n  }\n  \n  /**\n   * Handle quality change from WebRTCQualityMonitor\n   * @param {number} quality - Quality score (0-100)\n   * @param {Object} metrics - Quality metrics\n   * @private\n   */\n  _handleQualityChange(quality, metrics) {\n    // Notify about quality change\n    if (this.onNetworkQualityChange) {\n      this.onNetworkQualityChange(quality, metrics);\n    }\n    \n    // If in adaptive mode, adjust video quality\n    if (this.qualityMonitor.isAdaptiveMode() && this.localVideoStream) {\n      const videoTrack = this.localVideoStream.getVideoTracks()[0];\n      \n      if (videoTrack) {\n        // Get target constraints based on quality\n        const constraints = this.qualityMonitor.getTargetConstraints(quality);\n        \n        if (constraints) {\n          // Apply constraints\n          videoTrack.applyConstraints(constraints).catch(console.error);\n        }\n      }\n    }\n  }\n  \n  /**\n   * Setup socket event listeners\n   * @private\n   */\n  _setupSocketListeners() {\n    // Handle user connected event\n    this.socket.on('user-connected', async ({ userId }) => {\n      console.log('User connected:', userId);\n      \n      // Create peer connection\n      await this._createPeerConnection(userId);\n      \n      // Notify about peer connected\n      if (this.onPeerConnected) {\n        this.onPeerConnected(userId);\n      }\n    });\n    \n    // Handle user disconnected event\n    this.socket.on('user-disconnected', ({ userId }) => {\n      console.log('User disconnected:', userId);\n      \n      // Close peer connection\n      this._closePeerConnection(userId);\n      \n      // Notify about peer disconnected\n      if (this.onPeerDisconnected) {\n        this.onPeerDisconnected(userId);\n      }\n    });\n    \n    // Handle receive signal event\n    this.socket.on('receive-signal', async ({ userId, signal }) => {\n      try {\n        // Create peer connection if not exists\n        if (!this.peerConnections.has(userId)) {\n          await this._createPeerConnection(userId);\n        }\n        \n        const peerConnection = this.peerConnections.get(userId);\n        \n        // Handle signal\n        if (signal.type === 'offer') {\n          await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));\n          const answer = await peerConnection.createAnswer();\n          await peerConnection.setLocalDescription(answer);\n          \n          // Send answer\n          this.socket.emit('send-signal', {\n            roomId: this.roomId,\n            userId: this.userId,\n            targetUserId: userId,\n            signal: answer\n          });\n        } else if (signal.type === 'answer') {\n          await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));\n        } else if (signal.candidate) {\n          await peerConnection.addIceCandidate(new RTCIceCandidate(signal));\n        }\n      } catch (error) {\n        console.error('Error handling signal:', error);\n      }\n    });\n  }\n  \n  /**\n   * Create peer connection\n   * @param {string} peerId - Peer ID\n   * @returns {Promise<RTCPeerConnection>}\n   * @private\n   */\n  async _createPeerConnection(peerId) {\n    try {\n      // Create peer connection\n      const peerConnection = new RTCPeerConnection({\n        iceServers: this.iceServers\n      });\n      \n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n      \n      // Add local stream tracks\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Add local video stream tracks\n      if (this.localVideoStream) {\n        this.localVideoStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localVideoStream);\n        });\n      }\n      \n      // Add local screen stream tracks (if screen sharing is active)\n      if (this.isScreenSharing && this.localScreenStream) {\n        const screenTrack = this.localScreenStream.getVideoTracks()[0];\n        \n        if (screenTrack) {\n          // Find existing video sender\n          const senders = peerConnection.getSenders();\n          const videoSender = senders.find(sender => \n            sender.track && sender.track.kind === 'video'\n          );\n          \n          if (videoSender) {\n            // Replace existing video track with screen track\n            await videoSender.replaceTrack(screenTrack);\n          } else {\n            // Add screen track if no video sender exists\n            peerConnection.addTrack(screenTrack, this.localScreenStream);\n          }\n        }\n      }\n      \n      // Handle ICE candidate event\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          // Send ICE candidate\n          this.socket.emit('send-signal', {\n            roomId: this.roomId,\n            userId: this.userId,\n            targetUserId: peerId,\n            signal: event.candidate\n          });\n        }\n      };\n      \n      // Handle track event\n      peerConnection.ontrack = (event) => {\n        // Create remote stream if not exists\n        const remoteStream = new MediaStream();\n        \n        // Add track to remote stream\n        remoteStream.addTrack(event.track);\n        \n        // Notify about remote stream added\n        if (this.onRemoteStreamAdded) {\n          this.onRemoteStreamAdded(peerId, remoteStream);\n        }\n        \n        // Setup audio level detection for remote stream\n        if (event.track.kind === 'audio') {\n          this._setupRemoteAudioLevelDetection(peerId, remoteStream);\n        }\n        \n        // Setup quality monitoring\n        this.qualityMonitor.monitorConnection(peerConnection);\n      };\n      \n      // Handle connection state change event\n      peerConnection.onconnectionstatechange = () => {\n        if (peerConnection.connectionState === 'disconnected' || \n            peerConnection.connectionState === 'failed' ||\n            peerConnection.connectionState === 'closed') {\n          // Notify about remote stream removed\n          if (this.onRemoteStreamRemoved) {\n            this.onRemoteStreamRemoved(peerId);\n          }\n          \n          // Remove audio level detection\n          if (this.audioQualityMonitors.has(peerId)) {\n            this.audioQualityMonitors.delete(peerId);\n          }\n        }\n      };\n      \n      // Create and send offer\n      await this._createAndSendOffer(peerId);\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create and send offer\n   * @param {string} peerId - Peer ID\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      \n      if (!peerConnection) {\n        throw new Error(`Peer connection not found for ${peerId}`);\n      }\n      \n      // Create offer\n      const offer = await peerConnection.createOffer();\n      \n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      \n      // Send offer\n      this.socket.emit('send-signal', {\n        roomId: this.roomId,\n        userId: this.userId,\n        targetUserId: peerId,\n        signal: offer\n      });\n    } catch (error) {\n      console.error('Error creating and sending offer:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Close peer connection\n   * @param {string} peerId - Peer ID\n   * @private\n   */\n  _closePeerConnection(peerId) {\n    // Get peer connection\n    const peerConnection = this.peerConnections.get(peerId);\n    \n    if (peerConnection) {\n      // Close peer connection\n      peerConnection.close();\n      \n      // Remove peer connection\n      this.peerConnections.delete(peerId);\n      \n      // Remove audio level detection\n      if (this.audioQualityMonitors.has(peerId)) {\n        this.audioQualityMonitors.delete(peerId);\n      }\n      \n      // Notify about remote stream removed\n      if (this.onRemoteStreamRemoved) {\n        this.onRemoteStreamRemoved(peerId);\n      }\n    }\n  }\n  \n  /**\n   * Setup audio level detection\n   * @param {MediaStream} stream - Media stream\n   * @private\n   */\n  _setupAudioLevelDetection(stream) {\n    try {\n      // Create audio context\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      \n      // Create analyser\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 512;\n      analyser.smoothingTimeConstant = 0.1;\n      \n      // Create source\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n      \n      // Create data array\n      const dataArray = new Uint8Array(analyser.frequencyBinCount);\n      \n      // Create speaking detector\n      this.speakingDetector = {\n        analyser,\n        dataArray,\n        threshold: 30,\n        speakingHistory: Array(5).fill(false),\n        isSpeaking: false\n      };\n      \n      // Start detection loop\n      this._detectAudioLevel();\n    } catch (error) {\n      console.error('Error setting up audio level detection:', error);\n    }\n  }\n  \n  /**\n   * Setup remote audio level detection\n   * @param {string} peerId - Peer ID\n   * @param {MediaStream} stream - Media stream\n   * @private\n   */\n  _setupRemoteAudioLevelDetection(peerId, stream) {\n    try {\n      // Create audio context\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      \n      // Create analyser\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 512;\n      analyser.smoothingTimeConstant = 0.1;\n      \n      // Create source\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n      \n      // Create data array\n      const dataArray = new Uint8Array(analyser.frequencyBinCount);\n      \n      // Create speaking detector\n      const speakingDetector = {\n        analyser,\n        dataArray,\n        threshold: 30,\n        speakingHistory: Array(5).fill(false),\n        isSpeaking: false\n      };\n      \n      // Store speaking detector\n      this.audioQualityMonitors.set(peerId, speakingDetector);\n      \n      // Start detection loop\n      this._detectRemoteAudioLevel(peerId);\n    } catch (error) {\n      console.error('Error setting up remote audio level detection:', error);\n    }\n  }\n  \n  /**\n   * Detect audio level\n   * @private\n   */\n  _detectAudioLevel() {\n    if (!this.speakingDetector) {\n      return;\n    }\n    \n    // Get speaking detector\n    const { analyser, dataArray, threshold, speakingHistory } = this.speakingDetector;\n    \n    // Get audio level\n    analyser.getByteFrequencyData(dataArray);\n    \n    // Calculate average level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const average = sum / dataArray.length;\n    \n    // Check if speaking\n    const isSpeakingNow = average > threshold;\n    \n    // Update speaking history\n    speakingHistory.shift();\n    speakingHistory.push(isSpeakingNow);\n    \n    // Check if speaking status changed\n    const isSpeakingMajority = speakingHistory.filter(Boolean).length > speakingHistory.length / 2;\n    \n    if (isSpeakingMajority !== this.speakingDetector.isSpeaking) {\n      // Update speaking status\n      this.speakingDetector.isSpeaking = isSpeakingMajority;\n      \n      // Notify about audio level change\n      if (this.onAudioLevelChange) {\n        this.onAudioLevelChange(this.userId, isSpeakingMajority, average);\n      }\n    }\n    \n    // Continue detection loop\n    requestAnimationFrame(() => this._detectAudioLevel());\n  }\n  \n  /**\n   * Detect remote audio level\n   * @param {string} peerId - Peer ID\n   * @private\n   */\n  _detectRemoteAudioLevel(peerId) {\n    // Get speaking detector\n    const speakingDetector = this.audioQualityMonitors.get(peerId);\n    \n    if (!speakingDetector) {\n      return;\n    }\n    \n    // Get audio level\n    const { analyser, dataArray, threshold, speakingHistory } = speakingDetector;\n    analyser.getByteFrequencyData(dataArray);\n    \n    // Calculate average level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const average = sum / dataArray.length;\n    \n    // Check if speaking\n    const isSpeakingNow = average > threshold;\n    \n    // Update speaking history\n    speakingHistory.shift();\n    speakingHistory.push(isSpeakingNow);\n    \n    // Check if speaking status changed\n    const isSpeakingMajority = speakingHistory.filter(Boolean).length > speakingHistory.length / 2;\n    \n    if (isSpeakingMajority !== speakingDetector.isSpeaking) {\n      // Update speaking status\n      speakingDetector.isSpeaking = isSpeakingMajority;\n      \n      // Notify about audio level change\n      if (this.onAudioLevelChange) {\n        this.onAudioLevelChange(peerId, isSpeakingMajority, average);\n      }\n    }\n    \n    // Continue detection loop\n    requestAnimationFrame(() => this._detectRemoteAudioLevel(peerId));\n  }\n\n  /**\n   * Start screen sharing\n   * @returns {Promise<boolean>} Success status\n   */\n  async startScreenSharing() {\n    try {\n      if (this.isScreenSharing) {\n        return true;\n      }\n      \n      // Get screen sharing stream\n      const screenStream = await navigator.mediaDevices.getDisplayMedia({\n        video: {\n          cursor: 'always',\n          displaySurface: 'monitor',\n          logicalSurface: true,\n          frameRate: 30\n        },\n        audio: false\n      });\n      \n      // Store screen stream\n      this.localScreenStream = screenStream;\n      this.isScreenSharing = true;\n      \n      // Add screen track to all peer connections\n      for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n        const screenTrack = screenStream.getVideoTracks()[0];\n        \n        // Find existing video sender\n        const senders = peerConnection.getSenders();\n        const videoSender = senders.find(sender => \n          sender.track && sender.track.kind === 'video'\n        );\n        \n        if (videoSender) {\n          // Replace existing video track with screen track\n          await videoSender.replaceTrack(screenTrack);\n        } else {\n          // Add screen track if no video sender exists\n          peerConnection.addTrack(screenTrack, screenStream);\n          \n          // Renegotiate the connection\n          await this._createAndSendOffer(peerId);\n        }\n      }\n      \n      // Handle screen sharing stop event\n      screenStream.getVideoTracks()[0].addEventListener('ended', () => {\n        this.stopScreenSharing();\n      });\n      \n      // Notify about screen sharing\n      if (this.onScreenSharingChange) {\n        this.onScreenSharingChange(true, screenStream);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error starting screen sharing:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Stop screen sharing\n   * @returns {Promise<boolean>} Success status\n   */\n  async stopScreenSharing() {\n    try {\n      if (!this.isScreenSharing || !this.localScreenStream) {\n        return false;\n      }\n      \n      // Stop all screen tracks\n      this.localScreenStream.getTracks().forEach(track => track.stop());\n      \n      // Reset screen sharing state\n      this.localScreenStream = null;\n      this.isScreenSharing = false;\n      \n      // Restore video tracks in all peer connections\n      if (this.localVideoStream) {\n        const videoTrack = this.localVideoStream.getVideoTracks()[0];\n        \n        for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n          const senders = peerConnection.getSenders();\n          const videoSender = senders.find(sender => \n            sender.track && sender.track.kind === 'video'\n          );\n          \n          if (videoSender && videoTrack) {\n            await videoSender.replaceTrack(videoTrack);\n          }\n        }\n      }\n      \n      // Notify about screen sharing stop\n      if (this.onScreenSharingChange) {\n        this.onScreenSharingChange(false, null);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error stopping screen sharing:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Toggle screen sharing\n   * @returns {Promise<boolean>} New screen sharing status\n   */\n  async toggleScreenSharing() {\n    if (this.isScreenSharing) {\n      return await this.stopScreenSharing();\n    } else {\n      return await this.startScreenSharing();\n    }\n  }\n  \n  /**\n   * Check if screen sharing is enabled\n   * @returns {boolean} Screen sharing status\n   */\n  isScreenSharingEnabled() {\n    return this.isScreenSharing;\n  }\n}\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,0BAA0B,EAAEC,cAAc,QAAQ,oBAAoB;;AAE/E;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EACzBC,WAAWA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAChC,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,MAAM,GAAGD,OAAO,CAACC,MAAM,IAAI,QAAQC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,KAAK,CAAC,EAAE;IAC3E,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC,IAAI,CAACC,oBAAoB,GAAG,IAAID,GAAG,CAAC,CAAC;IACrC,IAAI,CAACE,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAAC,CAAC;IAC/B,IAAI,CAACC,eAAe,GAAG,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,UAAU,GAAGd,OAAO,CAACc,UAAU,IAAI,CACtC;MAAEC,IAAI,EAAE;IAA+B,CAAC,EACxC;MAAEA,IAAI,EAAE;IAAgC,CAAC,EACzC;MAAEA,IAAI,EAAE;IAAgC,CAAC,CAC1C;IACD,IAAI,CAACC,mBAAmB,GAAGhB,OAAO,CAACgB,mBAAmB;IACtD,IAAI,CAACC,qBAAqB,GAAGjB,OAAO,CAACiB,qBAAqB;IAC1D,IAAI,CAACC,eAAe,GAAGlB,OAAO,CAACkB,eAAe;IAC9C,IAAI,CAACC,kBAAkB,GAAGnB,OAAO,CAACmB,kBAAkB;IACpD,IAAI,CAACC,kBAAkB,GAAGpB,OAAO,CAACoB,kBAAkB;IACpD,IAAI,CAACC,mBAAmB,GAAGrB,OAAO,CAACqB,mBAAmB;IACtD,IAAI,CAACC,qBAAqB,GAAGtB,OAAO,CAACsB,qBAAqB;IAC1D,IAAI,CAACC,sBAAsB,GAAGvB,OAAO,CAACuB,sBAAsB;;IAE5D;IACA,IAAI,CAACC,cAAc,GAAG,IAAI9B,oBAAoB,CAAC;MAC7C+B,eAAe,EAAE,IAAI,CAACC,oBAAoB,CAACC,IAAI,CAAC,IAAI,CAAC;MACrDC,YAAY,EAAE5B,OAAO,CAAC4B,YAAY,IAAI;IACxC,CAAC,CAAC;;IAEF;IACA,IAAI,CAACC,cAAc,GAAG,QAAQ;;IAE9B;IACA,IAAI,CAACC,qBAAqB,CAAC,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMC,UAAUA,CAAC1B,MAAM,EAAE;IACvB,IAAI,CAACA,MAAM,GAAGA,MAAM;IAEpB,IAAI;MACF;MACA,MAAM2B,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACvDC,KAAK,EAAE,IAAI;QACXC,KAAK,EAAE;MACT,CAAC,CAAC;MAEF,IAAI,CAAC5B,WAAW,GAAGuB,MAAM;;MAEzB;MACA,IAAI,CAACjC,MAAM,CAACuC,IAAI,CAAC,WAAW,EAAE;QAC5BjC,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBJ,MAAM,EAAE,IAAI,CAACA;MACf,CAAC,CAAC;;MAEF;MACA,IAAI,CAACsC,yBAAyB,CAACP,MAAM,CAAC;MAEtC,OAAOQ,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD,OAAOF,OAAO,CAACI,MAAM,CAACF,KAAK,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMG,WAAWA,CAACC,WAAW,GAAG;IAAEC,KAAK,EAAE,GAAG;IAAEC,MAAM,EAAE;EAAI,CAAC,EAAE;IAC3D,IAAI;MACF;MACA,MAAMC,WAAW,GAAG,MAAMhB,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAC5DE,KAAK,EAAES;MACT,CAAC,CAAC;MAEF,IAAI,CAACpC,gBAAgB,GAAGuC,WAAW;;MAEnC;MACA,KAAK,MAAM,CAACC,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAAC7C,eAAe,CAAC8C,OAAO,CAAC,CAAC,EAAE;QACrE,MAAMC,UAAU,GAAGJ,WAAW,CAACK,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;QAElD,IAAID,UAAU,EAAE;UACdF,cAAc,CAACI,QAAQ,CAACF,UAAU,EAAEJ,WAAW,CAAC;;UAEhD;UACA,MAAM,IAAI,CAACO,mBAAmB,CAACN,MAAM,CAAC;QACxC;MACF;;MAEA;MACA,IAAI,IAAI,CAAC7B,mBAAmB,EAAE;QAC5B,IAAI,CAACA,mBAAmB,CAAC,IAAI,EAAE4B,WAAW,CAAC;MAC7C;MAEA,OAAOA,WAAW;IACpB,CAAC,CAAC,OAAOP,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;EACEe,YAAYA,CAAA,EAAG;IACb,IAAI,CAAC,IAAI,CAAC/C,gBAAgB,EAAE;MAC1B;IACF;;IAEA;IACA,IAAI,CAACA,gBAAgB,CAAC4C,cAAc,CAAC,CAAC,CAACI,OAAO,CAACC,KAAK,IAAI;MACtDA,KAAK,CAACC,IAAI,CAAC,CAAC;IACd,CAAC,CAAC;;IAEF;IACA,KAAK,MAAM,CAACV,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAAC7C,eAAe,CAAC8C,OAAO,CAAC,CAAC,EAAE;MACrE,MAAMS,OAAO,GAAGV,cAAc,CAACW,UAAU,CAAC,CAAC;MAC3C,MAAMC,WAAW,GAAGF,OAAO,CAACG,IAAI,CAACC,MAAM,IACrCA,MAAM,CAACN,KAAK,IAAIM,MAAM,CAACN,KAAK,CAACO,IAAI,KAAK,OACxC,CAAC;MAED,IAAIH,WAAW,EAAE;QACfZ,cAAc,CAACgB,WAAW,CAACJ,WAAW,CAAC;;QAEvC;QACA,IAAI,CAACP,mBAAmB,CAACN,MAAM,CAAC,CAACkB,KAAK,CAACzB,OAAO,CAACD,KAAK,CAAC;MACvD;IACF;;IAEA;IACA,IAAI,CAAChC,gBAAgB,GAAG,IAAI;;IAE5B;IACA,IAAI,IAAI,CAACW,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAAC,KAAK,EAAE,IAAI,CAAC;IACvC;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMgD,eAAeA,CAACC,MAAM,EAAE;IAC5B;IACA,MAAMC,kBAAkB,GAAG5E,0BAA0B,CAAC2E,MAAM,CAAC;;IAE7D;IACA,IAAIxB,WAAW,GAAGyB,kBAAkB;IAEpC,QAAQD,MAAM;MACZ,KAAK,KAAK;QACRxB,WAAW,GAAG;UAAE,GAAGyB,kBAAkB;UAAExB,KAAK,EAAE;YAAEyB,KAAK,EAAED,kBAAkB,CAACxB;UAAM,CAAC;UAAEC,MAAM,EAAE;YAAEwB,KAAK,EAAED,kBAAkB,CAACvB;UAAO,CAAC;UAAEyB,SAAS,EAAE;YAAED,KAAK,EAAED,kBAAkB,CAACE;UAAU;QAAE,CAAC;QACrL;MACF,KAAK,QAAQ;QACX3B,WAAW,GAAG;UAAE,GAAGyB,kBAAkB;UAAExB,KAAK,EAAE;YAAEyB,KAAK,EAAED,kBAAkB,CAACxB;UAAM,CAAC;UAAEC,MAAM,EAAE;YAAEwB,KAAK,EAAED,kBAAkB,CAACvB;UAAO,CAAC;UAAEyB,SAAS,EAAE;YAAED,KAAK,EAAED,kBAAkB,CAACE;UAAU;QAAE,CAAC;QACrL;MACF,KAAK,MAAM;QACT3B,WAAW,GAAG;UAAE,GAAGyB,kBAAkB;UAAExB,KAAK,EAAE;YAAEyB,KAAK,EAAED,kBAAkB,CAACxB;UAAM,CAAC;UAAEC,MAAM,EAAE;YAAEwB,KAAK,EAAED,kBAAkB,CAACvB;UAAO,CAAC;UAAEyB,SAAS,EAAE;YAAED,KAAK,EAAED,kBAAkB,CAACE;UAAU;QAAE,CAAC;QACrL;MACF,KAAK,IAAI;QACP3B,WAAW,GAAG;UAAE,GAAGyB,kBAAkB;UAAExB,KAAK,EAAE;YAAEyB,KAAK,EAAED,kBAAkB,CAACxB;UAAM,CAAC;UAAEC,MAAM,EAAE;YAAEwB,KAAK,EAAED,kBAAkB,CAACvB;UAAO,CAAC;UAAEyB,SAAS,EAAE;YAAED,KAAK,EAAED,kBAAkB,CAACE;UAAU;QAAE,CAAC;QACrL;MACF,KAAK,MAAM;MACX;QACE;QACA,IAAI,CAACjD,cAAc,CAACkD,eAAe,CAAC,IAAI,CAAC;QACzC5B,WAAW,GAAG;UAAEC,KAAK,EAAE,IAAI;UAAEC,MAAM,EAAE,GAAG;UAAEyB,SAAS,EAAE;QAAG,CAAC;QACzD;IACJ;;IAEA;IACA,IAAI,CAAC5C,cAAc,GAAGyC,MAAM;;IAE5B;IACA,IAAIA,MAAM,KAAK,MAAM,EAAE;MACrB,IAAI,CAAC9C,cAAc,CAACkD,eAAe,CAAC,KAAK,CAAC;IAC5C;;IAEA;IACA,IAAI,IAAI,CAAChE,gBAAgB,EAAE;MACzB;MACA,MAAM2C,UAAU,GAAG,IAAI,CAAC3C,gBAAgB,CAAC4C,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;MAE5D,IAAID,UAAU,EAAE;QACd;QACA,IAAI;UACF,MAAMA,UAAU,CAACsB,gBAAgB,CAAC7B,WAAW,CAAC;;UAE9C;UACA,IAAI,IAAI,CAACvB,sBAAsB,EAAE;YAC/B,IAAI,CAACA,sBAAsB,CAAC,GAAG,EAAE;cAAE+C;YAAO,CAAC,CAAC;UAC9C;QACF,CAAC,CAAC,OAAO5B,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;;UAEzD;UACA,IAAI,CAACe,YAAY,CAAC,CAAC;UACnB,MAAM,IAAI,CAACZ,WAAW,CAACC,WAAW,CAAC;QACrC;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAM8B,eAAeA,CAAA,EAAG;IACtB,IAAI;MACF,MAAMC,OAAO,GAAG,MAAM5C,SAAS,CAACC,YAAY,CAAC4C,gBAAgB,CAAC,CAAC;MAC/D,OAAOD,OAAO,CAACE,MAAM,CAACC,MAAM,IAAIA,MAAM,CAACd,IAAI,KAAK,YAAY,CAAC;IAC/D,CAAC,CAAC,OAAOxB,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,EAAE;IACX;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMuC,iBAAiBA,CAACC,QAAQ,EAAE;IAChC,IAAI;MACF;MACA,IAAIpC,WAAW,GAAG;QAAEoC,QAAQ,EAAE;UAAEC,KAAK,EAAED;QAAS;MAAE,CAAC;;MAEnD;MACA,IAAI,IAAI,CAACrD,cAAc,EAAE;QACvB,MAAMuD,kBAAkB,GAAGzF,0BAA0B,CAAC,IAAI,CAACkC,cAAc,CAAC;QAC1EiB,WAAW,GAAG;UACZ,GAAGA,WAAW;UACdC,KAAK,EAAE;YAAEyB,KAAK,EAAEY,kBAAkB,CAACrC;UAAM,CAAC;UAC1CC,MAAM,EAAE;YAAEwB,KAAK,EAAEY,kBAAkB,CAACpC;UAAO,CAAC;UAC5CyB,SAAS,EAAE;YAAED,KAAK,EAAEY,kBAAkB,CAACX;UAAU;QACnD,CAAC;MACH;;MAEA;MACA,IAAI,CAAChB,YAAY,CAAC,CAAC;;MAEnB;MACA,OAAO,MAAM,IAAI,CAACZ,WAAW,CAACC,WAAW,CAAC;IAC5C,CAAC,CAAC,OAAOJ,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;EACE2C,SAASA,CAAA,EAAG;IACV;IACA,IAAI,CAACtF,MAAM,CAACuC,IAAI,CAAC,YAAY,EAAE;MAC7BjC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBJ,MAAM,EAAE,IAAI,CAACA;IACf,CAAC,CAAC;;IAEF;IACA,IAAI,CAACI,MAAM,GAAG,IAAI;;IAElB;IACA,IAAI,CAACiF,UAAU,CAAC,CAAC;EACnB;;EAEA;AACF;AACA;EACEA,UAAUA,CAAA,EAAG;IACX;IACA,IAAI,IAAI,CAAC7E,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAAC8E,SAAS,CAAC,CAAC,CAAC7B,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MAC3D,IAAI,CAACnD,WAAW,GAAG,IAAI;IACzB;IAEA,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACzB,IAAI,CAACA,gBAAgB,CAAC6E,SAAS,CAAC,CAAC,CAAC7B,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MAChE,IAAI,CAAClD,gBAAgB,GAAG,IAAI;IAC9B;IAEA,IAAI,IAAI,CAACC,iBAAiB,EAAE;MAC1B,IAAI,CAACA,iBAAiB,CAAC4E,SAAS,CAAC,CAAC,CAAC7B,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MACjE,IAAI,CAACjD,iBAAiB,GAAG,IAAI;MAC7B,IAAI,CAACC,eAAe,GAAG,KAAK;IAC9B;;IAEA;IACA,KAAK,MAAM,CAACsC,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAAC7C,eAAe,CAAC8C,OAAO,CAAC,CAAC,EAAE;MACrE,IAAID,cAAc,EAAE;QAClBA,cAAc,CAACqC,KAAK,CAAC,CAAC;MACxB;IACF;IAEA,IAAI,CAAClF,eAAe,CAACmF,KAAK,CAAC,CAAC;IAC5B,IAAI,CAACjF,oBAAoB,CAACiF,KAAK,CAAC,CAAC;;IAEjC;IACA,IAAI,CAAC1F,MAAM,CAAC2F,GAAG,CAAC,gBAAgB,CAAC;IACjC,IAAI,CAAC3F,MAAM,CAAC2F,GAAG,CAAC,mBAAmB,CAAC;IACpC,IAAI,CAAC3F,MAAM,CAAC2F,GAAG,CAAC,gBAAgB,CAAC;EACnC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEhE,oBAAoBA,CAACiE,OAAO,EAAEC,OAAO,EAAE;IACrC;IACA,IAAI,IAAI,CAACrE,sBAAsB,EAAE;MAC/B,IAAI,CAACA,sBAAsB,CAACoE,OAAO,EAAEC,OAAO,CAAC;IAC/C;;IAEA;IACA,IAAI,IAAI,CAACpE,cAAc,CAACqE,cAAc,CAAC,CAAC,IAAI,IAAI,CAACnF,gBAAgB,EAAE;MACjE,MAAM2C,UAAU,GAAG,IAAI,CAAC3C,gBAAgB,CAAC4C,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;MAE5D,IAAID,UAAU,EAAE;QACd;QACA,MAAMP,WAAW,GAAG,IAAI,CAACtB,cAAc,CAACsE,oBAAoB,CAACH,OAAO,CAAC;QAErE,IAAI7C,WAAW,EAAE;UACf;UACAO,UAAU,CAACsB,gBAAgB,CAAC7B,WAAW,CAAC,CAACsB,KAAK,CAACzB,OAAO,CAACD,KAAK,CAAC;QAC/D;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;EACEZ,qBAAqBA,CAAA,EAAG;IACtB;IACA,IAAI,CAAC/B,MAAM,CAACgG,EAAE,CAAC,gBAAgB,EAAE,OAAO;MAAE9F;IAAO,CAAC,KAAK;MACrD0C,OAAO,CAACqD,GAAG,CAAC,iBAAiB,EAAE/F,MAAM,CAAC;;MAEtC;MACA,MAAM,IAAI,CAACgG,qBAAqB,CAAChG,MAAM,CAAC;;MAExC;MACA,IAAI,IAAI,CAACiB,eAAe,EAAE;QACxB,IAAI,CAACA,eAAe,CAACjB,MAAM,CAAC;MAC9B;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACF,MAAM,CAACgG,EAAE,CAAC,mBAAmB,EAAE,CAAC;MAAE9F;IAAO,CAAC,KAAK;MAClD0C,OAAO,CAACqD,GAAG,CAAC,oBAAoB,EAAE/F,MAAM,CAAC;;MAEzC;MACA,IAAI,CAACiG,oBAAoB,CAACjG,MAAM,CAAC;;MAEjC;MACA,IAAI,IAAI,CAACkB,kBAAkB,EAAE;QAC3B,IAAI,CAACA,kBAAkB,CAAClB,MAAM,CAAC;MACjC;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACF,MAAM,CAACgG,EAAE,CAAC,gBAAgB,EAAE,OAAO;MAAE9F,MAAM;MAAEkG;IAAO,CAAC,KAAK;MAC7D,IAAI;QACF;QACA,IAAI,CAAC,IAAI,CAAC7F,eAAe,CAAC8F,GAAG,CAACnG,MAAM,CAAC,EAAE;UACrC,MAAM,IAAI,CAACgG,qBAAqB,CAAChG,MAAM,CAAC;QAC1C;QAEA,MAAMkD,cAAc,GAAG,IAAI,CAAC7C,eAAe,CAAC+F,GAAG,CAACpG,MAAM,CAAC;;QAEvD;QACA,IAAIkG,MAAM,CAACG,IAAI,KAAK,OAAO,EAAE;UAC3B,MAAMnD,cAAc,CAACoD,oBAAoB,CAAC,IAAIC,qBAAqB,CAACL,MAAM,CAAC,CAAC;UAC5E,MAAMM,MAAM,GAAG,MAAMtD,cAAc,CAACuD,YAAY,CAAC,CAAC;UAClD,MAAMvD,cAAc,CAACwD,mBAAmB,CAACF,MAAM,CAAC;;UAEhD;UACA,IAAI,CAAC1G,MAAM,CAACuC,IAAI,CAAC,aAAa,EAAE;YAC9BjC,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBJ,MAAM,EAAE,IAAI,CAACA,MAAM;YACnB2G,YAAY,EAAE3G,MAAM;YACpBkG,MAAM,EAAEM;UACV,CAAC,CAAC;QACJ,CAAC,MAAM,IAAIN,MAAM,CAACG,IAAI,KAAK,QAAQ,EAAE;UACnC,MAAMnD,cAAc,CAACoD,oBAAoB,CAAC,IAAIC,qBAAqB,CAACL,MAAM,CAAC,CAAC;QAC9E,CAAC,MAAM,IAAIA,MAAM,CAACU,SAAS,EAAE;UAC3B,MAAM1D,cAAc,CAAC2D,eAAe,CAAC,IAAIC,eAAe,CAACZ,MAAM,CAAC,CAAC;QACnE;MACF,CAAC,CAAC,OAAOzD,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAChD;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMuD,qBAAqBA,CAAC/C,MAAM,EAAE;IAClC,IAAI;MACF;MACA,MAAMC,cAAc,GAAG,IAAI6D,iBAAiB,CAAC;QAC3ClG,UAAU,EAAE,IAAI,CAACA;MACnB,CAAC,CAAC;;MAEF;MACA,IAAI,CAACR,eAAe,CAAC2G,GAAG,CAAC/D,MAAM,EAAEC,cAAc,CAAC;;MAEhD;MACA,IAAI,IAAI,CAAC1C,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,CAAC8E,SAAS,CAAC,CAAC,CAAC7B,OAAO,CAACC,KAAK,IAAI;UAC5CR,cAAc,CAACI,QAAQ,CAACI,KAAK,EAAE,IAAI,CAAClD,WAAW,CAAC;QAClD,CAAC,CAAC;MACJ;;MAEA;MACA,IAAI,IAAI,CAACC,gBAAgB,EAAE;QACzB,IAAI,CAACA,gBAAgB,CAAC6E,SAAS,CAAC,CAAC,CAAC7B,OAAO,CAACC,KAAK,IAAI;UACjDR,cAAc,CAACI,QAAQ,CAACI,KAAK,EAAE,IAAI,CAACjD,gBAAgB,CAAC;QACvD,CAAC,CAAC;MACJ;;MAEA;MACA,IAAI,IAAI,CAACE,eAAe,IAAI,IAAI,CAACD,iBAAiB,EAAE;QAClD,MAAMuG,WAAW,GAAG,IAAI,CAACvG,iBAAiB,CAAC2C,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;QAE9D,IAAI4D,WAAW,EAAE;UACf;UACA,MAAMrD,OAAO,GAAGV,cAAc,CAACW,UAAU,CAAC,CAAC;UAC3C,MAAMC,WAAW,GAAGF,OAAO,CAACG,IAAI,CAACC,MAAM,IACrCA,MAAM,CAACN,KAAK,IAAIM,MAAM,CAACN,KAAK,CAACO,IAAI,KAAK,OACxC,CAAC;UAED,IAAIH,WAAW,EAAE;YACf;YACA,MAAMA,WAAW,CAACoD,YAAY,CAACD,WAAW,CAAC;UAC7C,CAAC,MAAM;YACL;YACA/D,cAAc,CAACI,QAAQ,CAAC2D,WAAW,EAAE,IAAI,CAACvG,iBAAiB,CAAC;UAC9D;QACF;MACF;;MAEA;MACAwC,cAAc,CAACiE,cAAc,GAAIC,KAAK,IAAK;QACzC,IAAIA,KAAK,CAACR,SAAS,EAAE;UACnB;UACA,IAAI,CAAC9G,MAAM,CAACuC,IAAI,CAAC,aAAa,EAAE;YAC9BjC,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBJ,MAAM,EAAE,IAAI,CAACA,MAAM;YACnB2G,YAAY,EAAE1D,MAAM;YACpBiD,MAAM,EAAEkB,KAAK,CAACR;UAChB,CAAC,CAAC;QACJ;MACF,CAAC;;MAED;MACA1D,cAAc,CAACmE,OAAO,GAAID,KAAK,IAAK;QAClC;QACA,MAAME,YAAY,GAAG,IAAIC,WAAW,CAAC,CAAC;;QAEtC;QACAD,YAAY,CAAChE,QAAQ,CAAC8D,KAAK,CAAC1D,KAAK,CAAC;;QAElC;QACA,IAAI,IAAI,CAAC3C,mBAAmB,EAAE;UAC5B,IAAI,CAACA,mBAAmB,CAACkC,MAAM,EAAEqE,YAAY,CAAC;QAChD;;QAEA;QACA,IAAIF,KAAK,CAAC1D,KAAK,CAACO,IAAI,KAAK,OAAO,EAAE;UAChC,IAAI,CAACuD,+BAA+B,CAACvE,MAAM,EAAEqE,YAAY,CAAC;QAC5D;;QAEA;QACA,IAAI,CAAC/F,cAAc,CAACkG,iBAAiB,CAACvE,cAAc,CAAC;MACvD,CAAC;;MAED;MACAA,cAAc,CAACwE,uBAAuB,GAAG,MAAM;QAC7C,IAAIxE,cAAc,CAACyE,eAAe,KAAK,cAAc,IACjDzE,cAAc,CAACyE,eAAe,KAAK,QAAQ,IAC3CzE,cAAc,CAACyE,eAAe,KAAK,QAAQ,EAAE;UAC/C;UACA,IAAI,IAAI,CAAC3G,qBAAqB,EAAE;YAC9B,IAAI,CAACA,qBAAqB,CAACiC,MAAM,CAAC;UACpC;;UAEA;UACA,IAAI,IAAI,CAAC1C,oBAAoB,CAAC4F,GAAG,CAAClD,MAAM,CAAC,EAAE;YACzC,IAAI,CAAC1C,oBAAoB,CAACqH,MAAM,CAAC3E,MAAM,CAAC;UAC1C;QACF;MACF,CAAC;;MAED;MACA,MAAM,IAAI,CAACM,mBAAmB,CAACN,MAAM,CAAC;MAEtC,OAAOC,cAAc;IACvB,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMc,mBAAmBA,CAACN,MAAM,EAAE;IAChC,IAAI;MACF,MAAMC,cAAc,GAAG,IAAI,CAAC7C,eAAe,CAAC+F,GAAG,CAACnD,MAAM,CAAC;MAEvD,IAAI,CAACC,cAAc,EAAE;QACnB,MAAM,IAAI2E,KAAK,CAAC,iCAAiC5E,MAAM,EAAE,CAAC;MAC5D;;MAEA;MACA,MAAM6E,KAAK,GAAG,MAAM5E,cAAc,CAAC6E,WAAW,CAAC,CAAC;;MAEhD;MACA,MAAM7E,cAAc,CAACwD,mBAAmB,CAACoB,KAAK,CAAC;;MAE/C;MACA,IAAI,CAAChI,MAAM,CAACuC,IAAI,CAAC,aAAa,EAAE;QAC9BjC,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBJ,MAAM,EAAE,IAAI,CAACA,MAAM;QACnB2G,YAAY,EAAE1D,MAAM;QACpBiD,MAAM,EAAE4B;MACV,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOrF,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEwD,oBAAoBA,CAAChD,MAAM,EAAE;IAC3B;IACA,MAAMC,cAAc,GAAG,IAAI,CAAC7C,eAAe,CAAC+F,GAAG,CAACnD,MAAM,CAAC;IAEvD,IAAIC,cAAc,EAAE;MAClB;MACAA,cAAc,CAACqC,KAAK,CAAC,CAAC;;MAEtB;MACA,IAAI,CAAClF,eAAe,CAACuH,MAAM,CAAC3E,MAAM,CAAC;;MAEnC;MACA,IAAI,IAAI,CAAC1C,oBAAoB,CAAC4F,GAAG,CAAClD,MAAM,CAAC,EAAE;QACzC,IAAI,CAAC1C,oBAAoB,CAACqH,MAAM,CAAC3E,MAAM,CAAC;MAC1C;;MAEA;MACA,IAAI,IAAI,CAACjC,qBAAqB,EAAE;QAC9B,IAAI,CAACA,qBAAqB,CAACiC,MAAM,CAAC;MACpC;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEX,yBAAyBA,CAACP,MAAM,EAAE;IAChC,IAAI;MACF;MACA,MAAMiG,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;;MAE7E;MACA,MAAMC,QAAQ,GAAGJ,YAAY,CAACK,cAAc,CAAC,CAAC;MAC9CD,QAAQ,CAACE,OAAO,GAAG,GAAG;MACtBF,QAAQ,CAACG,qBAAqB,GAAG,GAAG;;MAEpC;MACA,MAAMC,MAAM,GAAGR,YAAY,CAACS,uBAAuB,CAAC1G,MAAM,CAAC;MAC3DyG,MAAM,CAACE,OAAO,CAACN,QAAQ,CAAC;;MAExB;MACA,MAAMO,SAAS,GAAG,IAAIC,UAAU,CAACR,QAAQ,CAACS,iBAAiB,CAAC;;MAE5D;MACA,IAAI,CAACjI,gBAAgB,GAAG;QACtBwH,QAAQ;QACRO,SAAS;QACTG,SAAS,EAAE,EAAE;QACbC,eAAe,EAAEC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC;QACrCC,UAAU,EAAE;MACd,CAAC;;MAED;MACA,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAC1B,CAAC,CAAC,OAAO1G,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;IACjE;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE+E,+BAA+BA,CAACvE,MAAM,EAAElB,MAAM,EAAE;IAC9C,IAAI;MACF;MACA,MAAMiG,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;;MAE7E;MACA,MAAMC,QAAQ,GAAGJ,YAAY,CAACK,cAAc,CAAC,CAAC;MAC9CD,QAAQ,CAACE,OAAO,GAAG,GAAG;MACtBF,QAAQ,CAACG,qBAAqB,GAAG,GAAG;;MAEpC;MACA,MAAMC,MAAM,GAAGR,YAAY,CAACS,uBAAuB,CAAC1G,MAAM,CAAC;MAC3DyG,MAAM,CAACE,OAAO,CAACN,QAAQ,CAAC;;MAExB;MACA,MAAMO,SAAS,GAAG,IAAIC,UAAU,CAACR,QAAQ,CAACS,iBAAiB,CAAC;;MAE5D;MACA,MAAMjI,gBAAgB,GAAG;QACvBwH,QAAQ;QACRO,SAAS;QACTG,SAAS,EAAE,EAAE;QACbC,eAAe,EAAEC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC;QACrCC,UAAU,EAAE;MACd,CAAC;;MAED;MACA,IAAI,CAAC3I,oBAAoB,CAACyG,GAAG,CAAC/D,MAAM,EAAErC,gBAAgB,CAAC;;MAEvD;MACA,IAAI,CAACwI,uBAAuB,CAACnG,MAAM,CAAC;IACtC,CAAC,CAAC,OAAOR,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gDAAgD,EAAEA,KAAK,CAAC;IACxE;EACF;;EAEA;AACF;AACA;AACA;EACE0G,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAAC,IAAI,CAACvI,gBAAgB,EAAE;MAC1B;IACF;;IAEA;IACA,MAAM;MAAEwH,QAAQ;MAAEO,SAAS;MAAEG,SAAS;MAAEC;IAAgB,CAAC,GAAG,IAAI,CAACnI,gBAAgB;;IAEjF;IACAwH,QAAQ,CAACiB,oBAAoB,CAACV,SAAS,CAAC;;IAExC;IACA,IAAIW,GAAG,GAAG,CAAC;IACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;MACzCD,GAAG,IAAIX,SAAS,CAACY,CAAC,CAAC;IACrB;IACA,MAAME,OAAO,GAAGH,GAAG,GAAGX,SAAS,CAACa,MAAM;;IAEtC;IACA,MAAME,aAAa,GAAGD,OAAO,GAAGX,SAAS;;IAEzC;IACAC,eAAe,CAACY,KAAK,CAAC,CAAC;IACvBZ,eAAe,CAACa,IAAI,CAACF,aAAa,CAAC;;IAEnC;IACA,MAAMG,kBAAkB,GAAGd,eAAe,CAACjE,MAAM,CAACgF,OAAO,CAAC,CAACN,MAAM,GAAGT,eAAe,CAACS,MAAM,GAAG,CAAC;IAE9F,IAAIK,kBAAkB,KAAK,IAAI,CAACjJ,gBAAgB,CAACsI,UAAU,EAAE;MAC3D;MACA,IAAI,CAACtI,gBAAgB,CAACsI,UAAU,GAAGW,kBAAkB;;MAErD;MACA,IAAI,IAAI,CAAC1I,kBAAkB,EAAE;QAC3B,IAAI,CAACA,kBAAkB,CAAC,IAAI,CAACnB,MAAM,EAAE6J,kBAAkB,EAAEJ,OAAO,CAAC;MACnE;IACF;;IAEA;IACAM,qBAAqB,CAAC,MAAM,IAAI,CAACZ,iBAAiB,CAAC,CAAC,CAAC;EACvD;;EAEA;AACF;AACA;AACA;AACA;EACEC,uBAAuBA,CAACnG,MAAM,EAAE;IAC9B;IACA,MAAMrC,gBAAgB,GAAG,IAAI,CAACL,oBAAoB,CAAC6F,GAAG,CAACnD,MAAM,CAAC;IAE9D,IAAI,CAACrC,gBAAgB,EAAE;MACrB;IACF;;IAEA;IACA,MAAM;MAAEwH,QAAQ;MAAEO,SAAS;MAAEG,SAAS;MAAEC;IAAgB,CAAC,GAAGnI,gBAAgB;IAC5EwH,QAAQ,CAACiB,oBAAoB,CAACV,SAAS,CAAC;;IAExC;IACA,IAAIW,GAAG,GAAG,CAAC;IACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;MACzCD,GAAG,IAAIX,SAAS,CAACY,CAAC,CAAC;IACrB;IACA,MAAME,OAAO,GAAGH,GAAG,GAAGX,SAAS,CAACa,MAAM;;IAEtC;IACA,MAAME,aAAa,GAAGD,OAAO,GAAGX,SAAS;;IAEzC;IACAC,eAAe,CAACY,KAAK,CAAC,CAAC;IACvBZ,eAAe,CAACa,IAAI,CAACF,aAAa,CAAC;;IAEnC;IACA,MAAMG,kBAAkB,GAAGd,eAAe,CAACjE,MAAM,CAACgF,OAAO,CAAC,CAACN,MAAM,GAAGT,eAAe,CAACS,MAAM,GAAG,CAAC;IAE9F,IAAIK,kBAAkB,KAAKjJ,gBAAgB,CAACsI,UAAU,EAAE;MACtD;MACAtI,gBAAgB,CAACsI,UAAU,GAAGW,kBAAkB;;MAEhD;MACA,IAAI,IAAI,CAAC1I,kBAAkB,EAAE;QAC3B,IAAI,CAACA,kBAAkB,CAAC8B,MAAM,EAAE4G,kBAAkB,EAAEJ,OAAO,CAAC;MAC9D;IACF;;IAEA;IACAM,qBAAqB,CAAC,MAAM,IAAI,CAACX,uBAAuB,CAACnG,MAAM,CAAC,CAAC;EACnE;;EAEA;AACF;AACA;AACA;EACE,MAAM+G,kBAAkBA,CAAA,EAAG;IACzB,IAAI;MACF,IAAI,IAAI,CAACrJ,eAAe,EAAE;QACxB,OAAO,IAAI;MACb;;MAEA;MACA,MAAMsJ,YAAY,GAAG,MAAMjI,SAAS,CAACC,YAAY,CAACiI,eAAe,CAAC;QAChE9H,KAAK,EAAE;UACL+H,MAAM,EAAE,QAAQ;UAChBC,cAAc,EAAE,SAAS;UACzBC,cAAc,EAAE,IAAI;UACpB7F,SAAS,EAAE;QACb,CAAC;QACDrC,KAAK,EAAE;MACT,CAAC,CAAC;;MAEF;MACA,IAAI,CAACzB,iBAAiB,GAAGuJ,YAAY;MACrC,IAAI,CAACtJ,eAAe,GAAG,IAAI;;MAE3B;MACA,KAAK,MAAM,CAACsC,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAAC7C,eAAe,CAAC8C,OAAO,CAAC,CAAC,EAAE;QACrE,MAAM8D,WAAW,GAAGgD,YAAY,CAAC5G,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;;QAEpD;QACA,MAAMO,OAAO,GAAGV,cAAc,CAACW,UAAU,CAAC,CAAC;QAC3C,MAAMC,WAAW,GAAGF,OAAO,CAACG,IAAI,CAACC,MAAM,IACrCA,MAAM,CAACN,KAAK,IAAIM,MAAM,CAACN,KAAK,CAACO,IAAI,KAAK,OACxC,CAAC;QAED,IAAIH,WAAW,EAAE;UACf;UACA,MAAMA,WAAW,CAACoD,YAAY,CAACD,WAAW,CAAC;QAC7C,CAAC,MAAM;UACL;UACA/D,cAAc,CAACI,QAAQ,CAAC2D,WAAW,EAAEgD,YAAY,CAAC;;UAElD;UACA,MAAM,IAAI,CAAC1G,mBAAmB,CAACN,MAAM,CAAC;QACxC;MACF;;MAEA;MACAgH,YAAY,CAAC5G,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAACiH,gBAAgB,CAAC,OAAO,EAAE,MAAM;QAC/D,IAAI,CAACC,iBAAiB,CAAC,CAAC;MAC1B,CAAC,CAAC;;MAEF;MACA,IAAI,IAAI,CAAClJ,qBAAqB,EAAE;QAC9B,IAAI,CAACA,qBAAqB,CAAC,IAAI,EAAE4I,YAAY,CAAC;MAChD;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOxH,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAM8H,iBAAiBA,CAAA,EAAG;IACxB,IAAI;MACF,IAAI,CAAC,IAAI,CAAC5J,eAAe,IAAI,CAAC,IAAI,CAACD,iBAAiB,EAAE;QACpD,OAAO,KAAK;MACd;;MAEA;MACA,IAAI,CAACA,iBAAiB,CAAC4E,SAAS,CAAC,CAAC,CAAC7B,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;;MAEjE;MACA,IAAI,CAACjD,iBAAiB,GAAG,IAAI;MAC7B,IAAI,CAACC,eAAe,GAAG,KAAK;;MAE5B;MACA,IAAI,IAAI,CAACF,gBAAgB,EAAE;QACzB,MAAM2C,UAAU,GAAG,IAAI,CAAC3C,gBAAgB,CAAC4C,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;QAE5D,KAAK,MAAM,CAACJ,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAAC7C,eAAe,CAAC8C,OAAO,CAAC,CAAC,EAAE;UACrE,MAAMS,OAAO,GAAGV,cAAc,CAACW,UAAU,CAAC,CAAC;UAC3C,MAAMC,WAAW,GAAGF,OAAO,CAACG,IAAI,CAACC,MAAM,IACrCA,MAAM,CAACN,KAAK,IAAIM,MAAM,CAACN,KAAK,CAACO,IAAI,KAAK,OACxC,CAAC;UAED,IAAIH,WAAW,IAAIV,UAAU,EAAE;YAC7B,MAAMU,WAAW,CAACoD,YAAY,CAAC9D,UAAU,CAAC;UAC5C;QACF;MACF;;MAEA;MACA,IAAI,IAAI,CAAC/B,qBAAqB,EAAE;QAC9B,IAAI,CAACA,qBAAqB,CAAC,KAAK,EAAE,IAAI,CAAC;MACzC;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOoB,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAM+H,mBAAmBA,CAAA,EAAG;IAC1B,IAAI,IAAI,CAAC7J,eAAe,EAAE;MACxB,OAAO,MAAM,IAAI,CAAC4J,iBAAiB,CAAC,CAAC;IACvC,CAAC,MAAM;MACL,OAAO,MAAM,IAAI,CAACP,kBAAkB,CAAC,CAAC;IACxC;EACF;;EAEA;AACF;AACA;AACA;EACES,sBAAsBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAAC9J,eAAe;EAC7B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}