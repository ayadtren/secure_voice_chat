{"ast":null,"code":"import { createEnhancedAudioStream, SpeakingDetector, AudioQualityMonitor } from './audioProcessor';\n\n/**\n * WebRTC Connection Manager\n * \n * Manages WebRTC peer connections with enhanced audio processing,\n * connection resilience, and adaptive bitrate streaming.\n */\nexport class WebRTCManager {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.peerConnections = new Map(); // Map of peer ID to RTCPeerConnection\n    this.localStream = null;\n    this.roomId = null;\n    this.userId = options.userId || `user_${Math.random().toString(36).substr(2, 9)}`;\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n\n    // Configuration\n    this.config = {\n      iceServers: options.iceServers || [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }],\n      iceTransportPolicy: options.iceTransportPolicy || 'all',\n      sdpSemantics: 'unified-plan',\n      // Enable DTLS-SRTP for end-to-end encryption\n      // This is enabled by default in modern browsers\n      // but we explicitly set it for clarity\n      rtcpMuxPolicy: 'require'\n    };\n\n    // Audio constraints\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      // Prioritize voice clarity\n      channelCount: 1,\n      sampleRate: 48000,\n      sampleSize: 16\n    };\n\n    // Event callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n\n    // Bind socket event handlers\n    this._bindSocketEvents();\n  }\n\n  /**\n   * Initialize WebRTC manager and join a room\n   * @param {string} roomId - Room ID to join\n   * @returns {Promise<void>}\n   */\n  async initialize(roomId) {\n    try {\n      this.roomId = roomId;\n\n      // Get user media with enhanced audio\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false\n      });\n\n      // Apply enhanced audio processing\n      this.localStream = await createEnhancedAudioStream(stream);\n\n      // Initialize speaking detector\n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        threshold: 15,\n        onSpeakingChange: speaking => {\n          if (this.onSpeakingChange) {\n            this.onSpeakingChange(speaking);\n          }\n\n          // Emit speaking status to other peers\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              userId: this.userId,\n              speaking\n            });\n          }\n        }\n      });\n      this.speakingDetector.start();\n\n      // Join room\n      this.socket.emit('join', {\n        roomId: this.roomId,\n        userId: this.userId\n      });\n      return this.localStream;\n    } catch (error) {\n      console.error('Failed to initialize WebRTC:', error);\n      if (this.onError) {\n        this.onError('Failed to access microphone. Please check your permissions.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n\n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n\n      // Handle ICE candidates\n      peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          this.socket.emit('iceCandidate', {\n            roomId: this.roomId,\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate\n          });\n        }\n      };\n\n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            if (this.onPeerConnect) {\n              this.onPeerConnect(peerId);\n            }\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            this._cleanupPeerConnection(peerId);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            break;\n        }\n      };\n\n      // Handle incoming tracks\n      peerConnection.ontrack = event => {\n        const stream = event.streams[0];\n        // Store remote stream and create audio element\n        if (stream) {\n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n\n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n\n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n\n      // If initiator, create and send offer\n      if (isInitiator) {\n        this._createAndSendOffer(peerId);\n      }\n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) return;\n\n      // Create offer with audio preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false\n      });\n\n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n\n      // Send offer to peer\n      this.socket.emit('offer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription\n      });\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        peerConnection = this._createPeerConnection(peerId);\n      }\n\n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n\n      // Create answer\n      const answer = await peerConnection.createAnswer();\n\n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n\n      // Send answer to peer\n      this.socket.emit('answer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription\n      });\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n    }\n  }\n\n  /**\n   * Bind socket event handlers\n   */\n  _bindSocketEvents() {\n    if (!this.socket) return;\n\n    // Handle user joined event\n    this.socket.on('userJoined', ({\n      userId\n    }) => {\n      if (userId !== this.userId) {\n        this._createPeerConnection(userId, true);\n      }\n    });\n\n    // Handle user left event\n    this.socket.on('userLeft', ({\n      userId\n    }) => {\n      this._cleanupPeerConnection(userId);\n      if (this.onPeerDisconnect) {\n        this.onPeerDisconnect(userId);\n      }\n    });\n\n    // Handle offer\n    this.socket.on('offer', ({\n      from,\n      offer\n    }) => {\n      this._handleOffer(from, offer);\n    });\n\n    // Handle answer\n    this.socket.on('answer', ({\n      from,\n      answer\n    }) => {\n      this._handleAnswer(from, answer);\n    });\n\n    // Handle ICE candidate\n    this.socket.on('iceCandidate', ({\n      from,\n      candidate\n    }) => {\n      this._handleIceCandidate(from, candidate);\n    });\n\n    // Handle speaking status\n    this.socket.on('speaking', ({\n      userId,\n      speaking\n    }) => {\n      if (this.onSpeakingChange && userId !== this.userId) {\n        this.onSpeakingChange(speaking, userId);\n      }\n    });\n  }\n\n  /**\n   * Clean up peer connection\n   * @param {string} peerId - ID of the peer to clean up\n   */\n  _cleanupPeerConnection(peerId) {\n    // Clean up quality monitor\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      qualityMonitor.dispose();\n      this.audioQualityMonitors.delete(peerId);\n    }\n\n    // Clean up peer connection\n    const peerConnection = this.peerConnections.get(peerId);\n    if (peerConnection) {\n      peerConnection.onicecandidate = null;\n      peerConnection.ontrack = null;\n      peerConnection.onconnectionstatechange = null;\n\n      // Close connection\n      peerConnection.close();\n      this.peerConnections.delete(peerId);\n    }\n  }\n\n  /**\n   * Mute or unmute local audio\n   * @param {boolean} muted - Whether to mute audio\n   */\n  setMuted(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        track.enabled = !muted;\n      });\n    }\n  }\n\n  /**\n   * Check if local audio is muted\n   * @returns {boolean} Whether local audio is muted\n   */\n  isMuted() {\n    if (this.localStream) {\n      const audioTracks = this.localStream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        return !audioTracks[0].enabled;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (this.speakingDetector) {\n      return this.speakingDetector.getAudioLevel();\n    }\n    return 0;\n  }\n\n  /**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getConnectionQuality(peerId) {\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      return await qualityMonitor.getQualityMetrics();\n    }\n    return {\n      quality: 'unknown',\n      metrics: {}\n    };\n  }\n\n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop speaking detector\n    if (this.speakingDetector) {\n      this.speakingDetector.dispose();\n      this.speakingDetector = null;\n    }\n\n    // Clean up all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n\n    // Stop local stream tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.localStream = null;\n    }\n\n    // Leave room via socket\n    if (this.socket && this.socket.connected) {\n      this.socket.emit('leave', {\n        roomId: this.roomId,\n        userId: this.userId\n      });\n    }\n    this.roomId = null;\n  }\n\n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    this.leaveRoom();\n\n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n  }\n}","map":{"version":3,"names":["createEnhancedAudioStream","SpeakingDetector","AudioQualityMonitor","WebRTCManager","constructor","socket","options","peerConnections","Map","localStream","roomId","userId","Math","random","toString","substr","speakingDetector","audioQualityMonitors","config","iceServers","urls","iceTransportPolicy","sdpSemantics","rtcpMuxPolicy","audioConstraints","echoCancellation","noiseSuppression","autoGainControl","channelCount","sampleRate","sampleSize","onPeerConnect","onPeerDisconnect","onSpeakingChange","onAudioQualityChange","onError","_bindSocketEvents","initialize","stream","navigator","mediaDevices","getUserMedia","audio","video","threshold","speaking","connected","emit","start","error","console","_createPeerConnection","peerId","isInitiator","peerConnection","RTCPeerConnection","getTracks","forEach","track","addTrack","onicecandidate","event","candidate","to","from","onconnectionstatechange","connectionState","log","_cleanupPeerConnection","ontrack","streams","qualityMonitor","onQualityChange","quality","metrics","set","_createAndSendOffer","get","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","localDescription","_handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","_handleAnswer","_handleIceCandidate","addIceCandidate","RTCIceCandidate","on","dispose","delete","close","setMuted","muted","getAudioTracks","enabled","isMuted","audioTracks","length","getAudioLevel","getConnectionQuality","getQualityMetrics","leaveRoom","keys","stop","off"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcManager.js"],"sourcesContent":["import { createEnhancedAudioStream, SpeakingDetector, AudioQualityMonitor } from './audioProcessor';\n\n/**\n * WebRTC Connection Manager\n * \n * Manages WebRTC peer connections with enhanced audio processing,\n * connection resilience, and adaptive bitrate streaming.\n */\nexport class WebRTCManager {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.peerConnections = new Map(); // Map of peer ID to RTCPeerConnection\n    this.localStream = null;\n    this.roomId = null;\n    this.userId = options.userId || `user_${Math.random().toString(36).substr(2, 9)}`;\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    \n    // Configuration\n    this.config = {\n      iceServers: options.iceServers || [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n      ],\n      iceTransportPolicy: options.iceTransportPolicy || 'all',\n      sdpSemantics: 'unified-plan',\n      // Enable DTLS-SRTP for end-to-end encryption\n      // This is enabled by default in modern browsers\n      // but we explicitly set it for clarity\n      rtcpMuxPolicy: 'require',\n    };\n    \n    // Audio constraints\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      // Prioritize voice clarity\n      channelCount: 1,\n      sampleRate: 48000,\n      sampleSize: 16,\n    };\n    \n    // Event callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n    \n    // Bind socket event handlers\n    this._bindSocketEvents();\n  }\n  \n  /**\n   * Initialize WebRTC manager and join a room\n   * @param {string} roomId - Room ID to join\n   * @returns {Promise<void>}\n   */\n  async initialize(roomId) {\n    try {\n      this.roomId = roomId;\n      \n      // Get user media with enhanced audio\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false,\n      });\n      \n      // Apply enhanced audio processing\n      this.localStream = await createEnhancedAudioStream(stream);\n      \n      // Initialize speaking detector\n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        threshold: 15,\n        onSpeakingChange: (speaking) => {\n          if (this.onSpeakingChange) {\n            this.onSpeakingChange(speaking);\n          }\n          \n          // Emit speaking status to other peers\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              userId: this.userId,\n              speaking,\n            });\n          }\n        }\n      });\n      this.speakingDetector.start();\n      \n      // Join room\n      this.socket.emit('join', {\n        roomId: this.roomId,\n        userId: this.userId,\n      });\n      \n      return this.localStream;\n    } catch (error) {\n      console.error('Failed to initialize WebRTC:', error);\n      if (this.onError) {\n        this.onError('Failed to access microphone. Please check your permissions.');\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n      \n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Handle ICE candidates\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          this.socket.emit('iceCandidate', {\n            roomId: this.roomId,\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate,\n          });\n        }\n      };\n      \n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            if (this.onPeerConnect) {\n              this.onPeerConnect(peerId);\n            }\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            this._cleanupPeerConnection(peerId);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            break;\n        }\n      };\n      \n      // Handle incoming tracks\n      peerConnection.ontrack = (event) => {\n        const stream = event.streams[0];\n        // Store remote stream and create audio element\n        if (stream) {\n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n          \n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n      \n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n      \n      // If initiator, create and send offer\n      if (isInitiator) {\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n  \n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) return;\n      \n      // Create offer with audio preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      });\n      \n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      \n      // Send offer to peer\n      this.socket.emit('offer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription,\n      });\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      \n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      \n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      \n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      \n      // Send answer to peer\n      this.socket.emit('answer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription,\n      });\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n    }\n  }\n  \n  /**\n   * Bind socket event handlers\n   */\n  _bindSocketEvents() {\n    if (!this.socket) return;\n    \n    // Handle user joined event\n    this.socket.on('userJoined', ({ userId }) => {\n      if (userId !== this.userId) {\n        this._createPeerConnection(userId, true);\n      }\n    });\n    \n    // Handle user left event\n    this.socket.on('userLeft', ({ userId }) => {\n      this._cleanupPeerConnection(userId);\n      if (this.onPeerDisconnect) {\n        this.onPeerDisconnect(userId);\n      }\n    });\n    \n    // Handle offer\n    this.socket.on('offer', ({ from, offer }) => {\n      this._handleOffer(from, offer);\n    });\n    \n    // Handle answer\n    this.socket.on('answer', ({ from, answer }) => {\n      this._handleAnswer(from, answer);\n    });\n    \n    // Handle ICE candidate\n    this.socket.on('iceCandidate', ({ from, candidate }) => {\n      this._handleIceCandidate(from, candidate);\n    });\n    \n    // Handle speaking status\n    this.socket.on('speaking', ({ userId, speaking }) => {\n      if (this.onSpeakingChange && userId !== this.userId) {\n        this.onSpeakingChange(speaking, userId);\n      }\n    });\n  }\n  \n  /**\n   * Clean up peer connection\n   * @param {string} peerId - ID of the peer to clean up\n   */\n  _cleanupPeerConnection(peerId) {\n    // Clean up quality monitor\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      qualityMonitor.dispose();\n      this.audioQualityMonitors.delete(peerId);\n    }\n    \n    // Clean up peer connection\n    const peerConnection = this.peerConnections.get(peerId);\n    if (peerConnection) {\n      peerConnection.onicecandidate = null;\n      peerConnection.ontrack = null;\n      peerConnection.onconnectionstatechange = null;\n      \n      // Close connection\n      peerConnection.close();\n      this.peerConnections.delete(peerId);\n    }\n  }\n  \n  /**\n   * Mute or unmute local audio\n   * @param {boolean} muted - Whether to mute audio\n   */\n  setMuted(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Check if local audio is muted\n   * @returns {boolean} Whether local audio is muted\n   */\n  isMuted() {\n    if (this.localStream) {\n      const audioTracks = this.localStream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        return !audioTracks[0].enabled;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (this.speakingDetector) {\n      return this.speakingDetector.getAudioLevel();\n    }\n    return 0;\n  }\n  \n  /**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getConnectionQuality(peerId) {\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      return await qualityMonitor.getQualityMetrics();\n    }\n    return { quality: 'unknown', metrics: {} };\n  }\n  \n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop speaking detector\n    if (this.speakingDetector) {\n      this.speakingDetector.dispose();\n      this.speakingDetector = null;\n    }\n    \n    // Clean up all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n    \n    // Stop local stream tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.localStream = null;\n    }\n    \n    // Leave room via socket\n    if (this.socket && this.socket.connected) {\n      this.socket.emit('leave', {\n        roomId: this.roomId,\n        userId: this.userId,\n      });\n    }\n    \n    this.roomId = null;\n  }\n  \n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    this.leaveRoom();\n    \n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}