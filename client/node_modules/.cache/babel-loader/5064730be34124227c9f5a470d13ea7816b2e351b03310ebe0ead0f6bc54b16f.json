{"ast":null,"code":"/**\n * Recording helper for WebRTC video chat\n * Provides functionality to record video streams\n */\n\nclass RecordingHelper {\n  constructor() {\n    this.mediaRecorder = null;\n    this.recordedChunks = [];\n    this.isRecording = false;\n    this.startTime = 0;\n    this.recordingTimer = null;\n    this.onRecordingTimeUpdate = null;\n  }\n\n  /**\n   * Start recording video streams\n   * @param {MediaStream[]} streams - Array of media streams to record\n   * @param {Function} onTimeUpdate - Callback for recording time updates\n   * @returns {Promise<boolean>} Success status\n   */\n  startRecording(streams, onTimeUpdate = null) {\n    if (this.isRecording) {\n      return false;\n    }\n    try {\n      // Combine all streams into one\n      const combinedStream = this._combineStreams(streams);\n\n      // Create media recorder\n      this.mediaRecorder = new MediaRecorder(combinedStream, {\n        mimeType: this._getSupportedMimeType(),\n        videoBitsPerSecond: 2500000 // 2.5 Mbps\n      });\n\n      // Set up event handlers\n      this.recordedChunks = [];\n      this.mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          this.recordedChunks.push(event.data);\n        }\n      };\n\n      // Start recording\n      this.mediaRecorder.start(1000); // Collect data every second\n      this.isRecording = true;\n      this.startTime = Date.now();\n      this.onRecordingTimeUpdate = onTimeUpdate;\n\n      // Start timer for recording duration\n      this._startRecordingTimer();\n      return true;\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Stop recording\n   * @returns {Promise<Blob>} Recorded video blob\n   */\n  async stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.isRecording || !this.mediaRecorder) {\n        reject(new Error('No active recording'));\n        return;\n      }\n\n      // Stop the recording timer\n      this._stopRecordingTimer();\n\n      // Handle recording completion\n      this.mediaRecorder.onstop = () => {\n        try {\n          // Create blob from recorded chunks\n          const blob = new Blob(this.recordedChunks, {\n            type: this._getSupportedMimeType()\n          });\n          this.isRecording = false;\n          this.recordedChunks = [];\n          this.mediaRecorder = null;\n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      // Stop the media recorder\n      this.mediaRecorder.stop();\n    });\n  }\n\n  /**\n   * Download recorded video\n   * @param {Blob} blob - Video blob to download\n   * @param {string} filename - Name for the downloaded file\n   */\n  downloadRecording(blob, filename = 'recorded-video') {\n    // Create download link\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.href = url;\n    a.download = `${filename}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;\n\n    // Trigger download\n    a.click();\n\n    // Clean up\n    setTimeout(() => {\n      document.body.removeChild(a);\n      window.URL.revokeObjectURL(url);\n    }, 100);\n  }\n\n  /**\n   * Get recording status\n   * @returns {boolean} Recording status\n   */\n  isCurrentlyRecording() {\n    return this.isRecording;\n  }\n\n  /**\n   * Get recording duration in seconds\n   * @returns {number} Recording duration\n   */\n  getRecordingDuration() {\n    if (!this.isRecording || !this.startTime) {\n      return 0;\n    }\n    return Math.floor((Date.now() - this.startTime) / 1000);\n  }\n\n  /**\n   * Start recording timer\n   * @private\n   */\n  _startRecordingTimer() {\n    this.recordingTimer = setInterval(() => {\n      if (this.onRecordingTimeUpdate) {\n        this.onRecordingTimeUpdate(this.getRecordingDuration());\n      }\n    }, 1000);\n  }\n\n  /**\n   * Stop recording timer\n   * @private\n   */\n  _stopRecordingTimer() {\n    if (this.recordingTimer) {\n      clearInterval(this.recordingTimer);\n      this.recordingTimer = null;\n    }\n  }\n\n  /**\n   * Combine multiple media streams into one\n   * @param {MediaStream[]} streams - Array of media streams\n   * @returns {MediaStream} Combined stream\n   * @private\n   */\n  _combineStreams(streams) {\n    // Filter out null or undefined streams\n    const validStreams = streams.filter(stream => stream);\n    if (validStreams.length === 0) {\n      throw new Error('No valid streams to record');\n    }\n    if (validStreams.length === 1) {\n      return validStreams[0];\n    }\n\n    // Combine audio and video tracks from all streams\n    const combinedTracks = [];\n    validStreams.forEach(stream => {\n      stream.getTracks().forEach(track => {\n        combinedTracks.push(track);\n      });\n    });\n    return new MediaStream(combinedTracks);\n  }\n\n  /**\n   * Get supported MIME type for recording\n   * @returns {string} Supported MIME type\n   * @private\n   */\n  _getSupportedMimeType() {\n    const types = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm', 'video/mp4'];\n    for (const type of types) {\n      if (MediaRecorder.isTypeSupported(type)) {\n        return type;\n      }\n    }\n    return 'video/webm'; // Default fallback\n  }\n}\nexport default RecordingHelper;","map":{"version":3,"names":["RecordingHelper","constructor","mediaRecorder","recordedChunks","isRecording","startTime","recordingTimer","onRecordingTimeUpdate","startRecording","streams","onTimeUpdate","combinedStream","_combineStreams","MediaRecorder","mimeType","_getSupportedMimeType","videoBitsPerSecond","ondataavailable","event","data","size","push","start","Date","now","_startRecordingTimer","error","console","stopRecording","Promise","resolve","reject","Error","_stopRecordingTimer","onstop","blob","Blob","type","stop","downloadRecording","filename","url","URL","createObjectURL","a","document","createElement","body","appendChild","style","display","href","download","toISOString","slice","replace","click","setTimeout","removeChild","window","revokeObjectURL","isCurrentlyRecording","getRecordingDuration","Math","floor","setInterval","clearInterval","validStreams","filter","stream","length","combinedTracks","forEach","getTracks","track","MediaStream","types","isTypeSupported"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/recordingHelper.js"],"sourcesContent":["/**\n * Recording helper for WebRTC video chat\n * Provides functionality to record video streams\n */\n\nclass RecordingHelper {\n  constructor() {\n    this.mediaRecorder = null;\n    this.recordedChunks = [];\n    this.isRecording = false;\n    this.startTime = 0;\n    this.recordingTimer = null;\n    this.onRecordingTimeUpdate = null;\n  }\n\n  /**\n   * Start recording video streams\n   * @param {MediaStream[]} streams - Array of media streams to record\n   * @param {Function} onTimeUpdate - Callback for recording time updates\n   * @returns {Promise<boolean>} Success status\n   */\n  startRecording(streams, onTimeUpdate = null) {\n    if (this.isRecording) {\n      return false;\n    }\n\n    try {\n      // Combine all streams into one\n      const combinedStream = this._combineStreams(streams);\n      \n      // Create media recorder\n      this.mediaRecorder = new MediaRecorder(combinedStream, {\n        mimeType: this._getSupportedMimeType(),\n        videoBitsPerSecond: 2500000 // 2.5 Mbps\n      });\n      \n      // Set up event handlers\n      this.recordedChunks = [];\n      this.mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          this.recordedChunks.push(event.data);\n        }\n      };\n      \n      // Start recording\n      this.mediaRecorder.start(1000); // Collect data every second\n      this.isRecording = true;\n      this.startTime = Date.now();\n      this.onRecordingTimeUpdate = onTimeUpdate;\n      \n      // Start timer for recording duration\n      this._startRecordingTimer();\n      \n      return true;\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Stop recording\n   * @returns {Promise<Blob>} Recorded video blob\n   */\n  async stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.isRecording || !this.mediaRecorder) {\n        reject(new Error('No active recording'));\n        return;\n      }\n\n      // Stop the recording timer\n      this._stopRecordingTimer();\n      \n      // Handle recording completion\n      this.mediaRecorder.onstop = () => {\n        try {\n          // Create blob from recorded chunks\n          const blob = new Blob(this.recordedChunks, {\n            type: this._getSupportedMimeType()\n          });\n          \n          this.isRecording = false;\n          this.recordedChunks = [];\n          this.mediaRecorder = null;\n          \n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      \n      // Stop the media recorder\n      this.mediaRecorder.stop();\n    });\n  }\n\n  /**\n   * Download recorded video\n   * @param {Blob} blob - Video blob to download\n   * @param {string} filename - Name for the downloaded file\n   */\n  downloadRecording(blob, filename = 'recorded-video') {\n    // Create download link\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.href = url;\n    a.download = `${filename}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;\n    \n    // Trigger download\n    a.click();\n    \n    // Clean up\n    setTimeout(() => {\n      document.body.removeChild(a);\n      window.URL.revokeObjectURL(url);\n    }, 100);\n  }\n\n  /**\n   * Get recording status\n   * @returns {boolean} Recording status\n   */\n  isCurrentlyRecording() {\n    return this.isRecording;\n  }\n\n  /**\n   * Get recording duration in seconds\n   * @returns {number} Recording duration\n   */\n  getRecordingDuration() {\n    if (!this.isRecording || !this.startTime) {\n      return 0;\n    }\n    \n    return Math.floor((Date.now() - this.startTime) / 1000);\n  }\n\n  /**\n   * Start recording timer\n   * @private\n   */\n  _startRecordingTimer() {\n    this.recordingTimer = setInterval(() => {\n      if (this.onRecordingTimeUpdate) {\n        this.onRecordingTimeUpdate(this.getRecordingDuration());\n      }\n    }, 1000);\n  }\n\n  /**\n   * Stop recording timer\n   * @private\n   */\n  _stopRecordingTimer() {\n    if (this.recordingTimer) {\n      clearInterval(this.recordingTimer);\n      this.recordingTimer = null;\n    }\n  }\n\n  /**\n   * Combine multiple media streams into one\n   * @param {MediaStream[]} streams - Array of media streams\n   * @returns {MediaStream} Combined stream\n   * @private\n   */\n  _combineStreams(streams) {\n    // Filter out null or undefined streams\n    const validStreams = streams.filter(stream => stream);\n    \n    if (validStreams.length === 0) {\n      throw new Error('No valid streams to record');\n    }\n    \n    if (validStreams.length === 1) {\n      return validStreams[0];\n    }\n    \n    // Combine audio and video tracks from all streams\n    const combinedTracks = [];\n    \n    validStreams.forEach(stream => {\n      stream.getTracks().forEach(track => {\n        combinedTracks.push(track);\n      });\n    });\n    \n    return new MediaStream(combinedTracks);\n  }\n\n  /**\n   * Get supported MIME type for recording\n   * @returns {string} Supported MIME type\n   * @private\n   */\n  _getSupportedMimeType() {\n    const types = [\n      'video/webm;codecs=vp9,opus',\n      'video/webm;codecs=vp8,opus',\n      'video/webm',\n      'video/mp4'\n    ];\n    \n    for (const type of types) {\n      if (MediaRecorder.isTypeSupported(type)) {\n        return type;\n      }\n    }\n    \n    return 'video/webm'; // Default fallback\n  }\n}\n\nexport default RecordingHelper;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}