{"ast":null,"code":"// eslint-disable-next-line no-unused-vars\nimport { createEnhancedAudioStream } from './audioProcessor';\nimport { SpeakingDetector } from './speakingDetector';\nimport { AudioQualityMonitor } from './qualityMonitor';\nimport { createMicrophoneStatus } from './browserDetection';\n\n/**\n * WebRTC Manager for handling peer connections\n */\nexport class WebRTCManager {\n  /**\n   * Create a new WebRTC manager\n   * @param {Socket} socket - Socket.IO socket\n   * @param {Object} options - Configuration options\n   */\n  constructor(socket, options = {}) {\n    // Store socket\n    this.socket = socket;\n    this.userId = options.userId;\n\n    // Configuration\n    this.config = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10\n    };\n\n    // Enhanced audio settings\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      sampleRate: 48000,\n      channelCount: 1\n    };\n\n    // State\n    this.roomId = null;\n    this.localStream = null;\n    this.peerConnections = new Map();\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false; // Track if permission has been denied\n\n    // Callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n    this.onMicrophoneStatus = options.onMicrophoneStatus || null;\n\n    // Bind methods\n    this._handleUserMediaError = this._handleUserMediaError.bind(this);\n    this._notifyError = this._notifyError.bind(this);\n  }\n\n  /**\n   * Notify about errors in a consistent way\n   * @param {string|Error} error - Error message or object\n   * @param {string} defaultMessage - Default message if error is empty\n   * @private\n   */\n  _notifyError(error, defaultMessage = 'An unknown error occurred') {\n    let errorMessage = defaultMessage;\n    if (error) {\n      if (typeof error === 'string') {\n        errorMessage = error;\n      } else if (error instanceof Error) {\n        errorMessage = error.message || error.toString();\n      } else if (error.name || error.message) {\n        errorMessage = error.message || error.name;\n      }\n    }\n    console.error(defaultMessage, error || {});\n    if (this.onError) {\n      this.onError(errorMessage);\n    }\n    return errorMessage;\n  }\n\n  /**\n   * Handle user media errors\n   * @param {Error} error - The error that occurred\n   * @private\n   */\n  _handleUserMediaError(error) {\n    let errorMessage = 'Failed to access microphone. Please check your permissions.';\n\n    // Check if error exists and has properties\n    if (error) {\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Microphone access denied. Please allow microphone access in your browser settings.';\n\n        // Show instructions for enabling microphone\n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        }\n        this.permissionDenied = true; // Mark permission as denied to prevent repeated attempts\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No microphone found. Please connect a microphone and try again.';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Could not start microphone. It may be in use by another application.';\n      } else if (error.name === 'OverconstrainedError') {\n        errorMessage = 'Microphone constraints cannot be satisfied. Please try with different settings.';\n      } else if (error.name === 'TypeError') {\n        errorMessage = 'Invalid audio constraints. Please check your browser compatibility.';\n      } else if (error.name === 'AbortError') {\n        errorMessage = 'Microphone access request was aborted. Please try again.';\n      } else if (error.name === 'SecurityError') {\n        errorMessage = 'Microphone access blocked due to security policy. Try using HTTPS.';\n      }\n    }\n    this._notifyError(error, errorMessage);\n    return errorMessage;\n  }\n\n  /**\n   * Initialize WebRTC with local audio stream\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize(roomId) {\n    try {\n      // If permission was previously denied, don't try again automatically\n      if (this.permissionDenied) {\n        this.onMicrophoneStatus(createMicrophoneStatus('denied'));\n        return false;\n      }\n\n      // Store room ID\n      this.roomId = roomId;\n      this.microphonePermissionRequested = true;\n      if (this.onMicrophoneStatus) {\n        this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n      }\n\n      // Try with simpler constraints first\n      const constraints = {\n        audio: true,\n        video: false\n      };\n      try {\n        // Get user media with basic audio settings first\n        this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n        this.microphoneInitialized = true;\n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n        }\n\n        // If basic constraints work, try to apply enhanced settings\n        try {\n          const enhancedStream = await navigator.mediaDevices.getUserMedia({\n            audio: this.audioConstraints,\n            video: false\n          });\n\n          // Replace the basic stream with enhanced stream\n          this.localStream.getTracks().forEach(track => track.stop());\n          this.localStream = enhancedStream;\n        } catch (enhancedError) {\n          console.warn('Could not apply enhanced audio settings, using basic audio:', enhancedError);\n          // Continue with basic audio, no need to throw\n        }\n      } catch (basicError) {\n        // If basic constraints fail, throw the error to be caught by outer try/catch\n        throw basicError;\n      }\n\n      // Create speaking detector\n      if (this.localStream) {\n        this.speakingDetector = new SpeakingDetector(this.localStream, {\n          onSpeakingChange: speaking => {\n            if (this.onSpeakingChange) {\n              this.onSpeakingChange(speaking);\n            }\n\n            // Emit speaking status to other users\n            if (this.socket && this.socket.connected) {\n              this.socket.emit('speaking', {\n                roomId: this.roomId,\n                speaking\n              });\n            }\n          }\n        });\n        this.speakingDetector.start();\n      } else {\n        throw new Error('Failed to initialize local stream');\n      }\n      console.log('WebRTC initialized successfully with roomId:', roomId);\n      return true;\n    } catch (error) {\n      this.microphoneInitialized = false;\n      const errorMessage = this._handleUserMediaError(error);\n      throw new Error(errorMessage);\n    }\n  }\n\n  /**\n   * Retry microphone access\n   * @returns {Promise<boolean>} Success status\n   */\n  async retryMicrophoneAccess() {\n    try {\n      // Reset permission denied flag to allow retry\n      this.permissionDenied = false;\n\n      // Notify about microphone status\n      this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n\n      // Get user media with audio\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false\n      });\n\n      // Microphone access granted\n      this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n\n      // Initialize speaking detector\n      if (this.speakingDetector) {\n        this.speakingDetector.stop();\n      }\n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        onSpeakingChange: speaking => {\n          this.onSpeakingChange(speaking);\n\n          // Emit speaking status to other users\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              speaking\n            });\n          }\n        }\n      });\n      this.speakingDetector.start();\n\n      // Rejoin room if needed\n      if (this.roomId && this.socket && this.socket.connected) {\n        this.socket.emit('join', {\n          roomId: this.roomId\n        });\n      }\n      return true;\n    } catch (error) {\n      // Handle specific getUserMedia errors\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        this.permissionDenied = true; // Mark permission as denied\n        this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        this.onError('Microphone access denied. Please allow microphone access in your browser settings.');\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('No microphone found. Please connect a microphone and try again.');\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('Could not access microphone. It may be in use by another application.');\n      } else {\n        this.onMicrophoneStatus(createMicrophoneStatus('error', error.message));\n        this.onError(`Microphone error: ${error.message || 'Unknown error'}`);\n      }\n      console.error('Error accessing microphone:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      console.log(`Creating peer connection for ${peerId}, isInitiator: ${isInitiator}`);\n\n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n\n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          console.log(`Adding track to peer connection: ${track.kind}`);\n          peerConnection.addTrack(track, this.localStream);\n        });\n      } else {\n        console.error('No local stream available when creating peer connection');\n        if (this.onError) {\n          this.onError('Microphone not initialized. Please refresh and try again.');\n        }\n      }\n\n      // Handle ICE candidates\n      peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          console.log('Sending ICE candidate to peer:', peerId);\n          this.socket.emit('iceCandidate', {\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate\n          });\n        }\n      };\n\n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        console.log(`Connection state changed to: ${peerConnection.connectionState} for peer ${peerId}`);\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            this._cleanupPeerConnection(peerId);\n            break;\n          default:\n            break;\n        }\n      };\n\n      // Handle incoming tracks\n      peerConnection.ontrack = event => {\n        console.log(`Received track from peer ${peerId}: ${event.track.kind}`);\n        const stream = event.streams[0];\n\n        // Store remote stream and create audio element\n        if (stream) {\n          console.log(`Received stream from peer ${peerId}`);\n\n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n\n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n\n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n\n      // If initiator, create and send offer\n      if (isInitiator) {\n        console.log(`Initiating offer creation for peer ${peerId}`);\n        this._createAndSendOffer(peerId);\n      }\n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   * @returns {Promise<void>}\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      console.log(`Creating offer for peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.error(`No peer connection found for ${peerId}`);\n        return;\n      }\n\n      // Create offer with audio preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false\n      });\n\n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      console.log(`Local description set for peer ${peerId}`);\n\n      // Send offer to peer\n      this.socket.emit('offer', {\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription\n      });\n      console.log(`Offer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      console.log(`Handling offer from peer ${peerId}`);\n\n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.log(`Creating new peer connection for ${peerId} to handle offer`);\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      if (!peerConnection) {\n        console.error(`Failed to create peer connection for ${peerId}`);\n        return;\n      }\n\n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      console.log(`Remote description set for peer ${peerId}`);\n\n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      console.log(`Answer created for peer ${peerId}`);\n\n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      console.log(`Local description set for peer ${peerId}`);\n\n      // Send answer to peer\n      this.socket.emit('answer', {\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription\n      });\n      console.log(`Answer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      console.log(`Handling answer from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n        console.log(`Remote description set for peer ${peerId} from answer`);\n      } else {\n        console.error(`No peer connection found for ${peerId} when handling answer`);\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      console.log(`Handling ICE candidate from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        console.log(`Successfully added ICE candidate for peer ${peerId}`);\n      } else {\n        console.warn(`Received ICE candidate for non-existent peer connection: ${peerId}`);\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Clean up a peer connection\n   * @param {string} peerId - ID of the peer\n   */\n  _cleanupPeerConnection(peerId) {\n    try {\n      console.log(`Cleaning up peer connection for ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        peerConnection.onicecandidate = null;\n        peerConnection.ontrack = null;\n        peerConnection.onconnectionstatechange = null;\n        peerConnection.close();\n        this.peerConnections.delete(peerId);\n      }\n\n      // Clean up audio quality monitor\n      const qualityMonitor = this.audioQualityMonitors.get(peerId);\n      if (qualityMonitor) {\n        qualityMonitor.stop();\n        this.audioQualityMonitors.delete(peerId);\n      }\n      console.log(`Peer connection for ${peerId} cleaned up`);\n    } catch (error) {\n      console.error(`Error cleaning up peer connection for ${peerId}:`, error);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   * @param {string} peerId - ID of the peer who initiated the call\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<boolean>} Success status\n   */\n  async acceptIncomingCall(peerId, offer) {\n    try {\n      console.log(`Accepting incoming call from ${peerId}`);\n      await this._handleOffer(peerId, offer);\n      return true;\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      if (this.onError) {\n        this.onError('Failed to accept call. Please try again.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<RTCPeerConnection>} The peer connection\n   */\n  async startCall(peerId) {\n    try {\n      if (!this.microphonePermissionRequested) {\n        await this.initialize(this.roomId || 'default');\n      }\n      if (!this.localStream || !this.microphoneInitialized) {\n        throw new Error('Microphone not initialized. Please refresh and try again.');\n      }\n\n      // Create peer connection\n      const peerConnection = this._createPeerConnection(peerId, true);\n\n      // Add local tracks to the connection\n      this.localStream.getTracks().forEach(track => {\n        peerConnection.addTrack(track, this.localStream);\n      });\n\n      // Create and send offer\n      await this._createAndSendOffer(peerId);\n      return peerConnection;\n    } catch (error) {\n      this._notifyError(error, 'Failed to start call');\n      throw error;\n    }\n  }\n\n  /**\n   * Handle an answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async handleAnswer(peerId, answer) {\n    console.log(`Handling answer from ${peerId} in public method`);\n    return this._handleAnswer(peerId, answer);\n  }\n\n  /**\n   * Add an ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async addIceCandidate(peerId, candidate) {\n    console.log(`Adding ICE candidate from ${peerId} in public method`);\n    return this._handleIceCandidate(peerId, candidate);\n  }\n\n  /**\n   * Bind socket event handlers\n   */\n  _bindSocketEvents() {\n    // We don't need to bind socket events here since we're handling them in App.js\n    // This method is kept for future enhancements\n  }\n\n  /**\n   * Check if microphone is muted\n   * @returns {boolean} Mute status\n   */\n  isMuted() {\n    if (!this.localStream) return true;\n    const audioTracks = this.localStream.getAudioTracks();\n    if (audioTracks.length === 0) return true;\n    return !audioTracks[0].enabled;\n  }\n\n  /**\n   * Toggle microphone mute state\n   * @returns {boolean} New mute status\n   */\n  toggleMute() {\n    if (!this.localStream) return true;\n    const audioTracks = this.localStream.getAudioTracks();\n    if (audioTracks.length === 0) return true;\n    const track = audioTracks[0];\n    track.enabled = !track.enabled;\n    return !track.enabled;\n  }\n\n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (this.speakingDetector) {\n      return this.speakingDetector.getAudioLevel();\n    }\n    return 0;\n  }\n\n  /**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getConnectionQuality(peerId) {\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      return await qualityMonitor.getQualityMetrics();\n    }\n    return {\n      quality: 'unknown',\n      metrics: {}\n    };\n  }\n\n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n\n    // Stop local stream\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n\n    // Stop speaking detector\n    if (this.speakingDetector) {\n      try {\n        this.speakingDetector.stop();\n      } catch (error) {\n        console.error('Error stopping speaking detector:', error);\n      }\n    }\n\n    // Reset state\n    this.roomId = null;\n    this.peerConnections.clear();\n    this.audioQualityMonitors.clear();\n    this.speakingDetector = null;\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false;\n  }\n\n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    console.log('Disposing WebRTC manager');\n    this.leaveRoom();\n\n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n    console.log('WebRTC manager disposed');\n  }\n}","map":{"version":3,"names":["createEnhancedAudioStream","SpeakingDetector","AudioQualityMonitor","createMicrophoneStatus","WebRTCManager","constructor","socket","options","userId","config","iceServers","urls","iceCandidatePoolSize","audioConstraints","echoCancellation","noiseSuppression","autoGainControl","sampleRate","channelCount","roomId","localStream","peerConnections","Map","speakingDetector","audioQualityMonitors","microphoneInitialized","microphonePermissionRequested","permissionDenied","onPeerConnect","onPeerDisconnect","onSpeakingChange","onAudioQualityChange","onError","onMicrophoneStatus","_handleUserMediaError","bind","_notifyError","error","defaultMessage","errorMessage","Error","message","toString","name","console","initialize","constraints","audio","video","navigator","mediaDevices","getUserMedia","enhancedStream","getTracks","forEach","track","stop","enhancedError","warn","basicError","speaking","connected","emit","start","log","retryMicrophoneAccess","_createPeerConnection","peerId","isInitiator","peerConnection","RTCPeerConnection","kind","addTrack","onicecandidate","event","candidate","to","from","onconnectionstatechange","connectionState","_cleanupPeerConnection","ontrack","stream","streams","qualityMonitor","onQualityChange","quality","metrics","set","_createAndSendOffer","get","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","localDescription","_handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","_handleAnswer","_handleIceCandidate","addIceCandidate","RTCIceCandidate","close","delete","acceptIncomingCall","startCall","handleAnswer","_bindSocketEvents","isMuted","audioTracks","getAudioTracks","length","enabled","toggleMute","getAudioLevel","getConnectionQuality","getQualityMetrics","leaveRoom","keys","clear","dispose","off"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcManager.js"],"sourcesContent":["// eslint-disable-next-line no-unused-vars\nimport { createEnhancedAudioStream } from './audioProcessor';\nimport { SpeakingDetector } from './speakingDetector';\nimport { AudioQualityMonitor } from './qualityMonitor';\nimport { createMicrophoneStatus } from './browserDetection';\n\n/**\n * WebRTC Manager for handling peer connections\n */\nexport class WebRTCManager {\n  /**\n   * Create a new WebRTC manager\n   * @param {Socket} socket - Socket.IO socket\n   * @param {Object} options - Configuration options\n   */\n  constructor(socket, options = {}) {\n    // Store socket\n    this.socket = socket;\n    this.userId = options.userId;\n    \n    // Configuration\n    this.config = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' },\n      ],\n      iceCandidatePoolSize: 10,\n    };\n    \n    // Enhanced audio settings\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      sampleRate: 48000,\n      channelCount: 1\n    };\n    \n    // State\n    this.roomId = null;\n    this.localStream = null;\n    this.peerConnections = new Map();\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false; // Track if permission has been denied\n    \n    // Callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n    this.onMicrophoneStatus = options.onMicrophoneStatus || null;\n    \n    // Bind methods\n    this._handleUserMediaError = this._handleUserMediaError.bind(this);\n    this._notifyError = this._notifyError.bind(this);\n  }\n  \n  /**\n   * Notify about errors in a consistent way\n   * @param {string|Error} error - Error message or object\n   * @param {string} defaultMessage - Default message if error is empty\n   * @private\n   */\n  _notifyError(error, defaultMessage = 'An unknown error occurred') {\n    let errorMessage = defaultMessage;\n    \n    if (error) {\n      if (typeof error === 'string') {\n        errorMessage = error;\n      } else if (error instanceof Error) {\n        errorMessage = error.message || error.toString();\n      } else if (error.name || error.message) {\n        errorMessage = error.message || error.name;\n      }\n    }\n    \n    console.error(defaultMessage, error || {});\n    \n    if (this.onError) {\n      this.onError(errorMessage);\n    }\n    \n    return errorMessage;\n  }\n  \n  /**\n   * Handle user media errors\n   * @param {Error} error - The error that occurred\n   * @private\n   */\n  _handleUserMediaError(error) {\n    let errorMessage = 'Failed to access microphone. Please check your permissions.';\n    \n    // Check if error exists and has properties\n    if (error) {\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Microphone access denied. Please allow microphone access in your browser settings.';\n        \n        // Show instructions for enabling microphone\n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        }\n        this.permissionDenied = true; // Mark permission as denied to prevent repeated attempts\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No microphone found. Please connect a microphone and try again.';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Could not start microphone. It may be in use by another application.';\n      } else if (error.name === 'OverconstrainedError') {\n        errorMessage = 'Microphone constraints cannot be satisfied. Please try with different settings.';\n      } else if (error.name === 'TypeError') {\n        errorMessage = 'Invalid audio constraints. Please check your browser compatibility.';\n      } else if (error.name === 'AbortError') {\n        errorMessage = 'Microphone access request was aborted. Please try again.';\n      } else if (error.name === 'SecurityError') {\n        errorMessage = 'Microphone access blocked due to security policy. Try using HTTPS.';\n      }\n    }\n    \n    this._notifyError(error, errorMessage);\n    return errorMessage;\n  }\n  \n  /**\n   * Initialize WebRTC with local audio stream\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize(roomId) {\n    try {\n      // If permission was previously denied, don't try again automatically\n      if (this.permissionDenied) {\n        this.onMicrophoneStatus(createMicrophoneStatus('denied'));\n        return false;\n      }\n      \n      // Store room ID\n      this.roomId = roomId;\n      this.microphonePermissionRequested = true;\n      \n      if (this.onMicrophoneStatus) {\n        this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n      }\n      \n      // Try with simpler constraints first\n      const constraints = {\n        audio: true,\n        video: false\n      };\n      \n      try {\n        // Get user media with basic audio settings first\n        this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n        this.microphoneInitialized = true;\n        \n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n        }\n        \n        // If basic constraints work, try to apply enhanced settings\n        try {\n          const enhancedStream = await navigator.mediaDevices.getUserMedia({\n            audio: this.audioConstraints,\n            video: false\n          });\n          \n          // Replace the basic stream with enhanced stream\n          this.localStream.getTracks().forEach(track => track.stop());\n          this.localStream = enhancedStream;\n        } catch (enhancedError) {\n          console.warn('Could not apply enhanced audio settings, using basic audio:', enhancedError);\n          // Continue with basic audio, no need to throw\n        }\n      } catch (basicError) {\n        // If basic constraints fail, throw the error to be caught by outer try/catch\n        throw basicError;\n      }\n      \n      // Create speaking detector\n      if (this.localStream) {\n        this.speakingDetector = new SpeakingDetector(this.localStream, {\n          onSpeakingChange: (speaking) => {\n            if (this.onSpeakingChange) {\n              this.onSpeakingChange(speaking);\n            }\n            \n            // Emit speaking status to other users\n            if (this.socket && this.socket.connected) {\n              this.socket.emit('speaking', {\n                roomId: this.roomId,\n                speaking\n              });\n            }\n          }\n        });\n        this.speakingDetector.start();\n      } else {\n        throw new Error('Failed to initialize local stream');\n      }\n      \n      console.log('WebRTC initialized successfully with roomId:', roomId);\n      return true;\n    } catch (error) {\n      this.microphoneInitialized = false;\n      const errorMessage = this._handleUserMediaError(error);\n      throw new Error(errorMessage);\n    }\n  }\n  \n  /**\n   * Retry microphone access\n   * @returns {Promise<boolean>} Success status\n   */\n  async retryMicrophoneAccess() {\n    try {\n      // Reset permission denied flag to allow retry\n      this.permissionDenied = false;\n      \n      // Notify about microphone status\n      this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n      \n      // Get user media with audio\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false\n      });\n      \n      // Microphone access granted\n      this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n      \n      // Initialize speaking detector\n      if (this.speakingDetector) {\n        this.speakingDetector.stop();\n      }\n      \n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        onSpeakingChange: (speaking) => {\n          this.onSpeakingChange(speaking);\n          \n          // Emit speaking status to other users\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              speaking\n            });\n          }\n        }\n      });\n      \n      this.speakingDetector.start();\n      \n      // Rejoin room if needed\n      if (this.roomId && this.socket && this.socket.connected) {\n        this.socket.emit('join', { roomId: this.roomId });\n      }\n      \n      return true;\n    } catch (error) {\n      // Handle specific getUserMedia errors\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        this.permissionDenied = true; // Mark permission as denied\n        this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        this.onError('Microphone access denied. Please allow microphone access in your browser settings.');\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('No microphone found. Please connect a microphone and try again.');\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('Could not access microphone. It may be in use by another application.');\n      } else {\n        this.onMicrophoneStatus(createMicrophoneStatus('error', error.message));\n        this.onError(`Microphone error: ${error.message || 'Unknown error'}`);\n      }\n      \n      console.error('Error accessing microphone:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      console.log(`Creating peer connection for ${peerId}, isInitiator: ${isInitiator}`);\n      \n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n      \n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          console.log(`Adding track to peer connection: ${track.kind}`);\n          peerConnection.addTrack(track, this.localStream);\n        });\n      } else {\n        console.error('No local stream available when creating peer connection');\n        if (this.onError) {\n          this.onError('Microphone not initialized. Please refresh and try again.');\n        }\n      }\n      \n      // Handle ICE candidates\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          console.log('Sending ICE candidate to peer:', peerId);\n          this.socket.emit('iceCandidate', {\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate,\n          });\n        }\n      };\n      \n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        console.log(`Connection state changed to: ${peerConnection.connectionState} for peer ${peerId}`);\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            this._cleanupPeerConnection(peerId);\n            break;\n          default:\n            break;\n        }\n      };\n      \n      // Handle incoming tracks\n      peerConnection.ontrack = (event) => {\n        console.log(`Received track from peer ${peerId}: ${event.track.kind}`);\n        const stream = event.streams[0];\n        \n        // Store remote stream and create audio element\n        if (stream) {\n          console.log(`Received stream from peer ${peerId}`);\n          \n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n          \n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n      \n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n      \n      // If initiator, create and send offer\n      if (isInitiator) {\n        console.log(`Initiating offer creation for peer ${peerId}`);\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n  \n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   * @returns {Promise<void>}\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      console.log(`Creating offer for peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.error(`No peer connection found for ${peerId}`);\n        return;\n      }\n      \n      // Create offer with audio preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      });\n      \n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      console.log(`Local description set for peer ${peerId}`);\n      \n      // Send offer to peer\n      this.socket.emit('offer', {\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription,\n      });\n      console.log(`Offer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      console.log(`Handling offer from peer ${peerId}`);\n      \n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.log(`Creating new peer connection for ${peerId} to handle offer`);\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      \n      if (!peerConnection) {\n        console.error(`Failed to create peer connection for ${peerId}`);\n        return;\n      }\n      \n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      console.log(`Remote description set for peer ${peerId}`);\n      \n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      console.log(`Answer created for peer ${peerId}`);\n      \n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      console.log(`Local description set for peer ${peerId}`);\n      \n      // Send answer to peer\n      this.socket.emit('answer', {\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription,\n      });\n      console.log(`Answer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      console.log(`Handling answer from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n        console.log(`Remote description set for peer ${peerId} from answer`);\n      } else {\n        console.error(`No peer connection found for ${peerId} when handling answer`);\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      console.log(`Handling ICE candidate from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        console.log(`Successfully added ICE candidate for peer ${peerId}`);\n      } else {\n        console.warn(`Received ICE candidate for non-existent peer connection: ${peerId}`);\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Clean up a peer connection\n   * @param {string} peerId - ID of the peer\n   */\n  _cleanupPeerConnection(peerId) {\n    try {\n      console.log(`Cleaning up peer connection for ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        peerConnection.onicecandidate = null;\n        peerConnection.ontrack = null;\n        peerConnection.onconnectionstatechange = null;\n        peerConnection.close();\n        this.peerConnections.delete(peerId);\n      }\n      \n      // Clean up audio quality monitor\n      const qualityMonitor = this.audioQualityMonitors.get(peerId);\n      if (qualityMonitor) {\n        qualityMonitor.stop();\n        this.audioQualityMonitors.delete(peerId);\n      }\n      \n      console.log(`Peer connection for ${peerId} cleaned up`);\n    } catch (error) {\n      console.error(`Error cleaning up peer connection for ${peerId}:`, error);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   * @param {string} peerId - ID of the peer who initiated the call\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<boolean>} Success status\n   */\n  async acceptIncomingCall(peerId, offer) {\n    try {\n      console.log(`Accepting incoming call from ${peerId}`);\n      await this._handleOffer(peerId, offer);\n      return true;\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      if (this.onError) {\n        this.onError('Failed to accept call. Please try again.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<RTCPeerConnection>} The peer connection\n   */\n  async startCall(peerId) {\n    try {\n      if (!this.microphonePermissionRequested) {\n        await this.initialize(this.roomId || 'default');\n      }\n      \n      if (!this.localStream || !this.microphoneInitialized) {\n        throw new Error('Microphone not initialized. Please refresh and try again.');\n      }\n      \n      // Create peer connection\n      const peerConnection = this._createPeerConnection(peerId, true);\n      \n      // Add local tracks to the connection\n      this.localStream.getTracks().forEach(track => {\n        peerConnection.addTrack(track, this.localStream);\n      });\n      \n      // Create and send offer\n      await this._createAndSendOffer(peerId);\n      \n      return peerConnection;\n    } catch (error) {\n      this._notifyError(error, 'Failed to start call');\n      throw error;\n    }\n  }\n\n  /**\n   * Handle an answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async handleAnswer(peerId, answer) {\n    console.log(`Handling answer from ${peerId} in public method`);\n    return this._handleAnswer(peerId, answer);\n  }\n\n  /**\n   * Add an ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async addIceCandidate(peerId, candidate) {\n    console.log(`Adding ICE candidate from ${peerId} in public method`);\n    return this._handleIceCandidate(peerId, candidate);\n  }\n  \n  /**\n   * Bind socket event handlers\n   */\n  _bindSocketEvents() {\n    // We don't need to bind socket events here since we're handling them in App.js\n    // This method is kept for future enhancements\n  }\n  \n  /**\n   * Check if microphone is muted\n   * @returns {boolean} Mute status\n   */\n  isMuted() {\n    if (!this.localStream) return true;\n    \n    const audioTracks = this.localStream.getAudioTracks();\n    if (audioTracks.length === 0) return true;\n    \n    return !audioTracks[0].enabled;\n  }\n  \n  /**\n   * Toggle microphone mute state\n   * @returns {boolean} New mute status\n   */\n  toggleMute() {\n    if (!this.localStream) return true;\n    \n    const audioTracks = this.localStream.getAudioTracks();\n    if (audioTracks.length === 0) return true;\n    \n    const track = audioTracks[0];\n    track.enabled = !track.enabled;\n    \n    return !track.enabled;\n  }\n  \n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (this.speakingDetector) {\n      return this.speakingDetector.getAudioLevel();\n    }\n    return 0;\n  }\n  \n  /**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getConnectionQuality(peerId) {\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      return await qualityMonitor.getQualityMetrics();\n    }\n    return { quality: 'unknown', metrics: {} };\n  }\n  \n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n    \n    // Stop local stream\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    \n    // Stop speaking detector\n    if (this.speakingDetector) {\n      try {\n        this.speakingDetector.stop();\n      } catch (error) {\n        console.error('Error stopping speaking detector:', error);\n      }\n    }\n    \n    // Reset state\n    this.roomId = null;\n    this.peerConnections.clear();\n    this.audioQualityMonitors.clear();\n    this.speakingDetector = null;\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false;\n  }\n  \n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    console.log('Disposing WebRTC manager');\n    this.leaveRoom();\n    \n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n    \n    console.log('WebRTC manager disposed');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}