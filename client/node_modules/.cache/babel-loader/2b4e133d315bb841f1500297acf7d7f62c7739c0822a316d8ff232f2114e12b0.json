{"ast":null,"code":"import{createEnhancedAudioStream,SpeakingDetector,AudioQualityMonitor}from'./audioProcessor';/**\n * WebRTC Connection Manager\n * \n * Manages WebRTC peer connections with enhanced audio processing,\n * connection resilience, and adaptive bitrate streaming.\n */export class WebRTCManager{constructor(socket){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.socket=socket;this.peerConnections=new Map();// Map of peer ID to RTCPeerConnection\nthis.localStream=null;this.roomId=null;this.userId=options.userId||`user_${Math.random().toString(36).substr(2,9)}`;this.speakingDetector=null;this.audioQualityMonitors=new Map();// Configuration\nthis.config={iceServers:options.iceServers||[{urls:'stun:stun.l.google.com:19302'},{urls:'stun:stun1.l.google.com:19302'}],iceTransportPolicy:options.iceTransportPolicy||'all',sdpSemantics:'unified-plan',// Enable DTLS-SRTP for end-to-end encryption\n// This is enabled by default in modern browsers\n// but we explicitly set it for clarity\nrtcpMuxPolicy:'require'};// Audio constraints\nthis.audioConstraints={echoCancellation:true,noiseSuppression:true,autoGainControl:true,// Prioritize voice clarity\nchannelCount:1,sampleRate:48000,sampleSize:16};// Event callbacks\nthis.onPeerConnect=options.onPeerConnect||null;this.onPeerDisconnect=options.onPeerDisconnect||null;this.onSpeakingChange=options.onSpeakingChange||null;this.onAudioQualityChange=options.onAudioQualityChange||null;this.onError=options.onError||null;// Bind socket event handlers\nthis._bindSocketEvents();}/**\n   * Initialize WebRTC manager and join a room\n   * @param {string} roomId - Room ID to join\n   * @returns {Promise<void>}\n   */async initialize(roomId){try{this.roomId=roomId;// Get user media with enhanced audio\nconst stream=await navigator.mediaDevices.getUserMedia({audio:this.audioConstraints,video:false});// Apply enhanced audio processing\nthis.localStream=await createEnhancedAudioStream(stream);// Initialize speaking detector\nthis.speakingDetector=new SpeakingDetector(this.localStream,{threshold:15,onSpeakingChange:speaking=>{if(this.onSpeakingChange){this.onSpeakingChange(speaking);}// Emit speaking status to other peers\nif(this.socket&&this.socket.connected){this.socket.emit('speaking',{roomId:this.roomId,userId:this.userId,speaking});}}});this.speakingDetector.start();// Join room\nthis.socket.emit('join',{roomId:this.roomId,userId:this.userId});return this.localStream;}catch(error){console.error('Failed to initialize WebRTC:',error);if(this.onError){this.onError('Failed to access microphone. Please check your permissions.');}throw error;}}/**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */_createPeerConnection(peerId){let isInitiator=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{// Create new peer connection\nconst peerConnection=new RTCPeerConnection(this.config);// Add local stream tracks to peer connection\nif(this.localStream){this.localStream.getTracks().forEach(track=>{peerConnection.addTrack(track,this.localStream);});}// Handle ICE candidates\npeerConnection.onicecandidate=event=>{if(event.candidate){this.socket.emit('iceCandidate',{roomId:this.roomId,to:peerId,from:this.userId,candidate:event.candidate});}};// Handle connection state changes\npeerConnection.onconnectionstatechange=()=>{switch(peerConnection.connectionState){case'connected':console.log(`Connected to peer: ${peerId}`);if(this.onPeerConnect){this.onPeerConnect(peerId);}break;case'disconnected':case'failed':case'closed':console.log(`Disconnected from peer: ${peerId}`);if(this.onPeerDisconnect){this.onPeerDisconnect(peerId);}this._cleanupPeerConnection(peerId);break;default:console.log(`Connection state changed to: ${peerConnection.connectionState}`);break;}};// Handle incoming tracks\npeerConnection.ontrack=event=>{const stream=event.streams[0];// Store remote stream and create audio element\nif(stream){// Create audio quality monitor\nconst qualityMonitor=new AudioQualityMonitor(peerConnection,{onQualityChange:(quality,metrics)=>{if(this.onAudioQualityChange){this.onAudioQualityChange(peerId,quality,metrics);}}});qualityMonitor.start();this.audioQualityMonitors.set(peerId,qualityMonitor);// Notify about the new stream\nif(this.onPeerConnect){this.onPeerConnect(peerId,stream);}}};// Store peer connection\nthis.peerConnections.set(peerId,peerConnection);// If initiator, create and send offer\nif(isInitiator){this._createAndSendOffer(peerId);}return peerConnection;}catch(error){console.error('Error creating peer connection:',error);if(this.onError){this.onError('Failed to create connection. Please try again.');}return null;}}/**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   */async _createAndSendOffer(peerId){try{const peerConnection=this.peerConnections.get(peerId);if(!peerConnection)return;// Create offer with audio preferences\nconst offer=await peerConnection.createOffer({offerToReceiveAudio:true,offerToReceiveVideo:false});// Set local description\nawait peerConnection.setLocalDescription(offer);// Send offer to peer\nthis.socket.emit('offer',{roomId:this.roomId,to:peerId,from:this.userId,offer:peerConnection.localDescription});}catch(error){console.error('Error creating offer:',error);if(this.onError){this.onError('Failed to create connection offer. Please try again.');}}}/**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */async _handleOffer(peerId,offer){try{// Get or create peer connection\nlet peerConnection=this.peerConnections.get(peerId);if(!peerConnection){peerConnection=this._createPeerConnection(peerId);}// Set remote description\nawait peerConnection.setRemoteDescription(new RTCSessionDescription(offer));// Create answer\nconst answer=await peerConnection.createAnswer();// Set local description\nawait peerConnection.setLocalDescription(answer);// Send answer to peer\nthis.socket.emit('answer',{roomId:this.roomId,to:peerId,from:this.userId,answer:peerConnection.localDescription});}catch(error){console.error('Error handling offer:',error);if(this.onError){this.onError('Failed to process incoming connection. Please try again.');}}}/**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   */async _handleAnswer(peerId,answer){try{const peerConnection=this.peerConnections.get(peerId);if(peerConnection){await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));}}catch(error){console.error('Error handling answer:',error);if(this.onError){this.onError('Failed to establish connection. Please try again.');}}}/**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   */async _handleIceCandidate(peerId,candidate){try{const peerConnection=this.peerConnections.get(peerId);if(peerConnection){await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));}}catch(error){console.error('Error handling ICE candidate:',error);}}/**\n   * Bind socket event handlers\n   */_bindSocketEvents(){if(!this.socket)return;// Handle user joined event\nthis.socket.on('userJoined',_ref=>{let{userId}=_ref;if(userId!==this.userId){this._createPeerConnection(userId,true);}});// Handle user left event\nthis.socket.on('userLeft',_ref2=>{let{userId}=_ref2;this._cleanupPeerConnection(userId);if(this.onPeerDisconnect){this.onPeerDisconnect(userId);}});// Handle offer\nthis.socket.on('offer',_ref3=>{let{from,offer}=_ref3;this._handleOffer(from,offer);});// Handle answer\nthis.socket.on('answer',_ref4=>{let{from,answer}=_ref4;this._handleAnswer(from,answer);});// Handle ICE candidate\nthis.socket.on('iceCandidate',_ref5=>{let{from,candidate}=_ref5;this._handleIceCandidate(from,candidate);});// Handle speaking status\nthis.socket.on('speaking',_ref6=>{let{userId,speaking}=_ref6;if(this.onSpeakingChange&&userId!==this.userId){this.onSpeakingChange(speaking,userId);}});}/**\n   * Clean up peer connection\n   * @param {string} peerId - ID of the peer to clean up\n   */_cleanupPeerConnection(peerId){// Clean up quality monitor\nconst qualityMonitor=this.audioQualityMonitors.get(peerId);if(qualityMonitor){qualityMonitor.dispose();this.audioQualityMonitors.delete(peerId);}// Clean up peer connection\nconst peerConnection=this.peerConnections.get(peerId);if(peerConnection){peerConnection.onicecandidate=null;peerConnection.ontrack=null;peerConnection.onconnectionstatechange=null;// Close connection\npeerConnection.close();this.peerConnections.delete(peerId);}}/**\n   * Mute or unmute local audio\n   * @param {boolean} muted - Whether to mute audio\n   */setMuted(muted){if(this.localStream){this.localStream.getAudioTracks().forEach(track=>{track.enabled=!muted;});}}/**\n   * Check if local audio is muted\n   * @returns {boolean} Whether local audio is muted\n   */isMuted(){if(this.localStream){const audioTracks=this.localStream.getAudioTracks();if(audioTracks.length>0){return!audioTracks[0].enabled;}}return true;}/**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */getAudioLevel(){if(this.speakingDetector){return this.speakingDetector.getAudioLevel();}return 0;}/**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */async getConnectionQuality(peerId){const qualityMonitor=this.audioQualityMonitors.get(peerId);if(qualityMonitor){return await qualityMonitor.getQualityMetrics();}return{quality:'unknown',metrics:{}};}/**\n   * Leave the room and clean up all connections\n   */leaveRoom(){// Stop speaking detector\nif(this.speakingDetector){this.speakingDetector.dispose();this.speakingDetector=null;}// Clean up all peer connections\nfor(const peerId of this.peerConnections.keys()){this._cleanupPeerConnection(peerId);}// Stop local stream tracks\nif(this.localStream){this.localStream.getTracks().forEach(track=>{track.stop();});this.localStream=null;}// Leave room via socket\nif(this.socket&&this.socket.connected){this.socket.emit('leave',{roomId:this.roomId,userId:this.userId});}this.roomId=null;}/**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<void>}\n   */async startCall(peerId){try{// Create peer connection if it doesn't exist\nlet peerConnection=this.peerConnections.get(peerId);if(!peerConnection){peerConnection=this._createPeerConnection(peerId,true);}else{// If connection exists but we need to initiate a call\nthis._createAndSendOffer(peerId);}return peerConnection;}catch(error){console.error('Error starting call:',error);if(this.onError){this.onError('Failed to start call. Please try again.');}throw error;}}/**\n   * Dispose of all resources\n   */dispose(){this.leaveRoom();// Unbind socket events\nif(this.socket){this.socket.off('userJoined');this.socket.off('userLeft');this.socket.off('offer');this.socket.off('answer');this.socket.off('iceCandidate');this.socket.off('speaking');}}}","map":{"version":3,"names":["createEnhancedAudioStream","SpeakingDetector","AudioQualityMonitor","WebRTCManager","constructor","socket","options","arguments","length","undefined","peerConnections","Map","localStream","roomId","userId","Math","random","toString","substr","speakingDetector","audioQualityMonitors","config","iceServers","urls","iceTransportPolicy","sdpSemantics","rtcpMuxPolicy","audioConstraints","echoCancellation","noiseSuppression","autoGainControl","channelCount","sampleRate","sampleSize","onPeerConnect","onPeerDisconnect","onSpeakingChange","onAudioQualityChange","onError","_bindSocketEvents","initialize","stream","navigator","mediaDevices","getUserMedia","audio","video","threshold","speaking","connected","emit","start","error","console","_createPeerConnection","peerId","isInitiator","peerConnection","RTCPeerConnection","getTracks","forEach","track","addTrack","onicecandidate","event","candidate","to","from","onconnectionstatechange","connectionState","log","_cleanupPeerConnection","ontrack","streams","qualityMonitor","onQualityChange","quality","metrics","set","_createAndSendOffer","get","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","localDescription","_handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","_handleAnswer","_handleIceCandidate","addIceCandidate","RTCIceCandidate","on","_ref","_ref2","_ref3","_ref4","_ref5","_ref6","dispose","delete","close","setMuted","muted","getAudioTracks","enabled","isMuted","audioTracks","getAudioLevel","getConnectionQuality","getQualityMetrics","leaveRoom","keys","stop","startCall","off"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcManager.js"],"sourcesContent":["import { createEnhancedAudioStream, SpeakingDetector, AudioQualityMonitor } from './audioProcessor';\n\n/**\n * WebRTC Connection Manager\n * \n * Manages WebRTC peer connections with enhanced audio processing,\n * connection resilience, and adaptive bitrate streaming.\n */\nexport class WebRTCManager {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.peerConnections = new Map(); // Map of peer ID to RTCPeerConnection\n    this.localStream = null;\n    this.roomId = null;\n    this.userId = options.userId || `user_${Math.random().toString(36).substr(2, 9)}`;\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    \n    // Configuration\n    this.config = {\n      iceServers: options.iceServers || [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n      ],\n      iceTransportPolicy: options.iceTransportPolicy || 'all',\n      sdpSemantics: 'unified-plan',\n      // Enable DTLS-SRTP for end-to-end encryption\n      // This is enabled by default in modern browsers\n      // but we explicitly set it for clarity\n      rtcpMuxPolicy: 'require',\n    };\n    \n    // Audio constraints\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      // Prioritize voice clarity\n      channelCount: 1,\n      sampleRate: 48000,\n      sampleSize: 16,\n    };\n    \n    // Event callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n    \n    // Bind socket event handlers\n    this._bindSocketEvents();\n  }\n  \n  /**\n   * Initialize WebRTC manager and join a room\n   * @param {string} roomId - Room ID to join\n   * @returns {Promise<void>}\n   */\n  async initialize(roomId) {\n    try {\n      this.roomId = roomId;\n      \n      // Get user media with enhanced audio\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false,\n      });\n      \n      // Apply enhanced audio processing\n      this.localStream = await createEnhancedAudioStream(stream);\n      \n      // Initialize speaking detector\n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        threshold: 15,\n        onSpeakingChange: (speaking) => {\n          if (this.onSpeakingChange) {\n            this.onSpeakingChange(speaking);\n          }\n          \n          // Emit speaking status to other peers\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              userId: this.userId,\n              speaking,\n            });\n          }\n        }\n      });\n      this.speakingDetector.start();\n      \n      // Join room\n      this.socket.emit('join', {\n        roomId: this.roomId,\n        userId: this.userId,\n      });\n      \n      return this.localStream;\n    } catch (error) {\n      console.error('Failed to initialize WebRTC:', error);\n      if (this.onError) {\n        this.onError('Failed to access microphone. Please check your permissions.');\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n      \n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Handle ICE candidates\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          this.socket.emit('iceCandidate', {\n            roomId: this.roomId,\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate,\n          });\n        }\n      };\n      \n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            if (this.onPeerConnect) {\n              this.onPeerConnect(peerId);\n            }\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            this._cleanupPeerConnection(peerId);\n            break;\n          default:\n            console.log(`Connection state changed to: ${peerConnection.connectionState}`);\n            break;\n        }\n      };\n      \n      // Handle incoming tracks\n      peerConnection.ontrack = (event) => {\n        const stream = event.streams[0];\n        // Store remote stream and create audio element\n        if (stream) {\n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n          \n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n      \n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n      \n      // If initiator, create and send offer\n      if (isInitiator) {\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n  \n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) return;\n      \n      // Create offer with audio preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      });\n      \n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      \n      // Send offer to peer\n      this.socket.emit('offer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription,\n      });\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      \n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      \n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      \n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      \n      // Send answer to peer\n      this.socket.emit('answer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription,\n      });\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n    }\n  }\n  \n  /**\n   * Bind socket event handlers\n   */\n  _bindSocketEvents() {\n    if (!this.socket) return;\n    \n    // Handle user joined event\n    this.socket.on('userJoined', ({ userId }) => {\n      if (userId !== this.userId) {\n        this._createPeerConnection(userId, true);\n      }\n    });\n    \n    // Handle user left event\n    this.socket.on('userLeft', ({ userId }) => {\n      this._cleanupPeerConnection(userId);\n      if (this.onPeerDisconnect) {\n        this.onPeerDisconnect(userId);\n      }\n    });\n    \n    // Handle offer\n    this.socket.on('offer', ({ from, offer }) => {\n      this._handleOffer(from, offer);\n    });\n    \n    // Handle answer\n    this.socket.on('answer', ({ from, answer }) => {\n      this._handleAnswer(from, answer);\n    });\n    \n    // Handle ICE candidate\n    this.socket.on('iceCandidate', ({ from, candidate }) => {\n      this._handleIceCandidate(from, candidate);\n    });\n    \n    // Handle speaking status\n    this.socket.on('speaking', ({ userId, speaking }) => {\n      if (this.onSpeakingChange && userId !== this.userId) {\n        this.onSpeakingChange(speaking, userId);\n      }\n    });\n  }\n  \n  /**\n   * Clean up peer connection\n   * @param {string} peerId - ID of the peer to clean up\n   */\n  _cleanupPeerConnection(peerId) {\n    // Clean up quality monitor\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      qualityMonitor.dispose();\n      this.audioQualityMonitors.delete(peerId);\n    }\n    \n    // Clean up peer connection\n    const peerConnection = this.peerConnections.get(peerId);\n    if (peerConnection) {\n      peerConnection.onicecandidate = null;\n      peerConnection.ontrack = null;\n      peerConnection.onconnectionstatechange = null;\n      \n      // Close connection\n      peerConnection.close();\n      this.peerConnections.delete(peerId);\n    }\n  }\n  \n  /**\n   * Mute or unmute local audio\n   * @param {boolean} muted - Whether to mute audio\n   */\n  setMuted(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Check if local audio is muted\n   * @returns {boolean} Whether local audio is muted\n   */\n  isMuted() {\n    if (this.localStream) {\n      const audioTracks = this.localStream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        return !audioTracks[0].enabled;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (this.speakingDetector) {\n      return this.speakingDetector.getAudioLevel();\n    }\n    return 0;\n  }\n  \n  /**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getConnectionQuality(peerId) {\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      return await qualityMonitor.getQualityMetrics();\n    }\n    return { quality: 'unknown', metrics: {} };\n  }\n  \n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop speaking detector\n    if (this.speakingDetector) {\n      this.speakingDetector.dispose();\n      this.speakingDetector = null;\n    }\n    \n    // Clean up all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n    \n    // Stop local stream tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.localStream = null;\n    }\n    \n    // Leave room via socket\n    if (this.socket && this.socket.connected) {\n      this.socket.emit('leave', {\n        roomId: this.roomId,\n        userId: this.userId,\n      });\n    }\n    \n    this.roomId = null;\n  }\n  \n  /**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<void>}\n   */\n  async startCall(peerId) {\n    try {\n      // Create peer connection if it doesn't exist\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        peerConnection = this._createPeerConnection(peerId, true);\n      } else {\n        // If connection exists but we need to initiate a call\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error starting call:', error);\n      if (this.onError) {\n        this.onError('Failed to start call. Please try again.');\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    this.leaveRoom();\n    \n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}