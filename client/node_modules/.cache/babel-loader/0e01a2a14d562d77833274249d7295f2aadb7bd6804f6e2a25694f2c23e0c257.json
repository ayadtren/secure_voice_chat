{"ast":null,"code":"/**\n * SpeakingDetector class for detecting when a user is speaking\n * Used by WebRTCManager to provide speaking indicators\n */\nclass SpeakingDetector {\n  constructor(stream, options = {}) {\n    this.stream = stream;\n    this.options = {\n      threshold: options.threshold || -50,\n      // dB threshold for speaking detection\n      interval: options.interval || 100,\n      // ms between checks\n      minSpeakingTime: options.minSpeakingTime || 200,\n      // ms of sound above threshold to be considered speaking\n      speakingDecayTime: options.speakingDecayTime || 500,\n      // ms of silence before considered not speaking\n      ...options\n    };\n    this.speaking = false;\n    this.audioContext = null;\n    this.analyser = null;\n    this.dataArray = null;\n    this.speakingStartTime = null;\n    this.silenceStartTime = null;\n    this.checkInterval = null;\n    this.onSpeakingChange = options.onSpeakingChange || (() => {});\n  }\n\n  /**\n   * Initialize the audio context and analyzer\n   */\n  _initAudio() {\n    if (!this.stream) return;\n    try {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const source = this.audioContext.createMediaStreamSource(this.stream);\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 512;\n      this.analyser.smoothingTimeConstant = 0.5;\n      source.connect(this.analyser);\n      const bufferLength = this.analyser.frequencyBinCount;\n      this.dataArray = new Uint8Array(bufferLength);\n    } catch (error) {\n      console.error('Failed to initialize audio analyzer:', error);\n    }\n  }\n\n  /**\n   * Calculate the volume level in dB from the frequency data\n   * @returns {number} Volume level in dB\n   */\n  _getVolumeLevel() {\n    if (!this.analyser || !this.dataArray) return -Infinity;\n    this.analyser.getByteFrequencyData(this.dataArray);\n\n    // Calculate the average volume\n    let sum = 0;\n    for (let i = 0; i < this.dataArray.length; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.dataArray.length;\n\n    // Convert to dB (0-255 scale to dB)\n    // -100dB (silence) to 0dB (max volume)\n    const dB = average === 0 ? -100 : 20 * Math.log10(average / 255);\n    return dB;\n  }\n\n  /**\n   * Check if the user is speaking based on volume level\n   */\n  _checkSpeaking() {\n    const volumeLevel = this._getVolumeLevel();\n    const now = Date.now();\n\n    // Check if volume is above threshold\n    if (volumeLevel > this.options.threshold) {\n      if (!this.speakingStartTime) {\n        this.speakingStartTime = now;\n      }\n      this.silenceStartTime = null;\n\n      // If speaking for longer than minSpeakingTime, mark as speaking\n      if (!this.speaking && now - this.speakingStartTime >= this.options.minSpeakingTime) {\n        this.speaking = true;\n        this.onSpeakingChange(true);\n      }\n    } else {\n      // Volume is below threshold (silence)\n      if (!this.silenceStartTime) {\n        this.silenceStartTime = now;\n      }\n\n      // If silent for longer than speakingDecayTime, mark as not speaking\n      if (this.speaking && this.silenceStartTime && now - this.silenceStartTime >= this.options.speakingDecayTime) {\n        this.speaking = false;\n        this.speakingStartTime = null;\n        this.onSpeakingChange(false);\n      }\n    }\n  }\n\n  /**\n   * Start the speaking detector\n   */\n  start() {\n    if (this.checkInterval) return;\n    this._initAudio();\n    this.checkInterval = setInterval(() => this._checkSpeaking(), this.options.interval);\n  }\n\n  /**\n   * Stop the speaking detector\n   */\n  stop() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n    }\n    this.speaking = false;\n    this.speakingStartTime = null;\n    this.silenceStartTime = null;\n  }\n\n  /**\n   * Check if the user is currently speaking\n   * @returns {boolean} Whether the user is speaking\n   */\n  isSpeaking() {\n    return this.speaking;\n  }\n}\nexport default SpeakingDetector;","map":{"version":3,"names":["SpeakingDetector","constructor","stream","options","threshold","interval","minSpeakingTime","speakingDecayTime","speaking","audioContext","analyser","dataArray","speakingStartTime","silenceStartTime","checkInterval","onSpeakingChange","_initAudio","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","createAnalyser","fftSize","smoothingTimeConstant","connect","bufferLength","frequencyBinCount","Uint8Array","error","console","_getVolumeLevel","Infinity","getByteFrequencyData","sum","i","length","average","dB","Math","log10","_checkSpeaking","volumeLevel","now","Date","start","setInterval","stop","clearInterval","state","close","isSpeaking"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/speakingDetector.js"],"sourcesContent":["/**\n * SpeakingDetector class for detecting when a user is speaking\n * Used by WebRTCManager to provide speaking indicators\n */\nclass SpeakingDetector {\n  constructor(stream, options = {}) {\n    this.stream = stream;\n    this.options = {\n      threshold: options.threshold || -50, // dB threshold for speaking detection\n      interval: options.interval || 100, // ms between checks\n      minSpeakingTime: options.minSpeakingTime || 200, // ms of sound above threshold to be considered speaking\n      speakingDecayTime: options.speakingDecayTime || 500, // ms of silence before considered not speaking\n      ...options\n    };\n    \n    this.speaking = false;\n    this.audioContext = null;\n    this.analyser = null;\n    this.dataArray = null;\n    this.speakingStartTime = null;\n    this.silenceStartTime = null;\n    this.checkInterval = null;\n    this.onSpeakingChange = options.onSpeakingChange || (() => {});\n  }\n\n  /**\n   * Initialize the audio context and analyzer\n   */\n  _initAudio() {\n    if (!this.stream) return;\n\n    try {\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const source = this.audioContext.createMediaStreamSource(this.stream);\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 512;\n      this.analyser.smoothingTimeConstant = 0.5;\n      source.connect(this.analyser);\n      \n      const bufferLength = this.analyser.frequencyBinCount;\n      this.dataArray = new Uint8Array(bufferLength);\n    } catch (error) {\n      console.error('Failed to initialize audio analyzer:', error);\n    }\n  }\n\n  /**\n   * Calculate the volume level in dB from the frequency data\n   * @returns {number} Volume level in dB\n   */\n  _getVolumeLevel() {\n    if (!this.analyser || !this.dataArray) return -Infinity;\n    \n    this.analyser.getByteFrequencyData(this.dataArray);\n    \n    // Calculate the average volume\n    let sum = 0;\n    for (let i = 0; i < this.dataArray.length; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.dataArray.length;\n    \n    // Convert to dB (0-255 scale to dB)\n    // -100dB (silence) to 0dB (max volume)\n    const dB = average === 0 ? -100 : 20 * Math.log10(average / 255);\n    \n    return dB;\n  }\n\n  /**\n   * Check if the user is speaking based on volume level\n   */\n  _checkSpeaking() {\n    const volumeLevel = this._getVolumeLevel();\n    const now = Date.now();\n    \n    // Check if volume is above threshold\n    if (volumeLevel > this.options.threshold) {\n      if (!this.speakingStartTime) {\n        this.speakingStartTime = now;\n      }\n      this.silenceStartTime = null;\n      \n      // If speaking for longer than minSpeakingTime, mark as speaking\n      if (!this.speaking && now - this.speakingStartTime >= this.options.minSpeakingTime) {\n        this.speaking = true;\n        this.onSpeakingChange(true);\n      }\n    } else {\n      // Volume is below threshold (silence)\n      if (!this.silenceStartTime) {\n        this.silenceStartTime = now;\n      }\n      \n      // If silent for longer than speakingDecayTime, mark as not speaking\n      if (this.speaking && this.silenceStartTime && \n          now - this.silenceStartTime >= this.options.speakingDecayTime) {\n        this.speaking = false;\n        this.speakingStartTime = null;\n        this.onSpeakingChange(false);\n      }\n    }\n  }\n\n  /**\n   * Start the speaking detector\n   */\n  start() {\n    if (this.checkInterval) return;\n    \n    this._initAudio();\n    this.checkInterval = setInterval(() => this._checkSpeaking(), this.options.interval);\n  }\n\n  /**\n   * Stop the speaking detector\n   */\n  stop() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    \n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n    }\n    \n    this.speaking = false;\n    this.speakingStartTime = null;\n    this.silenceStartTime = null;\n  }\n\n  /**\n   * Check if the user is currently speaking\n   * @returns {boolean} Whether the user is speaking\n   */\n  isSpeaking() {\n    return this.speaking;\n  }\n}\n\nexport default SpeakingDetector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}