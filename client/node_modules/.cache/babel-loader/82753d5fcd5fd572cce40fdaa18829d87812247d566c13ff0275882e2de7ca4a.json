{"ast":null,"code":"/**\n * Advanced Audio Processing Utility\n * \n * Provides enhanced audio processing capabilities for WebRTC voice chat:\n * - Noise suppression\n * - Echo cancellation\n * - Volume normalization\n * - Speaking detection\n * - Audio quality monitoring\n */\n\n/**\n * Creates an enhanced audio stream with noise suppression and echo cancellation\n * @param {MediaStream} originalStream - The original audio stream from getUserMedia\n * @returns {Promise<MediaStream>} - Enhanced audio stream\n */\nexport async function createEnhancedAudioStream(originalStream) {\n  try {\n    // Check if browser supports advanced audio processing\n    const supportsAudioWorklet = 'AudioWorklet' in window.AudioContext.prototype;\n\n    // Create audio context\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n    // Get audio track from original stream\n    const audioTrack = originalStream.getAudioTracks()[0];\n    if (!audioTrack) {\n      console.warn('No audio track found in the stream');\n      return originalStream;\n    }\n\n    // Create source from the original audio track\n    const source = audioContext.createMediaStreamSource(originalStream);\n\n    // Create destination for processed audio\n    const destination = audioContext.createMediaStreamDestination();\n\n    // Apply audio constraints for echo cancellation and noise suppression\n    // Note: These constraints work in conjunction with getUserMedia constraints\n    try {\n      await audioTrack.applyConstraints({\n        echoCancellation: true,\n        noiseSuppression: true,\n        autoGainControl: true\n      });\n    } catch (err) {\n      console.warn('Could not apply audio constraints:', err);\n    }\n\n    // If browser supports AudioWorklet, use it for advanced processing\n    if (supportsAudioWorklet) {\n      try {\n        // Create gain node for volume control\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0; // Default gain\n\n        // Connect the audio processing chain\n        source.connect(gainNode);\n        gainNode.connect(destination);\n        console.log('Enhanced audio stream created with AudioWorklet support');\n      } catch (err) {\n        console.warn('Error setting up AudioWorklet processing:', err);\n        // Fallback: direct connection\n        source.connect(destination);\n      }\n    } else {\n      // Fallback for browsers without AudioWorklet support\n      console.log('AudioWorklet not supported, using basic audio processing');\n      source.connect(destination);\n    }\n\n    // Return the processed stream\n    return destination.stream;\n  } catch (error) {\n    console.error('Error creating enhanced audio stream:', error);\n    // Return original stream as fallback\n    return originalStream;\n  }\n}\n\n/**\n * Audio level detector for speaking indication\n */\nexport class SpeakingDetector {\n  constructor(stream, options = {}) {\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    this.stream = stream;\n    this.source = this.audioContext.createMediaStreamSource(stream);\n    this.analyser = this.audioContext.createAnalyser();\n\n    // Configure analyser\n    this.analyser.fftSize = 256;\n    this.analyser.smoothingTimeConstant = 0.5;\n    this.bufferLength = this.analyser.frequencyBinCount;\n    this.dataArray = new Uint8Array(this.bufferLength);\n\n    // Connect source to analyser\n    this.source.connect(this.analyser);\n\n    // Speaking detection configuration\n    this.threshold = options.threshold || 20; // Default threshold\n    this.speakingHistory = [];\n    this.historyLength = options.historyLength || 5;\n    this.speaking = false;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n\n    // Start detection\n    this.isRunning = false;\n  }\n\n  /**\n   * Start the speaking detection\n   */\n  start() {\n    if (this.isRunning) return;\n    this.isRunning = true;\n    this.detectSpeaking();\n  }\n\n  /**\n   * Stop the speaking detection\n   */\n  stop() {\n    this.isRunning = false;\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  /**\n   * Main detection loop\n   */\n  detectSpeaking() {\n    if (!this.isRunning) return;\n    this.analyser.getByteFrequencyData(this.dataArray);\n\n    // Calculate average volume\n    let sum = 0;\n    for (let i = 0; i < this.bufferLength; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.bufferLength;\n\n    // Add to history\n    this.speakingHistory.push(average);\n    if (this.speakingHistory.length > this.historyLength) {\n      this.speakingHistory.shift();\n    }\n\n    // Calculate average from history to reduce false positives\n    const historyAverage = this.speakingHistory.reduce((a, b) => a + b, 0) / this.speakingHistory.length;\n\n    // Determine if speaking\n    const isSpeaking = historyAverage > this.threshold;\n\n    // Notify if speaking state changed\n    if (isSpeaking !== this.speaking) {\n      this.speaking = isSpeaking;\n      if (this.onSpeakingChange) {\n        this.onSpeakingChange(this.speaking);\n      }\n    }\n\n    // Continue detection loop\n    this.animationFrame = requestAnimationFrame(this.detectSpeaking.bind(this));\n  }\n\n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (!this.isRunning) return 0;\n    this.analyser.getByteFrequencyData(this.dataArray);\n\n    // Calculate average volume\n    let sum = 0;\n    for (let i = 0; i < this.bufferLength; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.bufferLength;\n\n    // Convert to 0-100 scale\n    return Math.min(100, Math.max(0, average * (100 / 256)));\n  }\n\n  /**\n   * Set speaking detection threshold\n   * @param {number} threshold - New threshold value (0-100)\n   */\n  setThreshold(threshold) {\n    this.threshold = Math.min(100, Math.max(0, threshold));\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.stop();\n    if (this.source) {\n      this.source.disconnect();\n    }\n  }\n}\n\n/**\n * Audio quality monitor for adaptive streaming\n */\nexport class AudioQualityMonitor {\n  constructor(peerConnection, options = {}) {\n    this.peerConnection = peerConnection;\n    this.interval = options.interval || 2000; // Check interval in ms\n    this.onQualityChange = options.onQualityChange || null;\n    this.qualityThresholds = {\n      excellent: {\n        packetLoss: 0.01,\n        jitter: 10\n      },\n      good: {\n        packetLoss: 0.03,\n        jitter: 30\n      },\n      fair: {\n        packetLoss: 0.08,\n        jitter: 50\n      },\n      poor: {\n        packetLoss: 0.15,\n        jitter: 100\n      }\n      // Anything worse is considered \"bad\"\n    };\n    this.currentQuality = 'unknown';\n    this.intervalId = null;\n  }\n\n  /**\n   * Start monitoring audio quality\n   */\n  start() {\n    if (this.intervalId) return;\n    this.intervalId = setInterval(() => this.checkQuality(), this.interval);\n  }\n\n  /**\n   * Stop monitoring audio quality\n   */\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n\n  /**\n   * Check current audio quality\n   */\n  async checkQuality() {\n    if (!this.peerConnection) return;\n    try {\n      const stats = await this.peerConnection.getStats();\n      let audioInboundStats = null;\n\n      // Find audio inbound-rtp stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\n          audioInboundStats = stat;\n        }\n      });\n      if (!audioInboundStats) return;\n\n      // Calculate packet loss\n      const packetsLost = audioInboundStats.packetsLost || 0;\n      const packetsReceived = audioInboundStats.packetsReceived || 1; // Avoid division by zero\n      const packetLossRate = packetsLost / (packetsLost + packetsReceived);\n\n      // Get jitter (in milliseconds)\n      const jitter = (audioInboundStats.jitter || 0) * 1000;\n\n      // Determine quality level\n      let quality = 'bad';\n      if (packetLossRate <= this.qualityThresholds.excellent.packetLoss && jitter <= this.qualityThresholds.excellent.jitter) {\n        quality = 'excellent';\n      } else if (packetLossRate <= this.qualityThresholds.good.packetLoss && jitter <= this.qualityThresholds.good.jitter) {\n        quality = 'good';\n      } else if (packetLossRate <= this.qualityThresholds.fair.packetLoss && jitter <= this.qualityThresholds.fair.jitter) {\n        quality = 'fair';\n      } else if (packetLossRate <= this.qualityThresholds.poor.packetLoss && jitter <= this.qualityThresholds.poor.jitter) {\n        quality = 'poor';\n      }\n\n      // Notify if quality changed\n      if (quality !== this.currentQuality) {\n        this.currentQuality = quality;\n        if (this.onQualityChange) {\n          this.onQualityChange(quality, {\n            packetLossRate,\n            jitter\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error checking audio quality:', error);\n    }\n  }\n\n  /**\n   * Get current quality metrics\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getQualityMetrics() {\n    if (!this.peerConnection) {\n      return {\n        quality: 'unknown',\n        metrics: {}\n      };\n    }\n    try {\n      const stats = await this.peerConnection.getStats();\n      let audioInboundStats = null;\n      let audioOutboundStats = null;\n\n      // Find audio stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\n          audioInboundStats = stat;\n        }\n        if (stat.type === 'outbound-rtp' && stat.kind === 'audio') {\n          audioOutboundStats = stat;\n        }\n      });\n      const metrics = {\n        inbound: audioInboundStats ? {\n          packetsReceived: audioInboundStats.packetsReceived || 0,\n          packetsLost: audioInboundStats.packetsLost || 0,\n          jitter: (audioInboundStats.jitter || 0) * 1000,\n          // ms\n          bytesReceived: audioInboundStats.bytesReceived || 0\n        } : null,\n        outbound: audioOutboundStats ? {\n          packetsSent: audioOutboundStats.packetsSent || 0,\n          bytesSent: audioOutboundStats.bytesSent || 0\n        } : null,\n        quality: this.currentQuality\n      };\n      return metrics;\n    } catch (error) {\n      console.error('Error getting quality metrics:', error);\n      return {\n        quality: 'unknown',\n        metrics: {}\n      };\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.stop();\n    this.peerConnection = null;\n  }\n}","map":{"version":3,"names":["createEnhancedAudioStream","originalStream","supportsAudioWorklet","window","AudioContext","prototype","audioContext","webkitAudioContext","audioTrack","getAudioTracks","console","warn","source","createMediaStreamSource","destination","createMediaStreamDestination","applyConstraints","echoCancellation","noiseSuppression","autoGainControl","err","gainNode","createGain","gain","value","connect","log","stream","error","SpeakingDetector","constructor","options","analyser","createAnalyser","fftSize","smoothingTimeConstant","bufferLength","frequencyBinCount","dataArray","Uint8Array","threshold","speakingHistory","historyLength","speaking","onSpeakingChange","isRunning","start","detectSpeaking","stop","animationFrame","cancelAnimationFrame","getByteFrequencyData","sum","i","average","push","length","shift","historyAverage","reduce","a","b","isSpeaking","requestAnimationFrame","bind","getAudioLevel","Math","min","max","setThreshold","dispose","disconnect","AudioQualityMonitor","peerConnection","interval","onQualityChange","qualityThresholds","excellent","packetLoss","jitter","good","fair","poor","currentQuality","intervalId","setInterval","checkQuality","clearInterval","stats","getStats","audioInboundStats","forEach","stat","type","kind","packetsLost","packetsReceived","packetLossRate","quality","getQualityMetrics","metrics","audioOutboundStats","inbound","bytesReceived","outbound","packetsSent","bytesSent"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/audioProcessor.js"],"sourcesContent":["/**\n * Advanced Audio Processing Utility\n * \n * Provides enhanced audio processing capabilities for WebRTC voice chat:\n * - Noise suppression\n * - Echo cancellation\n * - Volume normalization\n * - Speaking detection\n * - Audio quality monitoring\n */\n\n/**\n * Creates an enhanced audio stream with noise suppression and echo cancellation\n * @param {MediaStream} originalStream - The original audio stream from getUserMedia\n * @returns {Promise<MediaStream>} - Enhanced audio stream\n */\nexport async function createEnhancedAudioStream(originalStream) {\n  try {\n    // Check if browser supports advanced audio processing\n    const supportsAudioWorklet = 'AudioWorklet' in window.AudioContext.prototype;\n    \n    // Create audio context\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    \n    // Get audio track from original stream\n    const audioTrack = originalStream.getAudioTracks()[0];\n    \n    if (!audioTrack) {\n      console.warn('No audio track found in the stream');\n      return originalStream;\n    }\n    \n    // Create source from the original audio track\n    const source = audioContext.createMediaStreamSource(originalStream);\n    \n    // Create destination for processed audio\n    const destination = audioContext.createMediaStreamDestination();\n    \n    // Apply audio constraints for echo cancellation and noise suppression\n    // Note: These constraints work in conjunction with getUserMedia constraints\n    try {\n      await audioTrack.applyConstraints({\n        echoCancellation: true,\n        noiseSuppression: true,\n        autoGainControl: true,\n      });\n    } catch (err) {\n      console.warn('Could not apply audio constraints:', err);\n    }\n    \n    // If browser supports AudioWorklet, use it for advanced processing\n    if (supportsAudioWorklet) {\n      try {\n        // Create gain node for volume control\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0; // Default gain\n        \n        // Connect the audio processing chain\n        source.connect(gainNode);\n        gainNode.connect(destination);\n        \n        console.log('Enhanced audio stream created with AudioWorklet support');\n      } catch (err) {\n        console.warn('Error setting up AudioWorklet processing:', err);\n        // Fallback: direct connection\n        source.connect(destination);\n      }\n    } else {\n      // Fallback for browsers without AudioWorklet support\n      console.log('AudioWorklet not supported, using basic audio processing');\n      source.connect(destination);\n    }\n    \n    // Return the processed stream\n    return destination.stream;\n  } catch (error) {\n    console.error('Error creating enhanced audio stream:', error);\n    // Return original stream as fallback\n    return originalStream;\n  }\n}\n\n/**\n * Audio level detector for speaking indication\n */\nexport class SpeakingDetector {\n  constructor(stream, options = {}) {\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    this.stream = stream;\n    this.source = this.audioContext.createMediaStreamSource(stream);\n    this.analyser = this.audioContext.createAnalyser();\n    \n    // Configure analyser\n    this.analyser.fftSize = 256;\n    this.analyser.smoothingTimeConstant = 0.5;\n    this.bufferLength = this.analyser.frequencyBinCount;\n    this.dataArray = new Uint8Array(this.bufferLength);\n    \n    // Connect source to analyser\n    this.source.connect(this.analyser);\n    \n    // Speaking detection configuration\n    this.threshold = options.threshold || 20; // Default threshold\n    this.speakingHistory = [];\n    this.historyLength = options.historyLength || 5;\n    this.speaking = false;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    \n    // Start detection\n    this.isRunning = false;\n  }\n  \n  /**\n   * Start the speaking detection\n   */\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    this.detectSpeaking();\n  }\n  \n  /**\n   * Stop the speaking detection\n   */\n  stop() {\n    this.isRunning = false;\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n  \n  /**\n   * Main detection loop\n   */\n  detectSpeaking() {\n    if (!this.isRunning) return;\n    \n    this.analyser.getByteFrequencyData(this.dataArray);\n    \n    // Calculate average volume\n    let sum = 0;\n    for (let i = 0; i < this.bufferLength; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.bufferLength;\n    \n    // Add to history\n    this.speakingHistory.push(average);\n    if (this.speakingHistory.length > this.historyLength) {\n      this.speakingHistory.shift();\n    }\n    \n    // Calculate average from history to reduce false positives\n    const historyAverage = this.speakingHistory.reduce((a, b) => a + b, 0) / this.speakingHistory.length;\n    \n    // Determine if speaking\n    const isSpeaking = historyAverage > this.threshold;\n    \n    // Notify if speaking state changed\n    if (isSpeaking !== this.speaking) {\n      this.speaking = isSpeaking;\n      if (this.onSpeakingChange) {\n        this.onSpeakingChange(this.speaking);\n      }\n    }\n    \n    // Continue detection loop\n    this.animationFrame = requestAnimationFrame(this.detectSpeaking.bind(this));\n  }\n  \n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (!this.isRunning) return 0;\n    \n    this.analyser.getByteFrequencyData(this.dataArray);\n    \n    // Calculate average volume\n    let sum = 0;\n    for (let i = 0; i < this.bufferLength; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.bufferLength;\n    \n    // Convert to 0-100 scale\n    return Math.min(100, Math.max(0, average * (100 / 256)));\n  }\n  \n  /**\n   * Set speaking detection threshold\n   * @param {number} threshold - New threshold value (0-100)\n   */\n  setThreshold(threshold) {\n    this.threshold = Math.min(100, Math.max(0, threshold));\n  }\n  \n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.stop();\n    if (this.source) {\n      this.source.disconnect();\n    }\n  }\n}\n\n/**\n * Audio quality monitor for adaptive streaming\n */\nexport class AudioQualityMonitor {\n  constructor(peerConnection, options = {}) {\n    this.peerConnection = peerConnection;\n    this.interval = options.interval || 2000; // Check interval in ms\n    this.onQualityChange = options.onQualityChange || null;\n    this.qualityThresholds = {\n      excellent: { packetLoss: 0.01, jitter: 10 },\n      good: { packetLoss: 0.03, jitter: 30 },\n      fair: { packetLoss: 0.08, jitter: 50 },\n      poor: { packetLoss: 0.15, jitter: 100 },\n      // Anything worse is considered \"bad\"\n    };\n    \n    this.currentQuality = 'unknown';\n    this.intervalId = null;\n  }\n  \n  /**\n   * Start monitoring audio quality\n   */\n  start() {\n    if (this.intervalId) return;\n    \n    this.intervalId = setInterval(() => this.checkQuality(), this.interval);\n  }\n  \n  /**\n   * Stop monitoring audio quality\n   */\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n  \n  /**\n   * Check current audio quality\n   */\n  async checkQuality() {\n    if (!this.peerConnection) return;\n    \n    try {\n      const stats = await this.peerConnection.getStats();\n      let audioInboundStats = null;\n      \n      // Find audio inbound-rtp stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\n          audioInboundStats = stat;\n        }\n      });\n      \n      if (!audioInboundStats) return;\n      \n      // Calculate packet loss\n      const packetsLost = audioInboundStats.packetsLost || 0;\n      const packetsReceived = audioInboundStats.packetsReceived || 1; // Avoid division by zero\n      const packetLossRate = packetsLost / (packetsLost + packetsReceived);\n      \n      // Get jitter (in milliseconds)\n      const jitter = (audioInboundStats.jitter || 0) * 1000;\n      \n      // Determine quality level\n      let quality = 'bad';\n      if (packetLossRate <= this.qualityThresholds.excellent.packetLoss && \n          jitter <= this.qualityThresholds.excellent.jitter) {\n        quality = 'excellent';\n      } else if (packetLossRate <= this.qualityThresholds.good.packetLoss && \n                jitter <= this.qualityThresholds.good.jitter) {\n        quality = 'good';\n      } else if (packetLossRate <= this.qualityThresholds.fair.packetLoss && \n                jitter <= this.qualityThresholds.fair.jitter) {\n        quality = 'fair';\n      } else if (packetLossRate <= this.qualityThresholds.poor.packetLoss && \n                jitter <= this.qualityThresholds.poor.jitter) {\n        quality = 'poor';\n      }\n      \n      // Notify if quality changed\n      if (quality !== this.currentQuality) {\n        this.currentQuality = quality;\n        if (this.onQualityChange) {\n          this.onQualityChange(quality, { packetLossRate, jitter });\n        }\n      }\n      \n    } catch (error) {\n      console.error('Error checking audio quality:', error);\n    }\n  }\n  \n  /**\n   * Get current quality metrics\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getQualityMetrics() {\n    if (!this.peerConnection) {\n      return { quality: 'unknown', metrics: {} };\n    }\n    \n    try {\n      const stats = await this.peerConnection.getStats();\n      let audioInboundStats = null;\n      let audioOutboundStats = null;\n      \n      // Find audio stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\n          audioInboundStats = stat;\n        }\n        if (stat.type === 'outbound-rtp' && stat.kind === 'audio') {\n          audioOutboundStats = stat;\n        }\n      });\n      \n      const metrics = {\n        inbound: audioInboundStats ? {\n          packetsReceived: audioInboundStats.packetsReceived || 0,\n          packetsLost: audioInboundStats.packetsLost || 0,\n          jitter: (audioInboundStats.jitter || 0) * 1000, // ms\n          bytesReceived: audioInboundStats.bytesReceived || 0,\n        } : null,\n        outbound: audioOutboundStats ? {\n          packetsSent: audioOutboundStats.packetsSent || 0,\n          bytesSent: audioOutboundStats.bytesSent || 0,\n        } : null,\n        quality: this.currentQuality,\n      };\n      \n      return metrics;\n    } catch (error) {\n      console.error('Error getting quality metrics:', error);\n      return { quality: 'unknown', metrics: {} };\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.stop();\n    this.peerConnection = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}