{"ast":null,"code":"/**\n * QualityMonitor classes for monitoring WebRTC connection quality\n * Used by WebRTCManager to provide quality metrics and indicators\n */\n\n/**\n * Base QualityMonitor class\n */\nexport class QualityMonitor {\n  constructor(peerConnection, options = {}) {\n    this.peerConnection = peerConnection;\n    this.options = {\n      interval: options.interval || 2000,\n      // ms between checks\n      qualityThresholds: {\n        excellent: {\n          packetLoss: 0.01,\n          rtt: 150\n        },\n        // <1% loss, <150ms RTT\n        good: {\n          packetLoss: 0.03,\n          rtt: 300\n        },\n        // <3% loss, <300ms RTT\n        fair: {\n          packetLoss: 0.08,\n          rtt: 500\n        },\n        // <8% loss, <500ms RTT\n        poor: {\n          packetLoss: 0.15,\n          rtt: 1000\n        } // <15% loss, <1000ms RTT\n        // anything worse is considered \"bad\"\n      },\n      ...options\n    };\n    this.stats = {\n      rtt: null,\n      jitter: null,\n      packetLoss: null,\n      bandwidth: null,\n      timestamp: null,\n      quality: 'unknown'\n    };\n    this.monitorInterval = null;\n    this.onQualityChange = options.onQualityChange || (() => {});\n  }\n\n  /**\n   * Start monitoring the connection quality\n   */\n  start() {\n    if (this.monitorInterval) return;\n    this.monitorInterval = setInterval(() => this._checkQuality(), this.options.interval);\n  }\n\n  /**\n   * Stop monitoring the connection quality\n   */\n  stop() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n  }\n\n  /**\n   * Check the connection quality using RTCPeerConnection stats\n   */\n  async _checkQuality() {\n    if (!this.peerConnection) return;\n    try {\n      var _inboundRtp;\n      const stats = await this.peerConnection.getStats();\n      const now = Date.now();\n      let inboundRtp = null;\n      let remoteOutboundRtp = null;\n      let candidatePair = null;\n\n      // Process the stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && !stat.isRemote && stat.mediaType === 'audio') {\n          inboundRtp = stat;\n        } else if (stat.type === 'remote-outbound-rtp' && stat.mediaType === 'audio') {\n          remoteOutboundRtp = stat;\n        } else if (stat.type === 'candidate-pair' && stat.nominated) {\n          candidatePair = stat;\n        }\n      });\n\n      // Calculate metrics\n      let rtt = null;\n      let jitter = null;\n      let packetLoss = null;\n      let bandwidth = null;\n      if (candidatePair) {\n        rtt = candidatePair.currentRoundTripTime ? candidatePair.currentRoundTripTime * 1000 : null;\n      }\n      if (inboundRtp) {\n        jitter = inboundRtp.jitter ? inboundRtp.jitter * 1000 : null;\n\n        // Calculate packet loss\n        if (inboundRtp.packetsLost !== undefined && inboundRtp.packetsReceived !== undefined) {\n          const totalPackets = inboundRtp.packetsLost + inboundRtp.packetsReceived;\n          packetLoss = totalPackets > 0 ? inboundRtp.packetsLost / totalPackets : 0;\n        }\n\n        // Calculate bandwidth\n        if (this.stats.timestamp && inboundRtp.bytesReceived !== undefined) {\n          const bytesNow = inboundRtp.bytesReceived;\n          const bytesLast = this.stats.bytesReceived || 0;\n          const timeElapsed = (now - this.stats.timestamp) / 1000; // seconds\n\n          if (timeElapsed > 0) {\n            bandwidth = (bytesNow - bytesLast) * 8 / timeElapsed; // bits per second\n          }\n        }\n\n        // Store bytes received for next calculation\n        this.stats.bytesReceived = inboundRtp.bytesReceived;\n      }\n\n      // Determine quality level\n      let quality = 'unknown';\n      if (rtt !== null && packetLoss !== null) {\n        const {\n          qualityThresholds\n        } = this.options;\n        if (packetLoss <= qualityThresholds.excellent.packetLoss && rtt <= qualityThresholds.excellent.rtt) {\n          quality = 'excellent';\n        } else if (packetLoss <= qualityThresholds.good.packetLoss && rtt <= qualityThresholds.good.rtt) {\n          quality = 'good';\n        } else if (packetLoss <= qualityThresholds.fair.packetLoss && rtt <= qualityThresholds.fair.rtt) {\n          quality = 'fair';\n        } else if (packetLoss <= qualityThresholds.poor.packetLoss && rtt <= qualityThresholds.poor.rtt) {\n          quality = 'poor';\n        } else {\n          quality = 'bad';\n        }\n      }\n\n      // Update stats\n      const prevQuality = this.stats.quality;\n      this.stats = {\n        rtt,\n        jitter,\n        packetLoss,\n        bandwidth,\n        bytesReceived: (_inboundRtp = inboundRtp) === null || _inboundRtp === void 0 ? void 0 : _inboundRtp.bytesReceived,\n        timestamp: now,\n        quality\n      };\n\n      // Notify if quality changed\n      if (quality !== prevQuality) {\n        this.onQualityChange(quality, this.stats);\n      }\n    } catch (error) {\n      console.error('Error getting connection stats:', error);\n    }\n  }\n\n  /**\n   * Get the current connection quality stats\n   * @returns {Object} The current quality stats\n   */\n  getStats() {\n    return {\n      ...this.stats\n    };\n  }\n\n  /**\n   * Get the current connection quality level\n   * @returns {string} The quality level: 'excellent', 'good', 'fair', 'poor', 'bad', or 'unknown'\n   */\n  getQuality() {\n    return this.stats.quality;\n  }\n}\n\n/**\n * Audio-specific quality monitor with additional audio metrics\n */\nexport class AudioQualityMonitor extends QualityMonitor {\n  constructor(peerConnection, options = {}) {\n    super(peerConnection, options);\n\n    // Additional audio-specific metrics\n    this.stats = {\n      ...this.stats,\n      audioLevel: null,\n      audioEnergy: null\n    };\n  }\n\n  /**\n   * Check audio quality with additional audio-specific metrics\n   */\n  async _checkQuality() {\n    await super._checkQuality();\n    if (!this.peerConnection) return;\n    try {\n      const stats = await this.peerConnection.getStats();\n      stats.forEach(stat => {\n        // Get audio level metrics\n        if (stat.type === 'inbound-rtp' && !stat.isRemote && stat.mediaType === 'audio') {\n          if (stat.audioLevel !== undefined) {\n            this.stats.audioLevel = stat.audioLevel;\n          }\n          if (stat.totalAudioEnergy !== undefined) {\n            this.stats.audioEnergy = stat.totalAudioEnergy;\n          }\n        }\n      });\n    } catch (error) {\n      console.error('Error getting audio stats:', error);\n    }\n  }\n\n  /**\n   * Get the current audio level (0-1)\n   * @returns {number|null} Audio level or null if not available\n   */\n  getAudioLevel() {\n    return this.stats.audioLevel;\n  }\n}\n\n// Export both classes as defaults for backward compatibility\nexport default {\n  QualityMonitor,\n  AudioQualityMonitor\n};","map":{"version":3,"names":["QualityMonitor","constructor","peerConnection","options","interval","qualityThresholds","excellent","packetLoss","rtt","good","fair","poor","stats","jitter","bandwidth","timestamp","quality","monitorInterval","onQualityChange","start","setInterval","_checkQuality","stop","clearInterval","_inboundRtp","getStats","now","Date","inboundRtp","remoteOutboundRtp","candidatePair","forEach","stat","type","isRemote","mediaType","nominated","currentRoundTripTime","packetsLost","undefined","packetsReceived","totalPackets","bytesReceived","bytesNow","bytesLast","timeElapsed","prevQuality","error","console","getQuality","AudioQualityMonitor","audioLevel","audioEnergy","totalAudioEnergy","getAudioLevel"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/qualityMonitor.js"],"sourcesContent":["/**\n * QualityMonitor classes for monitoring WebRTC connection quality\n * Used by WebRTCManager to provide quality metrics and indicators\n */\n\n/**\n * Base QualityMonitor class\n */\nexport class QualityMonitor {\n  constructor(peerConnection, options = {}) {\n    this.peerConnection = peerConnection;\n    this.options = {\n      interval: options.interval || 2000, // ms between checks\n      qualityThresholds: {\n        excellent: { packetLoss: 0.01, rtt: 150 },  // <1% loss, <150ms RTT\n        good: { packetLoss: 0.03, rtt: 300 },       // <3% loss, <300ms RTT\n        fair: { packetLoss: 0.08, rtt: 500 },       // <8% loss, <500ms RTT\n        poor: { packetLoss: 0.15, rtt: 1000 },      // <15% loss, <1000ms RTT\n        // anything worse is considered \"bad\"\n      },\n      ...options\n    };\n    \n    this.stats = {\n      rtt: null,\n      jitter: null,\n      packetLoss: null,\n      bandwidth: null,\n      timestamp: null,\n      quality: 'unknown'\n    };\n    \n    this.monitorInterval = null;\n    this.onQualityChange = options.onQualityChange || (() => {});\n  }\n\n  /**\n   * Start monitoring the connection quality\n   */\n  start() {\n    if (this.monitorInterval) return;\n    \n    this.monitorInterval = setInterval(() => this._checkQuality(), this.options.interval);\n  }\n\n  /**\n   * Stop monitoring the connection quality\n   */\n  stop() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n  }\n\n  /**\n   * Check the connection quality using RTCPeerConnection stats\n   */\n  async _checkQuality() {\n    if (!this.peerConnection) return;\n    \n    try {\n      const stats = await this.peerConnection.getStats();\n      const now = Date.now();\n      \n      let inboundRtp = null;\n      let remoteOutboundRtp = null;\n      let candidatePair = null;\n      \n      // Process the stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && !stat.isRemote && stat.mediaType === 'audio') {\n          inboundRtp = stat;\n        } else if (stat.type === 'remote-outbound-rtp' && stat.mediaType === 'audio') {\n          remoteOutboundRtp = stat;\n        } else if (stat.type === 'candidate-pair' && stat.nominated) {\n          candidatePair = stat;\n        }\n      });\n      \n      // Calculate metrics\n      let rtt = null;\n      let jitter = null;\n      let packetLoss = null;\n      let bandwidth = null;\n      \n      if (candidatePair) {\n        rtt = candidatePair.currentRoundTripTime ? candidatePair.currentRoundTripTime * 1000 : null;\n      }\n      \n      if (inboundRtp) {\n        jitter = inboundRtp.jitter ? inboundRtp.jitter * 1000 : null;\n        \n        // Calculate packet loss\n        if (inboundRtp.packetsLost !== undefined && inboundRtp.packetsReceived !== undefined) {\n          const totalPackets = inboundRtp.packetsLost + inboundRtp.packetsReceived;\n          packetLoss = totalPackets > 0 ? inboundRtp.packetsLost / totalPackets : 0;\n        }\n        \n        // Calculate bandwidth\n        if (this.stats.timestamp && inboundRtp.bytesReceived !== undefined) {\n          const bytesNow = inboundRtp.bytesReceived;\n          const bytesLast = this.stats.bytesReceived || 0;\n          const timeElapsed = (now - this.stats.timestamp) / 1000; // seconds\n          \n          if (timeElapsed > 0) {\n            bandwidth = (bytesNow - bytesLast) * 8 / timeElapsed; // bits per second\n          }\n        }\n        \n        // Store bytes received for next calculation\n        this.stats.bytesReceived = inboundRtp.bytesReceived;\n      }\n      \n      // Determine quality level\n      let quality = 'unknown';\n      if (rtt !== null && packetLoss !== null) {\n        const { qualityThresholds } = this.options;\n        \n        if (packetLoss <= qualityThresholds.excellent.packetLoss && \n            rtt <= qualityThresholds.excellent.rtt) {\n          quality = 'excellent';\n        } else if (packetLoss <= qualityThresholds.good.packetLoss && \n                  rtt <= qualityThresholds.good.rtt) {\n          quality = 'good';\n        } else if (packetLoss <= qualityThresholds.fair.packetLoss && \n                  rtt <= qualityThresholds.fair.rtt) {\n          quality = 'fair';\n        } else if (packetLoss <= qualityThresholds.poor.packetLoss && \n                  rtt <= qualityThresholds.poor.rtt) {\n          quality = 'poor';\n        } else {\n          quality = 'bad';\n        }\n      }\n      \n      // Update stats\n      const prevQuality = this.stats.quality;\n      this.stats = {\n        rtt,\n        jitter,\n        packetLoss,\n        bandwidth,\n        bytesReceived: inboundRtp?.bytesReceived,\n        timestamp: now,\n        quality\n      };\n      \n      // Notify if quality changed\n      if (quality !== prevQuality) {\n        this.onQualityChange(quality, this.stats);\n      }\n      \n    } catch (error) {\n      console.error('Error getting connection stats:', error);\n    }\n  }\n\n  /**\n   * Get the current connection quality stats\n   * @returns {Object} The current quality stats\n   */\n  getStats() {\n    return { ...this.stats };\n  }\n\n  /**\n   * Get the current connection quality level\n   * @returns {string} The quality level: 'excellent', 'good', 'fair', 'poor', 'bad', or 'unknown'\n   */\n  getQuality() {\n    return this.stats.quality;\n  }\n}\n\n/**\n * Audio-specific quality monitor with additional audio metrics\n */\nexport class AudioQualityMonitor extends QualityMonitor {\n  constructor(peerConnection, options = {}) {\n    super(peerConnection, options);\n    \n    // Additional audio-specific metrics\n    this.stats = {\n      ...this.stats,\n      audioLevel: null,\n      audioEnergy: null\n    };\n  }\n  \n  /**\n   * Check audio quality with additional audio-specific metrics\n   */\n  async _checkQuality() {\n    await super._checkQuality();\n    \n    if (!this.peerConnection) return;\n    \n    try {\n      const stats = await this.peerConnection.getStats();\n      \n      stats.forEach(stat => {\n        // Get audio level metrics\n        if (stat.type === 'inbound-rtp' && !stat.isRemote && stat.mediaType === 'audio') {\n          if (stat.audioLevel !== undefined) {\n            this.stats.audioLevel = stat.audioLevel;\n          }\n          \n          if (stat.totalAudioEnergy !== undefined) {\n            this.stats.audioEnergy = stat.totalAudioEnergy;\n          }\n        }\n      });\n      \n    } catch (error) {\n      console.error('Error getting audio stats:', error);\n    }\n  }\n  \n  /**\n   * Get the current audio level (0-1)\n   * @returns {number|null} Audio level or null if not available\n   */\n  getAudioLevel() {\n    return this.stats.audioLevel;\n  }\n}\n\n// Export both classes as defaults for backward compatibility\nexport default {\n  QualityMonitor,\n  AudioQualityMonitor\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}