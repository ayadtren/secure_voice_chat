{"ast":null,"code":"/**\n * WebRTC utility functions for secure voice chat\n * \n * These functions handle the setup and management of WebRTC peer connections\n * with security and privacy as the primary concerns.\n */\n\n// ICE servers configuration - using only STUN servers for NAT traversal\n// No TURN servers to ensure direct peer-to-peer communication\nconst ICE_SERVERS = {\n  iceServers: [{\n    urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302']\n  }],\n  iceCandidatePoolSize: 10\n};\n\n/**\n * Setup a WebRTC peer connection with the appropriate security settings\n * @param {Object} options Configuration options\n * @param {Function} options.onIceCandidate Callback for ICE candidate events\n * @param {Function} options.onTrack Callback for track events\n * @param {Function} options.onConnectionStateChange Callback for connection state changes\n * @returns {RTCPeerConnection} The configured peer connection\n */\nexport async function setupPeerConnection({\n  onIceCandidate,\n  onTrack,\n  onConnectionStateChange\n}) {\n  // Create peer connection with security-focused configuration\n  const peerConnection = new RTCPeerConnection({\n    ...ICE_SERVERS,\n    // Security settings\n    sdpSemantics: 'unified-plan',\n    // Enable DTLS-SRTP for end-to-end encryption\n    // This is actually the default in modern browsers\n    // but we explicitly set it for clarity and to ensure it's used\n    iceTransportPolicy: 'all'\n  });\n\n  // Set up event handlers\n  peerConnection.addEventListener('icecandidate', event => {\n    if (event.candidate) {\n      onIceCandidate(event.candidate);\n    }\n  });\n  peerConnection.addEventListener('track', event => {\n    onTrack(event);\n  });\n  peerConnection.addEventListener('connectionstatechange', () => {\n    onConnectionStateChange(peerConnection.connectionState);\n  });\n\n  // Log connection state changes for debugging\n  peerConnection.addEventListener('signalingstatechange', () => {\n    console.log('Signaling state:', peerConnection.signalingState);\n  });\n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n  return peerConnection;\n}\n\n/**\n * Clean up and close a peer connection\n * @param {RTCPeerConnection} peerConnection The peer connection to clean up\n */\nexport function cleanupPeerConnection(peerConnection) {\n  if (!peerConnection) return;\n  try {\n    // Close all transceivers\n    peerConnection.getTransceivers().forEach(transceiver => {\n      if (transceiver.stop) {\n        transceiver.stop();\n      }\n    });\n\n    // Close the connection\n    peerConnection.close();\n\n    // Remove all event listeners (for garbage collection)\n    peerConnection.onicecandidate = null;\n    peerConnection.ontrack = null;\n    peerConnection.onconnectionstatechange = null;\n    peerConnection.onsignalingstatechange = null;\n    peerConnection.onicegatheringstatechange = null;\n    peerConnection.oniceconnectionstatechange = null;\n    console.log('Peer connection cleaned up');\n  } catch (error) {\n    console.error('Error cleaning up peer connection:', error);\n  }\n}\n\n/**\n * Create an audio analyzer to visualize audio levels\n * @param {MediaStream} stream The audio stream to analyze\n * @returns {Object} The analyzer node and methods to get audio levels\n */\nexport function createAudioAnalyzer(stream) {\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const analyzer = audioContext.createAnalyser();\n  analyzer.fftSize = 256;\n  analyzer.smoothingTimeConstant = 0.8;\n  const audioSource = audioContext.createMediaStreamSource(stream);\n  audioSource.connect(analyzer);\n\n  // We don't connect the analyzer to the destination to avoid feedback\n  // analyzer.connect(audioContext.destination);\n\n  const dataArray = new Uint8Array(analyzer.frequencyBinCount);\n\n  // Function to get current audio level (0-100)\n  const getAudioLevel = () => {\n    analyzer.getByteFrequencyData(dataArray);\n\n    // Calculate average volume level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    const average = sum / dataArray.length;\n\n    // Convert to a percentage (0-100)\n    return Math.min(100, Math.round(average / 255 * 100));\n  };\n\n  // Function to clean up resources\n  const cleanup = () => {\n    try {\n      audioSource.disconnect();\n      analyzer.disconnect();\n      audioContext.close();\n    } catch (error) {\n      console.error('Error cleaning up audio analyzer:', error);\n    }\n  };\n  return {\n    analyzer,\n    getAudioLevel,\n    cleanup\n  };\n}","map":{"version":3,"names":["ICE_SERVERS","iceServers","urls","iceCandidatePoolSize","setupPeerConnection","onIceCandidate","onTrack","onConnectionStateChange","peerConnection","RTCPeerConnection","sdpSemantics","iceTransportPolicy","addEventListener","event","candidate","connectionState","console","log","signalingState","iceGatheringState","iceConnectionState","cleanupPeerConnection","getTransceivers","forEach","transceiver","stop","close","onicecandidate","ontrack","onconnectionstatechange","onsignalingstatechange","onicegatheringstatechange","oniceconnectionstatechange","error","createAudioAnalyzer","stream","audioContext","window","AudioContext","webkitAudioContext","analyzer","createAnalyser","fftSize","smoothingTimeConstant","audioSource","createMediaStreamSource","connect","dataArray","Uint8Array","frequencyBinCount","getAudioLevel","getByteFrequencyData","sum","i","length","average","Math","min","round","cleanup","disconnect"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtc.js"],"sourcesContent":["/**\n * WebRTC utility functions for secure voice chat\n * \n * These functions handle the setup and management of WebRTC peer connections\n * with security and privacy as the primary concerns.\n */\n\n// ICE servers configuration - using only STUN servers for NAT traversal\n// No TURN servers to ensure direct peer-to-peer communication\nconst ICE_SERVERS = {\n  iceServers: [\n    {\n      urls: [\n        'stun:stun.l.google.com:19302',\n        'stun:stun1.l.google.com:19302',\n        'stun:stun2.l.google.com:19302',\n      ],\n    },\n  ],\n  iceCandidatePoolSize: 10,\n};\n\n/**\n * Setup a WebRTC peer connection with the appropriate security settings\n * @param {Object} options Configuration options\n * @param {Function} options.onIceCandidate Callback for ICE candidate events\n * @param {Function} options.onTrack Callback for track events\n * @param {Function} options.onConnectionStateChange Callback for connection state changes\n * @returns {RTCPeerConnection} The configured peer connection\n */\nexport async function setupPeerConnection({ \n  onIceCandidate, \n  onTrack, \n  onConnectionStateChange \n}) {\n  // Create peer connection with security-focused configuration\n  const peerConnection = new RTCPeerConnection({\n    ...ICE_SERVERS,\n    // Security settings\n    sdpSemantics: 'unified-plan',\n    // Enable DTLS-SRTP for end-to-end encryption\n    // This is actually the default in modern browsers\n    // but we explicitly set it for clarity and to ensure it's used\n    iceTransportPolicy: 'all',\n  });\n  \n  // Set up event handlers\n  peerConnection.addEventListener('icecandidate', (event) => {\n    if (event.candidate) {\n      onIceCandidate(event.candidate);\n    }\n  });\n  \n  peerConnection.addEventListener('track', (event) => {\n    onTrack(event);\n  });\n  \n  peerConnection.addEventListener('connectionstatechange', () => {\n    onConnectionStateChange(peerConnection.connectionState);\n  });\n  \n  // Log connection state changes for debugging\n  peerConnection.addEventListener('signalingstatechange', () => {\n    console.log('Signaling state:', peerConnection.signalingState);\n  });\n  \n  peerConnection.addEventListener('icegatheringstatechange', () => {\n    console.log('ICE gathering state:', peerConnection.iceGatheringState);\n  });\n  \n  peerConnection.addEventListener('iceconnectionstatechange', () => {\n    console.log('ICE connection state:', peerConnection.iceConnectionState);\n  });\n  \n  return peerConnection;\n}\n\n/**\n * Clean up and close a peer connection\n * @param {RTCPeerConnection} peerConnection The peer connection to clean up\n */\nexport function cleanupPeerConnection(peerConnection) {\n  if (!peerConnection) return;\n  \n  try {\n    // Close all transceivers\n    peerConnection.getTransceivers().forEach(transceiver => {\n      if (transceiver.stop) {\n        transceiver.stop();\n      }\n    });\n    \n    // Close the connection\n    peerConnection.close();\n    \n    // Remove all event listeners (for garbage collection)\n    peerConnection.onicecandidate = null;\n    peerConnection.ontrack = null;\n    peerConnection.onconnectionstatechange = null;\n    peerConnection.onsignalingstatechange = null;\n    peerConnection.onicegatheringstatechange = null;\n    peerConnection.oniceconnectionstatechange = null;\n    \n    console.log('Peer connection cleaned up');\n  } catch (error) {\n    console.error('Error cleaning up peer connection:', error);\n  }\n}\n\n/**\n * Create an audio analyzer to visualize audio levels\n * @param {MediaStream} stream The audio stream to analyze\n * @returns {Object} The analyzer node and methods to get audio levels\n */\nexport function createAudioAnalyzer(stream) {\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const analyzer = audioContext.createAnalyser();\n  \n  analyzer.fftSize = 256;\n  analyzer.smoothingTimeConstant = 0.8;\n  \n  const audioSource = audioContext.createMediaStreamSource(stream);\n  audioSource.connect(analyzer);\n  \n  // We don't connect the analyzer to the destination to avoid feedback\n  // analyzer.connect(audioContext.destination);\n  \n  const dataArray = new Uint8Array(analyzer.frequencyBinCount);\n  \n  // Function to get current audio level (0-100)\n  const getAudioLevel = () => {\n    analyzer.getByteFrequencyData(dataArray);\n    \n    // Calculate average volume level\n    let sum = 0;\n    for (let i = 0; i < dataArray.length; i++) {\n      sum += dataArray[i];\n    }\n    \n    const average = sum / dataArray.length;\n    \n    // Convert to a percentage (0-100)\n    return Math.min(100, Math.round((average / 255) * 100));\n  };\n  \n  // Function to clean up resources\n  const cleanup = () => {\n    try {\n      audioSource.disconnect();\n      analyzer.disconnect();\n      audioContext.close();\n    } catch (error) {\n      console.error('Error cleaning up audio analyzer:', error);\n    }\n  };\n  \n  return {\n    analyzer,\n    getAudioLevel,\n    cleanup\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}