{"ast":null,"code":"// eslint-disable-next-line no-unused-vars\nimport { createEnhancedAudioStream } from './audioProcessor';\nimport { SpeakingDetector } from './speakingDetector';\nimport { AudioQualityMonitor } from './qualityMonitor';\nimport { createMicrophoneStatus } from './browserDetection';\nimport { WebRTCQualityMonitor } from './webrtcQualityMonitor';\n\n/**\n * WebRTC Manager for handling peer connections\n */\nexport class WebRTCManager {\n  /**\n   * Create a new WebRTC manager\n   * @param {Socket} socket - Socket.IO socket\n   * @param {Object} options - Configuration options\n   */\n  constructor(socket, options = {}) {\n    // Store socket\n    this.socket = socket;\n    this.userId = options.userId;\n\n    // Configuration\n    this.config = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10\n    };\n\n    // Enhanced audio settings\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      sampleRate: 48000,\n      channelCount: 1\n    };\n\n    // Video settings\n    this.videoConstraints = {\n      width: {\n        ideal: 1280,\n        max: 1920\n      },\n      height: {\n        ideal: 720,\n        max: 1080\n      },\n      frameRate: {\n        ideal: 30,\n        max: 60\n      }\n    };\n\n    // State\n    this.roomId = null;\n    this.localStream = null;\n    this.localVideoStream = null;\n    this.peerConnections = new Map();\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false; // Track if permission has been denied\n    this.cameraInitialized = false;\n    this.cameraPermissionRequested = false;\n    this.cameraPermissionDenied = false;\n    this.videoEnabled = options.videoEnabled || false;\n\n    // Phase 2: Quality monitoring and adaptive streaming\n    this.currentVideoQuality = 'high'; // Default quality\n    this.qualityMonitor = new WebRTCQualityMonitor({\n      initialQuality: this.currentVideoQuality,\n      adaptiveQuality: true,\n      onQualityChange: this._handleQualityChange.bind(this),\n      onNetworkQualityChange: options.onNetworkQualityChange || null\n    });\n\n    // Callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n    this.onMicrophoneStatus = options.onMicrophoneStatus || null;\n    this.onCameraStatus = options.onCameraStatus || null;\n    this.onLocalVideo = options.onLocalVideo || null;\n    this.onRemoteVideo = options.onRemoteVideo || null;\n    this.onVideoStatusChange = options.onVideoStatusChange || null;\n    this.onNetworkQualityChange = options.onNetworkQualityChange || null; // Phase 2: Network quality callback\n\n    // Bind methods\n    this._handleUserMediaError = this._handleUserMediaError.bind(this);\n    this._notifyError = this._notifyError.bind(this);\n    this._handleQualityChange = this._handleQualityChange.bind(this);\n  }\n\n  /**\n   * Handle quality change from quality monitor\n   * @param {Object} qualitySettings - New quality settings\n   * @private\n   */\n  _handleQualityChange(qualitySettings) {\n    if (!qualitySettings) return;\n\n    // Update video constraints\n    this.videoConstraints = {\n      ...this.videoConstraints,\n      width: {\n        ideal: qualitySettings.width,\n        max: qualitySettings.width * 1.5\n      },\n      height: {\n        ideal: qualitySettings.height,\n        max: qualitySettings.height * 1.5\n      },\n      frameRate: {\n        ideal: qualitySettings.frameRate,\n        max: qualitySettings.frameRate * 1.5\n      }\n    };\n\n    // Apply to active video track if exists\n    this._applyVideoConstraints();\n\n    // Apply bitrate constraints to all peer connections\n    this.peerConnections.forEach(pc => {\n      this._applyBitrateConstraint(pc, qualitySettings.bitrate);\n    });\n  }\n\n  /**\n   * Apply current video constraints to active video track\n   * @private\n   */\n  _applyVideoConstraints() {\n    if (this.localVideoStream) {\n      const videoTrack = this.localVideoStream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.applyConstraints(this.videoConstraints).catch(error => {\n          console.warn('Failed to apply video constraints:', error);\n        });\n      }\n    }\n  }\n\n  /**\n   * Apply bitrate constraint to peer connection\n   * @param {RTCPeerConnection} pc - Peer connection\n   * @param {number} bitrate - Target bitrate in bps\n   * @private\n   */\n  _applyBitrateConstraint(pc, bitrate) {\n    try {\n      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');\n      if (sender) {\n        const parameters = sender.getParameters();\n        if (!parameters.encodings) {\n          parameters.encodings = [{}];\n        }\n\n        // Set max bitrate\n        parameters.encodings[0].maxBitrate = bitrate;\n\n        // Apply the changes\n        sender.setParameters(parameters).catch(error => {\n          console.warn('Failed to set sender parameters:', error);\n        });\n      }\n    } catch (error) {\n      console.warn('Failed to apply bitrate constraint:', error);\n    }\n  }\n\n  /**\n   * Notify about errors in a consistent way\n   * @param {string|Error} error - Error message or object\n   * @param {string} defaultMessage - Default message if error is empty\n   * @private\n   */\n  _notifyError(error, defaultMessage = 'An unknown error occurred') {\n    let errorMessage = defaultMessage;\n    if (error) {\n      if (typeof error === 'string') {\n        errorMessage = error;\n      } else if (error instanceof Error) {\n        errorMessage = error.message || error.toString();\n      } else if (error.name || error.message) {\n        errorMessage = error.message || error.name;\n      }\n    }\n    console.error(defaultMessage, error || {});\n    if (this.onError) {\n      this.onError(errorMessage);\n    }\n    return errorMessage;\n  }\n\n  /**\n   * Handle user media errors\n   * @param {Error} error - The error that occurred\n   * @private\n   */\n  _handleUserMediaError(error) {\n    let errorMessage = 'Failed to access microphone. Please check your permissions.';\n\n    // Check if error exists and has properties\n    if (error) {\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Microphone access denied. Please allow microphone access in your browser settings.';\n\n        // Show instructions for enabling microphone\n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        }\n        this.permissionDenied = true; // Mark permission as denied to prevent repeated attempts\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No microphone found. Please connect a microphone and try again.';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Could not start microphone. It may be in use by another application.';\n      } else if (error.name === 'OverconstrainedError') {\n        errorMessage = 'Microphone constraints cannot be satisfied. Please try with different settings.';\n      } else if (error.name === 'TypeError') {\n        errorMessage = 'Invalid audio constraints. Please check your browser compatibility.';\n      } else if (error.name === 'AbortError') {\n        errorMessage = 'Microphone access request was aborted. Please try again.';\n      } else if (error.name === 'SecurityError') {\n        errorMessage = 'Microphone access blocked due to security policy. Try using HTTPS.';\n      }\n    }\n    this._notifyError(error, errorMessage);\n    return errorMessage;\n  }\n\n  /**\n   * Handle camera media errors\n   * @param {Error} error - The error that occurred\n   * @private\n   */\n  _handleCameraMediaError(error) {\n    let errorMessage = 'Failed to access camera. Please check your permissions.';\n\n    // Check if error exists and has properties\n    if (error) {\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Camera access denied. Please allow camera access in your browser settings.';\n\n        // Show instructions for enabling camera\n        if (this.onCameraStatus) {\n          this.onCameraStatus(createCameraStatus('denied', error.message));\n        }\n        this.cameraPermissionDenied = true; // Mark permission as denied to prevent repeated attempts\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No camera found. Please connect a camera and try again.';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Could not start camera. It may be in use by another application.';\n      } else if (error.name === 'OverconstrainedError') {\n        errorMessage = 'Camera constraints cannot be satisfied. Please try with different settings.';\n      } else if (error.name === 'TypeError') {\n        errorMessage = 'Invalid video constraints. Please check your browser compatibility.';\n      } else if (error.name === 'AbortError') {\n        errorMessage = 'Camera access request was aborted. Please try again.';\n      } else if (error.name === 'SecurityError') {\n        errorMessage = 'Camera access blocked due to security policy. Try using HTTPS.';\n      }\n    }\n    this._notifyError(error, errorMessage);\n    return errorMessage;\n  }\n\n  /**\n   * Initialize WebRTC with local audio stream\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize(roomId) {\n    try {\n      // If permission was previously denied, don't try again automatically\n      if (this.permissionDenied) {\n        this.onMicrophoneStatus(createMicrophoneStatus('denied'));\n        return false;\n      }\n\n      // Store room ID\n      this.roomId = roomId;\n      this.microphonePermissionRequested = true;\n      if (this.onMicrophoneStatus) {\n        this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n      }\n\n      // Try with simpler constraints first\n      const constraints = {\n        audio: true,\n        video: false\n      };\n      try {\n        // Get user media with basic audio settings first\n        this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n        this.microphoneInitialized = true;\n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n        }\n\n        // If basic constraints work, try to apply enhanced settings\n        try {\n          const enhancedStream = await navigator.mediaDevices.getUserMedia({\n            audio: this.audioConstraints,\n            video: false\n          });\n\n          // Replace the basic stream with enhanced stream\n          this.localStream.getTracks().forEach(track => track.stop());\n          this.localStream = enhancedStream;\n        } catch (enhancedError) {\n          console.warn('Could not apply enhanced audio settings, using basic audio:', enhancedError);\n          // Continue with basic audio, no need to throw\n        }\n      } catch (basicError) {\n        // If basic constraints fail, throw the error to be caught by outer try/catch\n        throw basicError;\n      }\n\n      // Create speaking detector\n      if (this.localStream) {\n        this.speakingDetector = new SpeakingDetector(this.localStream, {\n          onSpeakingChange: speaking => {\n            if (this.onSpeakingChange) {\n              this.onSpeakingChange(speaking);\n            }\n\n            // Emit speaking status to other users\n            if (this.socket && this.socket.connected) {\n              this.socket.emit('speaking', {\n                roomId: this.roomId,\n                speaking\n              });\n            }\n          }\n        });\n        this.speakingDetector.start();\n      } else {\n        throw new Error('Failed to initialize local stream');\n      }\n      console.log('WebRTC initialized successfully with roomId:', roomId);\n      return true;\n    } catch (error) {\n      this.microphoneInitialized = false;\n      const errorMessage = this._handleUserMediaError(error);\n      throw new Error(errorMessage);\n    }\n  }\n\n  /**\n   * Initialize WebRTC with video\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initializeWithVideo(roomId) {\n    try {\n      // First initialize audio\n      const audioInitialized = await this.initialize(roomId);\n      if (!audioInitialized) {\n        return false;\n      }\n\n      // If camera permission was previously denied, don't try again automatically\n      if (this.cameraPermissionDenied) {\n        if (this.onCameraStatus) {\n          this.onCameraStatus(createCameraStatus('denied'));\n        }\n        return false;\n      }\n      this.cameraPermissionRequested = true;\n      if (this.onCameraStatus) {\n        this.onCameraStatus(createCameraStatus('requesting'));\n      }\n      try {\n        // Get video stream\n        const videoStream = await navigator.mediaDevices.getUserMedia({\n          video: this.videoConstraints\n        });\n        this.cameraInitialized = true;\n        this.videoEnabled = true;\n        if (this.onCameraStatus) {\n          this.onCameraStatus(createCameraStatus('granted'));\n        }\n\n        // Store video stream\n        this.localVideoStream = videoStream;\n\n        // Notify about local video\n        if (this.onLocalVideo) {\n          this.onLocalVideo(videoStream);\n        }\n\n        // Notify about video status change\n        if (this.onVideoStatusChange) {\n          this.onVideoStatusChange(true);\n        }\n\n        // If we already have peer connections, add video tracks to them\n        if (this.peerConnections.size > 0) {\n          for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n            // Add video tracks to the peer connection\n            videoStream.getVideoTracks().forEach(track => {\n              peerConnection.addTrack(track, videoStream);\n            });\n\n            // Renegotiate the connection\n            await this._createAndSendOffer(peerId);\n          }\n        }\n        return true;\n      } catch (error) {\n        this.cameraInitialized = false;\n        this.videoEnabled = false;\n        const errorMessage = this._handleCameraMediaError(error);\n        console.error(errorMessage);\n        return false;\n      }\n    } catch (error) {\n      console.error('Error initializing with video:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Retry microphone access\n   * @returns {Promise<boolean>} Success status\n   */\n  async retryMicrophoneAccess() {\n    try {\n      // Reset permission denied flag to allow retry\n      this.permissionDenied = false;\n\n      // Notify about microphone status\n      this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n\n      // Get user media with audio\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false\n      });\n\n      // Microphone access granted\n      this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n\n      // Initialize speaking detector\n      if (this.speakingDetector) {\n        this.speakingDetector.stop();\n      }\n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        onSpeakingChange: speaking => {\n          this.onSpeakingChange(speaking);\n\n          // Emit speaking status to other users\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              speaking\n            });\n          }\n        }\n      });\n      this.speakingDetector.start();\n\n      // Rejoin room if needed\n      if (this.roomId && this.socket && this.socket.connected) {\n        this.socket.emit('join', {\n          roomId: this.roomId\n        });\n      }\n      return true;\n    } catch (error) {\n      // Handle specific getUserMedia errors\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        this.permissionDenied = true; // Mark permission as denied\n        this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        this.onError('Microphone access denied. Please allow microphone access in your browser settings.');\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('No microphone found. Please connect a microphone and try again.');\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('Could not access microphone. It may be in use by another application.');\n      } else {\n        this.onMicrophoneStatus(createMicrophoneStatus('error', error.message));\n        this.onError(`Microphone error: ${error.message || 'Unknown error'}`);\n      }\n      console.error('Error accessing microphone:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      console.log(`Creating peer connection for ${peerId}, isInitiator: ${isInitiator}`);\n\n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n\n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          console.log(`Adding track to peer connection: ${track.kind}`);\n          peerConnection.addTrack(track, this.localStream);\n        });\n      } else {\n        console.error('No local stream available when creating peer connection');\n        if (this.onError) {\n          this.onError('Microphone not initialized. Please refresh and try again.');\n        }\n      }\n\n      // Add video tracks if available\n      if (this.videoEnabled && this.localVideoStream) {\n        this.localVideoStream.getVideoTracks().forEach(track => {\n          console.log(`Adding video track to peer connection: ${track.kind}`);\n          peerConnection.addTrack(track, this.localVideoStream);\n        });\n      }\n\n      // Handle ICE candidates\n      peerConnection.onicecandidate = event => {\n        if (event.candidate) {\n          console.log('Sending ICE candidate to peer:', peerId);\n          this.socket.emit('iceCandidate', {\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate\n          });\n        }\n      };\n\n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        console.log(`Connection state changed to: ${peerConnection.connectionState} for peer ${peerId}`);\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n\n            // Start monitoring network quality for this peer connection (Phase 2)\n            if (this.qualityMonitor) {\n              this.qualityMonitor.startMonitoring(peerConnection, peerId);\n            }\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            this._cleanupPeerConnection(peerId);\n            break;\n          default:\n            break;\n        }\n      };\n\n      // Handle incoming tracks\n      peerConnection.ontrack = event => {\n        console.log(`Received track from peer ${peerId}: ${event.track.kind}`);\n        const stream = event.streams[0];\n\n        // Store remote stream and create audio element\n        if (stream) {\n          console.log(`Received stream from peer ${peerId}`);\n\n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n\n          // Check if this is a video track\n          if (event.track.kind === 'video' && this.onRemoteVideo) {\n            this.onRemoteVideo(peerId, stream);\n          }\n\n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n\n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n\n      // If initiator, create and send offer\n      if (isInitiator) {\n        console.log(`Initiating offer creation for peer ${peerId}`);\n        this._createAndSendOffer(peerId);\n      }\n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   * @returns {Promise<void>}\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      console.log(`Creating offer for peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.error(`No peer connection found for ${peerId}`);\n        return;\n      }\n\n      // Create offer with audio and video preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: this.videoEnabled\n      });\n\n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      console.log(`Local description set for peer ${peerId}`);\n\n      // Send offer to peer\n      this.socket.emit('offer', {\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription\n      });\n      console.log(`Offer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      console.log(`Handling offer from peer ${peerId}`);\n\n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.log(`Creating new peer connection for ${peerId} to handle offer`);\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      if (!peerConnection) {\n        console.error(`Failed to create peer connection for ${peerId}`);\n        return;\n      }\n\n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      console.log(`Remote description set for peer ${peerId}`);\n\n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      console.log(`Answer created for peer ${peerId}`);\n\n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      console.log(`Local description set for peer ${peerId}`);\n\n      // Send answer to peer\n      this.socket.emit('answer', {\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription\n      });\n      console.log(`Answer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      console.log(`Handling answer from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n        console.log(`Remote description set for peer ${peerId} from answer`);\n      } else {\n        console.error(`No peer connection found for ${peerId} when handling answer`);\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      console.log(`Handling ICE candidate from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        console.log(`Successfully added ICE candidate for peer ${peerId}`);\n      } else {\n        console.warn(`Received ICE candidate for non-existent peer connection: ${peerId}`);\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n\n  /**\n   * Clean up a peer connection\n   * @param {string} peerId - ID of the peer\n   */\n  _cleanupPeerConnection(peerId) {\n    try {\n      console.log(`Cleaning up peer connection for ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        peerConnection.onicecandidate = null;\n        peerConnection.ontrack = null;\n        peerConnection.onconnectionstatechange = null;\n        peerConnection.close();\n        this.peerConnections.delete(peerId);\n      }\n\n      // Clean up audio quality monitor\n      const qualityMonitor = this.audioQualityMonitors.get(peerId);\n      if (qualityMonitor) {\n        qualityMonitor.stop();\n        this.audioQualityMonitors.delete(peerId);\n      }\n      console.log(`Peer connection for ${peerId} cleaned up`);\n    } catch (error) {\n      console.error(`Error cleaning up peer connection for ${peerId}:`, error);\n    }\n  }\n\n  /**\n   * Accept an incoming call\n   * @param {string} peerId - ID of the peer who initiated the call\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<boolean>} Success status\n   */\n  async acceptIncomingCall(peerId, offer) {\n    try {\n      console.log(`Accepting incoming call from ${peerId}`);\n      await this._handleOffer(peerId, offer);\n      return true;\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      if (this.onError) {\n        this.onError('Failed to accept call. Please try again.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<RTCPeerConnection>} The peer connection\n   */\n  async startCall(peerId) {\n    try {\n      if (!this.microphonePermissionRequested) {\n        await this.initialize(this.roomId || 'default');\n      }\n      if (!this.localStream || !this.microphoneInitialized) {\n        throw new Error('Microphone not initialized. Please refresh and try again.');\n      }\n\n      // Create peer connection\n      const peerConnection = this._createPeerConnection(peerId, true);\n\n      // Add local tracks to the connection\n      this.localStream.getTracks().forEach(track => {\n        peerConnection.addTrack(track, this.localStream);\n      });\n\n      // Create and send offer\n      await this._createAndSendOffer(peerId);\n      return peerConnection;\n    } catch (error) {\n      this._notifyError(error, 'Failed to start call');\n      throw error;\n    }\n  }\n\n  /**\n   * Handle an answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async handleAnswer(peerId, answer) {\n    console.log(`Handling answer from ${peerId} in public method`);\n    return this._handleAnswer(peerId, answer);\n  }\n\n  /**\n   * Add an ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async addIceCandidate(peerId, candidate) {\n    console.log(`Adding ICE candidate from ${peerId} in public method`);\n    return this._handleIceCandidate(peerId, candidate);\n  }\n\n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n\n    // Stop local stream\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n\n    // Stop local video stream\n    if (this.localVideoStream) {\n      this.localVideoStream.getTracks().forEach(track => track.stop());\n      this.localVideoStream = null;\n    }\n\n    // Stop speaking detector\n    if (this.speakingDetector) {\n      try {\n        this.speakingDetector.stop();\n      } catch (error) {\n        console.error('Error stopping speaking detector:', error);\n      }\n    }\n\n    // Reset state\n    this.roomId = null;\n    this.peerConnections.clear();\n    this.audioQualityMonitors.clear();\n    this.speakingDetector = null;\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false;\n    this.cameraInitialized = false;\n    this.cameraPermissionRequested = false;\n    this.cameraPermissionDenied = false;\n    this.videoEnabled = false;\n  }\n\n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    console.log('Disposing WebRTC manager');\n    this.leaveRoom();\n\n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n\n    // Stop quality monitoring (Phase 2)\n    if (this.qualityMonitor) {\n      this.qualityMonitor.stopMonitoring();\n    }\n    console.log('WebRTC manager disposed');\n  }\n\n  /**\n   * Toggle video on/off\n   * @returns {Promise<boolean>} New video status\n   */\n  async toggleVideo() {\n    try {\n      // If video is not initialized, initialize it\n      if (!this.cameraInitialized) {\n        const initialized = await this.initializeWithVideo(this.roomId);\n        return initialized;\n      }\n\n      // If video is initialized, toggle it\n      if (this.localVideoStream) {\n        const videoTracks = this.localVideoStream.getVideoTracks();\n        if (videoTracks.length === 0) return false;\n        const track = videoTracks[0];\n        track.enabled = !track.enabled;\n        this.videoEnabled = track.enabled;\n\n        // Notify about video status change\n        if (this.onVideoStatusChange) {\n          this.onVideoStatusChange(this.videoEnabled);\n        }\n        return this.videoEnabled;\n      }\n      return false;\n    } catch (error) {\n      console.error('Error toggling video:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Switch camera\n   * @param {string} deviceId - ID of the camera to switch to\n   * @returns {Promise<boolean>} Success status\n   */\n  async switchCamera(deviceId) {\n    try {\n      if (!this.cameraInitialized) {\n        return false;\n      }\n\n      // Stop current video tracks\n      if (this.localVideoStream) {\n        this.localVideoStream.getVideoTracks().forEach(track => track.stop());\n      }\n\n      // Get new video stream with specified device\n      const videoConstraints = {\n        ...this.videoConstraints,\n        deviceId: deviceId ? {\n          exact: deviceId\n        } : undefined\n      };\n      const newVideoStream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints\n      });\n\n      // Replace old stream with new stream\n      this.localVideoStream = newVideoStream;\n\n      // Notify about local video\n      if (this.onLocalVideo) {\n        this.onLocalVideo(newVideoStream);\n      }\n\n      // Replace tracks in all peer connections\n      for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n        const senders = peerConnection.getSenders();\n        const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');\n        if (videoSender) {\n          const newTrack = newVideoStream.getVideoTracks()[0];\n          await videoSender.replaceTrack(newTrack);\n        } else {\n          // If no video sender exists, add the track\n          newVideoStream.getVideoTracks().forEach(track => {\n            peerConnection.addTrack(track, newVideoStream);\n          });\n\n          // Renegotiate the connection\n          await this._createAndSendOffer(peerId);\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Error switching camera:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get available video devices\n   * @returns {Promise<MediaDeviceInfo[]>} List of video devices\n   */\n  async getVideoDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'videoinput');\n    } catch (error) {\n      console.error('Error getting video devices:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check if camera is enabled\n   * @returns {boolean} Camera status\n   */\n  isCameraEnabled() {\n    if (!this.localVideoStream) return false;\n    const videoTracks = this.localVideoStream.getVideoTracks();\n    if (videoTracks.length === 0) return false;\n    return videoTracks[0].enabled;\n  }\n\n  /**\n   * Set video quality preset\n   * @param {string} presetId - Quality preset ID ('low', 'medium', 'high', 'hd', 'auto')\n   * @returns {Promise<boolean>} Success status\n   */\n  async setVideoQuality(presetId) {\n    try {\n      const qualitySettings = this.qualityMonitor.setQuality(presetId);\n      this.currentVideoQuality = presetId;\n      return true;\n    } catch (error) {\n      console.error('Error setting video quality:', error);\n      if (this.onError) {\n        this.onError(`Failed to set video quality: ${error.message}`);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Get current video quality preset\n   * @returns {string} Current quality preset ID\n   */\n  getCurrentVideoQuality() {\n    return this.currentVideoQuality;\n  }\n\n  /**\n   * Get all available quality presets\n   * @returns {Object} Quality presets\n   */\n  getQualityPresets() {\n    return this.qualityMonitor.getQualityPresets();\n  }\n}","map":{"version":3,"names":["createEnhancedAudioStream","SpeakingDetector","AudioQualityMonitor","createMicrophoneStatus","WebRTCQualityMonitor","WebRTCManager","constructor","socket","options","userId","config","iceServers","urls","iceCandidatePoolSize","audioConstraints","echoCancellation","noiseSuppression","autoGainControl","sampleRate","channelCount","videoConstraints","width","ideal","max","height","frameRate","roomId","localStream","localVideoStream","peerConnections","Map","speakingDetector","audioQualityMonitors","microphoneInitialized","microphonePermissionRequested","permissionDenied","cameraInitialized","cameraPermissionRequested","cameraPermissionDenied","videoEnabled","currentVideoQuality","qualityMonitor","initialQuality","adaptiveQuality","onQualityChange","_handleQualityChange","bind","onNetworkQualityChange","onPeerConnect","onPeerDisconnect","onSpeakingChange","onAudioQualityChange","onError","onMicrophoneStatus","onCameraStatus","onLocalVideo","onRemoteVideo","onVideoStatusChange","_handleUserMediaError","_notifyError","qualitySettings","_applyVideoConstraints","forEach","pc","_applyBitrateConstraint","bitrate","videoTrack","getVideoTracks","applyConstraints","catch","error","console","warn","sender","getSenders","find","s","track","kind","parameters","getParameters","encodings","maxBitrate","setParameters","defaultMessage","errorMessage","Error","message","toString","name","_handleCameraMediaError","createCameraStatus","initialize","constraints","audio","video","navigator","mediaDevices","getUserMedia","enhancedStream","getTracks","stop","enhancedError","basicError","speaking","connected","emit","start","log","initializeWithVideo","audioInitialized","videoStream","size","peerId","peerConnection","entries","addTrack","_createAndSendOffer","retryMicrophoneAccess","_createPeerConnection","isInitiator","RTCPeerConnection","onicecandidate","event","candidate","to","from","onconnectionstatechange","connectionState","startMonitoring","_cleanupPeerConnection","ontrack","stream","streams","quality","metrics","set","get","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","localDescription","_handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","_handleAnswer","_handleIceCandidate","addIceCandidate","RTCIceCandidate","close","delete","acceptIncomingCall","startCall","handleAnswer","leaveRoom","keys","clear","dispose","off","stopMonitoring","toggleVideo","initialized","videoTracks","length","enabled","switchCamera","deviceId","exact","undefined","newVideoStream","senders","videoSender","newTrack","replaceTrack","getVideoDevices","devices","enumerateDevices","filter","device","isCameraEnabled","setVideoQuality","presetId","setQuality","getCurrentVideoQuality","getQualityPresets"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcManager.js"],"sourcesContent":["// eslint-disable-next-line no-unused-vars\nimport { createEnhancedAudioStream } from './audioProcessor';\nimport { SpeakingDetector } from './speakingDetector';\nimport { AudioQualityMonitor } from './qualityMonitor';\nimport { createMicrophoneStatus } from './browserDetection';\nimport { WebRTCQualityMonitor } from './webrtcQualityMonitor';\n\n/**\n * WebRTC Manager for handling peer connections\n */\nexport class WebRTCManager {\n  /**\n   * Create a new WebRTC manager\n   * @param {Socket} socket - Socket.IO socket\n   * @param {Object} options - Configuration options\n   */\n  constructor(socket, options = {}) {\n    // Store socket\n    this.socket = socket;\n    this.userId = options.userId;\n    \n    // Configuration\n    this.config = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' },\n      ],\n      iceCandidatePoolSize: 10,\n    };\n    \n    // Enhanced audio settings\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      sampleRate: 48000,\n      channelCount: 1\n    };\n    \n    // Video settings\n    this.videoConstraints = {\n      width: { ideal: 1280, max: 1920 },\n      height: { ideal: 720, max: 1080 },\n      frameRate: { ideal: 30, max: 60 }\n    };\n    \n    // State\n    this.roomId = null;\n    this.localStream = null;\n    this.localVideoStream = null;\n    this.peerConnections = new Map();\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false; // Track if permission has been denied\n    this.cameraInitialized = false;\n    this.cameraPermissionRequested = false;\n    this.cameraPermissionDenied = false;\n    this.videoEnabled = options.videoEnabled || false;\n    \n    // Phase 2: Quality monitoring and adaptive streaming\n    this.currentVideoQuality = 'high'; // Default quality\n    this.qualityMonitor = new WebRTCQualityMonitor({\n      initialQuality: this.currentVideoQuality,\n      adaptiveQuality: true,\n      onQualityChange: this._handleQualityChange.bind(this),\n      onNetworkQualityChange: options.onNetworkQualityChange || null\n    });\n    \n    // Callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n    this.onMicrophoneStatus = options.onMicrophoneStatus || null;\n    this.onCameraStatus = options.onCameraStatus || null;\n    this.onLocalVideo = options.onLocalVideo || null;\n    this.onRemoteVideo = options.onRemoteVideo || null;\n    this.onVideoStatusChange = options.onVideoStatusChange || null;\n    this.onNetworkQualityChange = options.onNetworkQualityChange || null; // Phase 2: Network quality callback\n    \n    // Bind methods\n    this._handleUserMediaError = this._handleUserMediaError.bind(this);\n    this._notifyError = this._notifyError.bind(this);\n    this._handleQualityChange = this._handleQualityChange.bind(this);\n  }\n  \n  /**\n   * Handle quality change from quality monitor\n   * @param {Object} qualitySettings - New quality settings\n   * @private\n   */\n  _handleQualityChange(qualitySettings) {\n    if (!qualitySettings) return;\n    \n    // Update video constraints\n    this.videoConstraints = {\n      ...this.videoConstraints,\n      width: { ideal: qualitySettings.width, max: qualitySettings.width * 1.5 },\n      height: { ideal: qualitySettings.height, max: qualitySettings.height * 1.5 },\n      frameRate: { ideal: qualitySettings.frameRate, max: qualitySettings.frameRate * 1.5 }\n    };\n    \n    // Apply to active video track if exists\n    this._applyVideoConstraints();\n    \n    // Apply bitrate constraints to all peer connections\n    this.peerConnections.forEach((pc) => {\n      this._applyBitrateConstraint(pc, qualitySettings.bitrate);\n    });\n  }\n  \n  /**\n   * Apply current video constraints to active video track\n   * @private\n   */\n  _applyVideoConstraints() {\n    if (this.localVideoStream) {\n      const videoTrack = this.localVideoStream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.applyConstraints(this.videoConstraints)\n          .catch(error => {\n            console.warn('Failed to apply video constraints:', error);\n          });\n      }\n    }\n  }\n  \n  /**\n   * Apply bitrate constraint to peer connection\n   * @param {RTCPeerConnection} pc - Peer connection\n   * @param {number} bitrate - Target bitrate in bps\n   * @private\n   */\n  _applyBitrateConstraint(pc, bitrate) {\n    try {\n      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');\n      if (sender) {\n        const parameters = sender.getParameters();\n        if (!parameters.encodings) {\n          parameters.encodings = [{}];\n        }\n        \n        // Set max bitrate\n        parameters.encodings[0].maxBitrate = bitrate;\n        \n        // Apply the changes\n        sender.setParameters(parameters)\n          .catch(error => {\n            console.warn('Failed to set sender parameters:', error);\n          });\n      }\n    } catch (error) {\n      console.warn('Failed to apply bitrate constraint:', error);\n    }\n  }\n  \n  /**\n   * Notify about errors in a consistent way\n   * @param {string|Error} error - Error message or object\n   * @param {string} defaultMessage - Default message if error is empty\n   * @private\n   */\n  _notifyError(error, defaultMessage = 'An unknown error occurred') {\n    let errorMessage = defaultMessage;\n    \n    if (error) {\n      if (typeof error === 'string') {\n        errorMessage = error;\n      } else if (error instanceof Error) {\n        errorMessage = error.message || error.toString();\n      } else if (error.name || error.message) {\n        errorMessage = error.message || error.name;\n      }\n    }\n    \n    console.error(defaultMessage, error || {});\n    \n    if (this.onError) {\n      this.onError(errorMessage);\n    }\n    \n    return errorMessage;\n  }\n  \n  /**\n   * Handle user media errors\n   * @param {Error} error - The error that occurred\n   * @private\n   */\n  _handleUserMediaError(error) {\n    let errorMessage = 'Failed to access microphone. Please check your permissions.';\n    \n    // Check if error exists and has properties\n    if (error) {\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Microphone access denied. Please allow microphone access in your browser settings.';\n        \n        // Show instructions for enabling microphone\n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        }\n        this.permissionDenied = true; // Mark permission as denied to prevent repeated attempts\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No microphone found. Please connect a microphone and try again.';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Could not start microphone. It may be in use by another application.';\n      } else if (error.name === 'OverconstrainedError') {\n        errorMessage = 'Microphone constraints cannot be satisfied. Please try with different settings.';\n      } else if (error.name === 'TypeError') {\n        errorMessage = 'Invalid audio constraints. Please check your browser compatibility.';\n      } else if (error.name === 'AbortError') {\n        errorMessage = 'Microphone access request was aborted. Please try again.';\n      } else if (error.name === 'SecurityError') {\n        errorMessage = 'Microphone access blocked due to security policy. Try using HTTPS.';\n      }\n    }\n    \n    this._notifyError(error, errorMessage);\n    return errorMessage;\n  }\n  \n  /**\n   * Handle camera media errors\n   * @param {Error} error - The error that occurred\n   * @private\n   */\n  _handleCameraMediaError(error) {\n    let errorMessage = 'Failed to access camera. Please check your permissions.';\n    \n    // Check if error exists and has properties\n    if (error) {\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        errorMessage = 'Camera access denied. Please allow camera access in your browser settings.';\n        \n        // Show instructions for enabling camera\n        if (this.onCameraStatus) {\n          this.onCameraStatus(createCameraStatus('denied', error.message));\n        }\n        this.cameraPermissionDenied = true; // Mark permission as denied to prevent repeated attempts\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        errorMessage = 'No camera found. Please connect a camera and try again.';\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        errorMessage = 'Could not start camera. It may be in use by another application.';\n      } else if (error.name === 'OverconstrainedError') {\n        errorMessage = 'Camera constraints cannot be satisfied. Please try with different settings.';\n      } else if (error.name === 'TypeError') {\n        errorMessage = 'Invalid video constraints. Please check your browser compatibility.';\n      } else if (error.name === 'AbortError') {\n        errorMessage = 'Camera access request was aborted. Please try again.';\n      } else if (error.name === 'SecurityError') {\n        errorMessage = 'Camera access blocked due to security policy. Try using HTTPS.';\n      }\n    }\n    \n    this._notifyError(error, errorMessage);\n    return errorMessage;\n  }\n  \n  /**\n   * Initialize WebRTC with local audio stream\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize(roomId) {\n    try {\n      // If permission was previously denied, don't try again automatically\n      if (this.permissionDenied) {\n        this.onMicrophoneStatus(createMicrophoneStatus('denied'));\n        return false;\n      }\n      \n      // Store room ID\n      this.roomId = roomId;\n      this.microphonePermissionRequested = true;\n      \n      if (this.onMicrophoneStatus) {\n        this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n      }\n      \n      // Try with simpler constraints first\n      const constraints = {\n        audio: true,\n        video: false\n      };\n      \n      try {\n        // Get user media with basic audio settings first\n        this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n        this.microphoneInitialized = true;\n        \n        if (this.onMicrophoneStatus) {\n          this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n        }\n        \n        // If basic constraints work, try to apply enhanced settings\n        try {\n          const enhancedStream = await navigator.mediaDevices.getUserMedia({\n            audio: this.audioConstraints,\n            video: false\n          });\n          \n          // Replace the basic stream with enhanced stream\n          this.localStream.getTracks().forEach(track => track.stop());\n          this.localStream = enhancedStream;\n        } catch (enhancedError) {\n          console.warn('Could not apply enhanced audio settings, using basic audio:', enhancedError);\n          // Continue with basic audio, no need to throw\n        }\n      } catch (basicError) {\n        // If basic constraints fail, throw the error to be caught by outer try/catch\n        throw basicError;\n      }\n      \n      // Create speaking detector\n      if (this.localStream) {\n        this.speakingDetector = new SpeakingDetector(this.localStream, {\n          onSpeakingChange: (speaking) => {\n            if (this.onSpeakingChange) {\n              this.onSpeakingChange(speaking);\n            }\n            \n            // Emit speaking status to other users\n            if (this.socket && this.socket.connected) {\n              this.socket.emit('speaking', {\n                roomId: this.roomId,\n                speaking\n              });\n            }\n          }\n        });\n        this.speakingDetector.start();\n      } else {\n        throw new Error('Failed to initialize local stream');\n      }\n      \n      console.log('WebRTC initialized successfully with roomId:', roomId);\n      return true;\n    } catch (error) {\n      this.microphoneInitialized = false;\n      const errorMessage = this._handleUserMediaError(error);\n      throw new Error(errorMessage);\n    }\n  }\n  \n  /**\n   * Initialize WebRTC with video\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initializeWithVideo(roomId) {\n    try {\n      // First initialize audio\n      const audioInitialized = await this.initialize(roomId);\n      if (!audioInitialized) {\n        return false;\n      }\n      \n      // If camera permission was previously denied, don't try again automatically\n      if (this.cameraPermissionDenied) {\n        if (this.onCameraStatus) {\n          this.onCameraStatus(createCameraStatus('denied'));\n        }\n        return false;\n      }\n      \n      this.cameraPermissionRequested = true;\n      \n      if (this.onCameraStatus) {\n        this.onCameraStatus(createCameraStatus('requesting'));\n      }\n      \n      try {\n        // Get video stream\n        const videoStream = await navigator.mediaDevices.getUserMedia({\n          video: this.videoConstraints\n        });\n        \n        this.cameraInitialized = true;\n        this.videoEnabled = true;\n        \n        if (this.onCameraStatus) {\n          this.onCameraStatus(createCameraStatus('granted'));\n        }\n        \n        // Store video stream\n        this.localVideoStream = videoStream;\n        \n        // Notify about local video\n        if (this.onLocalVideo) {\n          this.onLocalVideo(videoStream);\n        }\n        \n        // Notify about video status change\n        if (this.onVideoStatusChange) {\n          this.onVideoStatusChange(true);\n        }\n        \n        // If we already have peer connections, add video tracks to them\n        if (this.peerConnections.size > 0) {\n          for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n            // Add video tracks to the peer connection\n            videoStream.getVideoTracks().forEach(track => {\n              peerConnection.addTrack(track, videoStream);\n            });\n            \n            // Renegotiate the connection\n            await this._createAndSendOffer(peerId);\n          }\n        }\n        \n        return true;\n      } catch (error) {\n        this.cameraInitialized = false;\n        this.videoEnabled = false;\n        const errorMessage = this._handleCameraMediaError(error);\n        console.error(errorMessage);\n        return false;\n      }\n    } catch (error) {\n      console.error('Error initializing with video:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Retry microphone access\n   * @returns {Promise<boolean>} Success status\n   */\n  async retryMicrophoneAccess() {\n    try {\n      // Reset permission denied flag to allow retry\n      this.permissionDenied = false;\n      \n      // Notify about microphone status\n      this.onMicrophoneStatus(createMicrophoneStatus('requesting'));\n      \n      // Get user media with audio\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false\n      });\n      \n      // Microphone access granted\n      this.onMicrophoneStatus(createMicrophoneStatus('granted'));\n      \n      // Initialize speaking detector\n      if (this.speakingDetector) {\n        this.speakingDetector.stop();\n      }\n      \n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        onSpeakingChange: (speaking) => {\n          this.onSpeakingChange(speaking);\n          \n          // Emit speaking status to other users\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              speaking\n            });\n          }\n        }\n      });\n      \n      this.speakingDetector.start();\n      \n      // Rejoin room if needed\n      if (this.roomId && this.socket && this.socket.connected) {\n        this.socket.emit('join', { roomId: this.roomId });\n      }\n      \n      return true;\n    } catch (error) {\n      // Handle specific getUserMedia errors\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        this.permissionDenied = true; // Mark permission as denied\n        this.onMicrophoneStatus(createMicrophoneStatus('denied', error.message));\n        this.onError('Microphone access denied. Please allow microphone access in your browser settings.');\n      } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('No microphone found. Please connect a microphone and try again.');\n      } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        this.onMicrophoneStatus(createMicrophoneStatus('unavailable', error.message));\n        this.onError('Could not access microphone. It may be in use by another application.');\n      } else {\n        this.onMicrophoneStatus(createMicrophoneStatus('error', error.message));\n        this.onError(`Microphone error: ${error.message || 'Unknown error'}`);\n      }\n      \n      console.error('Error accessing microphone:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      console.log(`Creating peer connection for ${peerId}, isInitiator: ${isInitiator}`);\n      \n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n      \n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          console.log(`Adding track to peer connection: ${track.kind}`);\n          peerConnection.addTrack(track, this.localStream);\n        });\n      } else {\n        console.error('No local stream available when creating peer connection');\n        if (this.onError) {\n          this.onError('Microphone not initialized. Please refresh and try again.');\n        }\n      }\n      \n      // Add video tracks if available\n      if (this.videoEnabled && this.localVideoStream) {\n        this.localVideoStream.getVideoTracks().forEach(track => {\n          console.log(`Adding video track to peer connection: ${track.kind}`);\n          peerConnection.addTrack(track, this.localVideoStream);\n        });\n      }\n      \n      // Handle ICE candidates\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          console.log('Sending ICE candidate to peer:', peerId);\n          this.socket.emit('iceCandidate', {\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate,\n          });\n        }\n      };\n      \n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        console.log(`Connection state changed to: ${peerConnection.connectionState} for peer ${peerId}`);\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            \n            // Start monitoring network quality for this peer connection (Phase 2)\n            if (this.qualityMonitor) {\n              this.qualityMonitor.startMonitoring(peerConnection, peerId);\n            }\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            this._cleanupPeerConnection(peerId);\n            break;\n          default:\n            break;\n        }\n      };\n      \n      // Handle incoming tracks\n      peerConnection.ontrack = (event) => {\n        console.log(`Received track from peer ${peerId}: ${event.track.kind}`);\n        const stream = event.streams[0];\n        \n        // Store remote stream and create audio element\n        if (stream) {\n          console.log(`Received stream from peer ${peerId}`);\n          \n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n          \n          // Check if this is a video track\n          if (event.track.kind === 'video' && this.onRemoteVideo) {\n            this.onRemoteVideo(peerId, stream);\n          }\n          \n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n      \n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n      \n      // If initiator, create and send offer\n      if (isInitiator) {\n        console.log(`Initiating offer creation for peer ${peerId}`);\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n  \n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   * @returns {Promise<void>}\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      console.log(`Creating offer for peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.error(`No peer connection found for ${peerId}`);\n        return;\n      }\n      \n      // Create offer with audio and video preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: this.videoEnabled,\n      });\n      \n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      console.log(`Local description set for peer ${peerId}`);\n      \n      // Send offer to peer\n      this.socket.emit('offer', {\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription,\n      });\n      console.log(`Offer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      console.log(`Handling offer from peer ${peerId}`);\n      \n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        console.log(`Creating new peer connection for ${peerId} to handle offer`);\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      \n      if (!peerConnection) {\n        console.error(`Failed to create peer connection for ${peerId}`);\n        return;\n      }\n      \n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      console.log(`Remote description set for peer ${peerId}`);\n      \n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      console.log(`Answer created for peer ${peerId}`);\n      \n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      console.log(`Local description set for peer ${peerId}`);\n      \n      // Send answer to peer\n      this.socket.emit('answer', {\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription,\n      });\n      console.log(`Answer sent to peer ${peerId}`);\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      console.log(`Handling answer from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n        console.log(`Remote description set for peer ${peerId} from answer`);\n      } else {\n        console.error(`No peer connection found for ${peerId} when handling answer`);\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      console.log(`Handling ICE candidate from peer ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        console.log(`Successfully added ICE candidate for peer ${peerId}`);\n      } else {\n        console.warn(`Received ICE candidate for non-existent peer connection: ${peerId}`);\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Clean up a peer connection\n   * @param {string} peerId - ID of the peer\n   */\n  _cleanupPeerConnection(peerId) {\n    try {\n      console.log(`Cleaning up peer connection for ${peerId}`);\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        peerConnection.onicecandidate = null;\n        peerConnection.ontrack = null;\n        peerConnection.onconnectionstatechange = null;\n        peerConnection.close();\n        this.peerConnections.delete(peerId);\n      }\n      \n      // Clean up audio quality monitor\n      const qualityMonitor = this.audioQualityMonitors.get(peerId);\n      if (qualityMonitor) {\n        qualityMonitor.stop();\n        this.audioQualityMonitors.delete(peerId);\n      }\n      \n      console.log(`Peer connection for ${peerId} cleaned up`);\n    } catch (error) {\n      console.error(`Error cleaning up peer connection for ${peerId}:`, error);\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   * @param {string} peerId - ID of the peer who initiated the call\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<boolean>} Success status\n   */\n  async acceptIncomingCall(peerId, offer) {\n    try {\n      console.log(`Accepting incoming call from ${peerId}`);\n      await this._handleOffer(peerId, offer);\n      return true;\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      if (this.onError) {\n        this.onError('Failed to accept call. Please try again.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<RTCPeerConnection>} The peer connection\n   */\n  async startCall(peerId) {\n    try {\n      if (!this.microphonePermissionRequested) {\n        await this.initialize(this.roomId || 'default');\n      }\n      \n      if (!this.localStream || !this.microphoneInitialized) {\n        throw new Error('Microphone not initialized. Please refresh and try again.');\n      }\n      \n      // Create peer connection\n      const peerConnection = this._createPeerConnection(peerId, true);\n      \n      // Add local tracks to the connection\n      this.localStream.getTracks().forEach(track => {\n        peerConnection.addTrack(track, this.localStream);\n      });\n      \n      // Create and send offer\n      await this._createAndSendOffer(peerId);\n      \n      return peerConnection;\n    } catch (error) {\n      this._notifyError(error, 'Failed to start call');\n      throw error;\n    }\n  }\n\n  /**\n   * Handle an answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async handleAnswer(peerId, answer) {\n    console.log(`Handling answer from ${peerId} in public method`);\n    return this._handleAnswer(peerId, answer);\n  }\n\n  /**\n   * Add an ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async addIceCandidate(peerId, candidate) {\n    console.log(`Adding ICE candidate from ${peerId} in public method`);\n    return this._handleIceCandidate(peerId, candidate);\n  }\n  \n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n    \n    // Stop local stream\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n    \n    // Stop local video stream\n    if (this.localVideoStream) {\n      this.localVideoStream.getTracks().forEach(track => track.stop());\n      this.localVideoStream = null;\n    }\n    \n    // Stop speaking detector\n    if (this.speakingDetector) {\n      try {\n        this.speakingDetector.stop();\n      } catch (error) {\n        console.error('Error stopping speaking detector:', error);\n      }\n    }\n    \n    // Reset state\n    this.roomId = null;\n    this.peerConnections.clear();\n    this.audioQualityMonitors.clear();\n    this.speakingDetector = null;\n    this.microphoneInitialized = false;\n    this.microphonePermissionRequested = false;\n    this.permissionDenied = false;\n    this.cameraInitialized = false;\n    this.cameraPermissionRequested = false;\n    this.cameraPermissionDenied = false;\n    this.videoEnabled = false;\n  }\n  \n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    console.log('Disposing WebRTC manager');\n    this.leaveRoom();\n    \n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n    \n    // Stop quality monitoring (Phase 2)\n    if (this.qualityMonitor) {\n      this.qualityMonitor.stopMonitoring();\n    }\n    \n    console.log('WebRTC manager disposed');\n  }\n  \n  /**\n   * Toggle video on/off\n   * @returns {Promise<boolean>} New video status\n   */\n  async toggleVideo() {\n    try {\n      // If video is not initialized, initialize it\n      if (!this.cameraInitialized) {\n        const initialized = await this.initializeWithVideo(this.roomId);\n        return initialized;\n      }\n      \n      // If video is initialized, toggle it\n      if (this.localVideoStream) {\n        const videoTracks = this.localVideoStream.getVideoTracks();\n        if (videoTracks.length === 0) return false;\n        \n        const track = videoTracks[0];\n        track.enabled = !track.enabled;\n        this.videoEnabled = track.enabled;\n        \n        // Notify about video status change\n        if (this.onVideoStatusChange) {\n          this.onVideoStatusChange(this.videoEnabled);\n        }\n        \n        return this.videoEnabled;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Error toggling video:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Switch camera\n   * @param {string} deviceId - ID of the camera to switch to\n   * @returns {Promise<boolean>} Success status\n   */\n  async switchCamera(deviceId) {\n    try {\n      if (!this.cameraInitialized) {\n        return false;\n      }\n      \n      // Stop current video tracks\n      if (this.localVideoStream) {\n        this.localVideoStream.getVideoTracks().forEach(track => track.stop());\n      }\n      \n      // Get new video stream with specified device\n      const videoConstraints = {\n        ...this.videoConstraints,\n        deviceId: deviceId ? { exact: deviceId } : undefined\n      };\n      \n      const newVideoStream = await navigator.mediaDevices.getUserMedia({\n        video: videoConstraints\n      });\n      \n      // Replace old stream with new stream\n      this.localVideoStream = newVideoStream;\n      \n      // Notify about local video\n      if (this.onLocalVideo) {\n        this.onLocalVideo(newVideoStream);\n      }\n      \n      // Replace tracks in all peer connections\n      for (const [peerId, peerConnection] of this.peerConnections.entries()) {\n        const senders = peerConnection.getSenders();\n        const videoSender = senders.find(sender => \n          sender.track && sender.track.kind === 'video'\n        );\n        \n        if (videoSender) {\n          const newTrack = newVideoStream.getVideoTracks()[0];\n          await videoSender.replaceTrack(newTrack);\n        } else {\n          // If no video sender exists, add the track\n          newVideoStream.getVideoTracks().forEach(track => {\n            peerConnection.addTrack(track, newVideoStream);\n          });\n          \n          // Renegotiate the connection\n          await this._createAndSendOffer(peerId);\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error switching camera:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Get available video devices\n   * @returns {Promise<MediaDeviceInfo[]>} List of video devices\n   */\n  async getVideoDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'videoinput');\n    } catch (error) {\n      console.error('Error getting video devices:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * Check if camera is enabled\n   * @returns {boolean} Camera status\n   */\n  isCameraEnabled() {\n    if (!this.localVideoStream) return false;\n    \n    const videoTracks = this.localVideoStream.getVideoTracks();\n    if (videoTracks.length === 0) return false;\n    \n    return videoTracks[0].enabled;\n  }\n  \n  /**\n   * Set video quality preset\n   * @param {string} presetId - Quality preset ID ('low', 'medium', 'high', 'hd', 'auto')\n   * @returns {Promise<boolean>} Success status\n   */\n  async setVideoQuality(presetId) {\n    try {\n      const qualitySettings = this.qualityMonitor.setQuality(presetId);\n      this.currentVideoQuality = presetId;\n      return true;\n    } catch (error) {\n      console.error('Error setting video quality:', error);\n      if (this.onError) {\n        this.onError(`Failed to set video quality: ${error.message}`);\n      }\n      return false;\n    }\n  }\n  \n  /**\n   * Get current video quality preset\n   * @returns {string} Current quality preset ID\n   */\n  getCurrentVideoQuality() {\n    return this.currentVideoQuality;\n  }\n  \n  /**\n   * Get all available quality presets\n   * @returns {Object} Quality presets\n   */\n  getQualityPresets() {\n    return this.qualityMonitor.getQualityPresets();\n  }\n}\n"],"mappings":"AAAA;AACA,SAASA,yBAAyB,QAAQ,kBAAkB;AAC5D,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,mBAAmB,QAAQ,kBAAkB;AACtD,SAASC,sBAAsB,QAAQ,oBAAoB;AAC3D,SAASC,oBAAoB,QAAQ,wBAAwB;;AAE7D;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EACzB;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAChC;IACA,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,MAAM,GAAGD,OAAO,CAACC,MAAM;;IAE5B;IACA,IAAI,CAACC,MAAM,GAAG;MACZC,UAAU,EAAE,CACV;QAAEC,IAAI,EAAE;MAA+B,CAAC,EACxC;QAAEA,IAAI,EAAE;MAAgC,CAAC,EACzC;QAAEA,IAAI,EAAE;MAAgC,CAAC,CAC1C;MACDC,oBAAoB,EAAE;IACxB,CAAC;;IAED;IACA,IAAI,CAACC,gBAAgB,GAAG;MACtBC,gBAAgB,EAAE,IAAI;MACtBC,gBAAgB,EAAE,IAAI;MACtBC,eAAe,EAAE,IAAI;MACrBC,UAAU,EAAE,KAAK;MACjBC,YAAY,EAAE;IAChB,CAAC;;IAED;IACA,IAAI,CAACC,gBAAgB,GAAG;MACtBC,KAAK,EAAE;QAAEC,KAAK,EAAE,IAAI;QAAEC,GAAG,EAAE;MAAK,CAAC;MACjCC,MAAM,EAAE;QAAEF,KAAK,EAAE,GAAG;QAAEC,GAAG,EAAE;MAAK,CAAC;MACjCE,SAAS,EAAE;QAAEH,KAAK,EAAE,EAAE;QAAEC,GAAG,EAAE;MAAG;IAClC,CAAC;;IAED;IACA,IAAI,CAACG,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,oBAAoB,GAAG,IAAIF,GAAG,CAAC,CAAC;IACrC,IAAI,CAACG,qBAAqB,GAAG,KAAK;IAClC,IAAI,CAACC,6BAA6B,GAAG,KAAK;IAC1C,IAAI,CAACC,gBAAgB,GAAG,KAAK,CAAC,CAAC;IAC/B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,yBAAyB,GAAG,KAAK;IACtC,IAAI,CAACC,sBAAsB,GAAG,KAAK;IACnC,IAAI,CAACC,YAAY,GAAG/B,OAAO,CAAC+B,YAAY,IAAI,KAAK;;IAEjD;IACA,IAAI,CAACC,mBAAmB,GAAG,MAAM,CAAC,CAAC;IACnC,IAAI,CAACC,cAAc,GAAG,IAAIrC,oBAAoB,CAAC;MAC7CsC,cAAc,EAAE,IAAI,CAACF,mBAAmB;MACxCG,eAAe,EAAE,IAAI;MACrBC,eAAe,EAAE,IAAI,CAACC,oBAAoB,CAACC,IAAI,CAAC,IAAI,CAAC;MACrDC,sBAAsB,EAAEvC,OAAO,CAACuC,sBAAsB,IAAI;IAC5D,CAAC,CAAC;;IAEF;IACA,IAAI,CAACC,aAAa,GAAGxC,OAAO,CAACwC,aAAa,IAAI,IAAI;IAClD,IAAI,CAACC,gBAAgB,GAAGzC,OAAO,CAACyC,gBAAgB,IAAI,IAAI;IACxD,IAAI,CAACC,gBAAgB,GAAG1C,OAAO,CAAC0C,gBAAgB,IAAI,IAAI;IACxD,IAAI,CAACC,oBAAoB,GAAG3C,OAAO,CAAC2C,oBAAoB,IAAI,IAAI;IAChE,IAAI,CAACC,OAAO,GAAG5C,OAAO,CAAC4C,OAAO,IAAI,IAAI;IACtC,IAAI,CAACC,kBAAkB,GAAG7C,OAAO,CAAC6C,kBAAkB,IAAI,IAAI;IAC5D,IAAI,CAACC,cAAc,GAAG9C,OAAO,CAAC8C,cAAc,IAAI,IAAI;IACpD,IAAI,CAACC,YAAY,GAAG/C,OAAO,CAAC+C,YAAY,IAAI,IAAI;IAChD,IAAI,CAACC,aAAa,GAAGhD,OAAO,CAACgD,aAAa,IAAI,IAAI;IAClD,IAAI,CAACC,mBAAmB,GAAGjD,OAAO,CAACiD,mBAAmB,IAAI,IAAI;IAC9D,IAAI,CAACV,sBAAsB,GAAGvC,OAAO,CAACuC,sBAAsB,IAAI,IAAI,CAAC,CAAC;;IAEtE;IACA,IAAI,CAACW,qBAAqB,GAAG,IAAI,CAACA,qBAAqB,CAACZ,IAAI,CAAC,IAAI,CAAC;IAClE,IAAI,CAACa,YAAY,GAAG,IAAI,CAACA,YAAY,CAACb,IAAI,CAAC,IAAI,CAAC;IAChD,IAAI,CAACD,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACC,IAAI,CAAC,IAAI,CAAC;EAClE;;EAEA;AACF;AACA;AACA;AACA;EACED,oBAAoBA,CAACe,eAAe,EAAE;IACpC,IAAI,CAACA,eAAe,EAAE;;IAEtB;IACA,IAAI,CAACxC,gBAAgB,GAAG;MACtB,GAAG,IAAI,CAACA,gBAAgB;MACxBC,KAAK,EAAE;QAAEC,KAAK,EAAEsC,eAAe,CAACvC,KAAK;QAAEE,GAAG,EAAEqC,eAAe,CAACvC,KAAK,GAAG;MAAI,CAAC;MACzEG,MAAM,EAAE;QAAEF,KAAK,EAAEsC,eAAe,CAACpC,MAAM;QAAED,GAAG,EAAEqC,eAAe,CAACpC,MAAM,GAAG;MAAI,CAAC;MAC5EC,SAAS,EAAE;QAAEH,KAAK,EAAEsC,eAAe,CAACnC,SAAS;QAAEF,GAAG,EAAEqC,eAAe,CAACnC,SAAS,GAAG;MAAI;IACtF,CAAC;;IAED;IACA,IAAI,CAACoC,sBAAsB,CAAC,CAAC;;IAE7B;IACA,IAAI,CAAChC,eAAe,CAACiC,OAAO,CAAEC,EAAE,IAAK;MACnC,IAAI,CAACC,uBAAuB,CAACD,EAAE,EAAEH,eAAe,CAACK,OAAO,CAAC;IAC3D,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;EACEJ,sBAAsBA,CAAA,EAAG;IACvB,IAAI,IAAI,CAACjC,gBAAgB,EAAE;MACzB,MAAMsC,UAAU,GAAG,IAAI,CAACtC,gBAAgB,CAACuC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5D,IAAID,UAAU,EAAE;QACdA,UAAU,CAACE,gBAAgB,CAAC,IAAI,CAAChD,gBAAgB,CAAC,CAC/CiD,KAAK,CAACC,KAAK,IAAI;UACdC,OAAO,CAACC,IAAI,CAAC,oCAAoC,EAAEF,KAAK,CAAC;QAC3D,CAAC,CAAC;MACN;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEN,uBAAuBA,CAACD,EAAE,EAAEE,OAAO,EAAE;IACnC,IAAI;MACF,MAAMQ,MAAM,GAAGV,EAAE,CAACW,UAAU,CAAC,CAAC,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,KAAK,IAAID,CAAC,CAACC,KAAK,CAACC,IAAI,KAAK,OAAO,CAAC;MAC7E,IAAIL,MAAM,EAAE;QACV,MAAMM,UAAU,GAAGN,MAAM,CAACO,aAAa,CAAC,CAAC;QACzC,IAAI,CAACD,UAAU,CAACE,SAAS,EAAE;UACzBF,UAAU,CAACE,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;QAC7B;;QAEA;QACAF,UAAU,CAACE,SAAS,CAAC,CAAC,CAAC,CAACC,UAAU,GAAGjB,OAAO;;QAE5C;QACAQ,MAAM,CAACU,aAAa,CAACJ,UAAU,CAAC,CAC7BV,KAAK,CAACC,KAAK,IAAI;UACdC,OAAO,CAACC,IAAI,CAAC,kCAAkC,EAAEF,KAAK,CAAC;QACzD,CAAC,CAAC;MACN;IACF,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,qCAAqC,EAAEF,KAAK,CAAC;IAC5D;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEX,YAAYA,CAACW,KAAK,EAAEc,cAAc,GAAG,2BAA2B,EAAE;IAChE,IAAIC,YAAY,GAAGD,cAAc;IAEjC,IAAId,KAAK,EAAE;MACT,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QAC7Be,YAAY,GAAGf,KAAK;MACtB,CAAC,MAAM,IAAIA,KAAK,YAAYgB,KAAK,EAAE;QACjCD,YAAY,GAAGf,KAAK,CAACiB,OAAO,IAAIjB,KAAK,CAACkB,QAAQ,CAAC,CAAC;MAClD,CAAC,MAAM,IAAIlB,KAAK,CAACmB,IAAI,IAAInB,KAAK,CAACiB,OAAO,EAAE;QACtCF,YAAY,GAAGf,KAAK,CAACiB,OAAO,IAAIjB,KAAK,CAACmB,IAAI;MAC5C;IACF;IAEAlB,OAAO,CAACD,KAAK,CAACc,cAAc,EAAEd,KAAK,IAAI,CAAC,CAAC,CAAC;IAE1C,IAAI,IAAI,CAAClB,OAAO,EAAE;MAChB,IAAI,CAACA,OAAO,CAACiC,YAAY,CAAC;IAC5B;IAEA,OAAOA,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACE3B,qBAAqBA,CAACY,KAAK,EAAE;IAC3B,IAAIe,YAAY,GAAG,6DAA6D;;IAEhF;IACA,IAAIf,KAAK,EAAE;MACT,IAAIA,KAAK,CAACmB,IAAI,KAAK,iBAAiB,IAAInB,KAAK,CAACmB,IAAI,KAAK,uBAAuB,EAAE;QAC9EJ,YAAY,GAAG,oFAAoF;;QAEnG;QACA,IAAI,IAAI,CAAChC,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,CAAClD,sBAAsB,CAAC,QAAQ,EAAEmE,KAAK,CAACiB,OAAO,CAAC,CAAC;QAC1E;QACA,IAAI,CAACpD,gBAAgB,GAAG,IAAI,CAAC,CAAC;MAChC,CAAC,MAAM,IAAImC,KAAK,CAACmB,IAAI,KAAK,eAAe,IAAInB,KAAK,CAACmB,IAAI,KAAK,sBAAsB,EAAE;QAClFJ,YAAY,GAAG,iEAAiE;MAClF,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,kBAAkB,IAAInB,KAAK,CAACmB,IAAI,KAAK,iBAAiB,EAAE;QAChFJ,YAAY,GAAG,sEAAsE;MACvF,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,sBAAsB,EAAE;QAChDJ,YAAY,GAAG,iFAAiF;MAClG,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,WAAW,EAAE;QACrCJ,YAAY,GAAG,qEAAqE;MACtF,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,YAAY,EAAE;QACtCJ,YAAY,GAAG,0DAA0D;MAC3E,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,eAAe,EAAE;QACzCJ,YAAY,GAAG,oEAAoE;MACrF;IACF;IAEA,IAAI,CAAC1B,YAAY,CAACW,KAAK,EAAEe,YAAY,CAAC;IACtC,OAAOA,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACEK,uBAAuBA,CAACpB,KAAK,EAAE;IAC7B,IAAIe,YAAY,GAAG,yDAAyD;;IAE5E;IACA,IAAIf,KAAK,EAAE;MACT,IAAIA,KAAK,CAACmB,IAAI,KAAK,iBAAiB,IAAInB,KAAK,CAACmB,IAAI,KAAK,uBAAuB,EAAE;QAC9EJ,YAAY,GAAG,4EAA4E;;QAE3F;QACA,IAAI,IAAI,CAAC/B,cAAc,EAAE;UACvB,IAAI,CAACA,cAAc,CAACqC,kBAAkB,CAAC,QAAQ,EAAErB,KAAK,CAACiB,OAAO,CAAC,CAAC;QAClE;QACA,IAAI,CAACjD,sBAAsB,GAAG,IAAI,CAAC,CAAC;MACtC,CAAC,MAAM,IAAIgC,KAAK,CAACmB,IAAI,KAAK,eAAe,IAAInB,KAAK,CAACmB,IAAI,KAAK,sBAAsB,EAAE;QAClFJ,YAAY,GAAG,yDAAyD;MAC1E,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,kBAAkB,IAAInB,KAAK,CAACmB,IAAI,KAAK,iBAAiB,EAAE;QAChFJ,YAAY,GAAG,kEAAkE;MACnF,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,sBAAsB,EAAE;QAChDJ,YAAY,GAAG,6EAA6E;MAC9F,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,WAAW,EAAE;QACrCJ,YAAY,GAAG,qEAAqE;MACtF,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,YAAY,EAAE;QACtCJ,YAAY,GAAG,sDAAsD;MACvE,CAAC,MAAM,IAAIf,KAAK,CAACmB,IAAI,KAAK,eAAe,EAAE;QACzCJ,YAAY,GAAG,gEAAgE;MACjF;IACF;IAEA,IAAI,CAAC1B,YAAY,CAACW,KAAK,EAAEe,YAAY,CAAC;IACtC,OAAOA,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMO,UAAUA,CAAClE,MAAM,EAAE;IACvB,IAAI;MACF;MACA,IAAI,IAAI,CAACS,gBAAgB,EAAE;QACzB,IAAI,CAACkB,kBAAkB,CAAClD,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QACzD,OAAO,KAAK;MACd;;MAEA;MACA,IAAI,CAACuB,MAAM,GAAGA,MAAM;MACpB,IAAI,CAACQ,6BAA6B,GAAG,IAAI;MAEzC,IAAI,IAAI,CAACmB,kBAAkB,EAAE;QAC3B,IAAI,CAACA,kBAAkB,CAAClD,sBAAsB,CAAC,YAAY,CAAC,CAAC;MAC/D;;MAEA;MACA,MAAM0F,WAAW,GAAG;QAClBC,KAAK,EAAE,IAAI;QACXC,KAAK,EAAE;MACT,CAAC;MAED,IAAI;QACF;QACA,IAAI,CAACpE,WAAW,GAAG,MAAMqE,SAAS,CAACC,YAAY,CAACC,YAAY,CAACL,WAAW,CAAC;QACzE,IAAI,CAAC5D,qBAAqB,GAAG,IAAI;QAEjC,IAAI,IAAI,CAACoB,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,CAAClD,sBAAsB,CAAC,SAAS,CAAC,CAAC;QAC5D;;QAEA;QACA,IAAI;UACF,MAAMgG,cAAc,GAAG,MAAMH,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;YAC/DJ,KAAK,EAAE,IAAI,CAAChF,gBAAgB;YAC5BiF,KAAK,EAAE;UACT,CAAC,CAAC;;UAEF;UACA,IAAI,CAACpE,WAAW,CAACyE,SAAS,CAAC,CAAC,CAACtC,OAAO,CAACe,KAAK,IAAIA,KAAK,CAACwB,IAAI,CAAC,CAAC,CAAC;UAC3D,IAAI,CAAC1E,WAAW,GAAGwE,cAAc;QACnC,CAAC,CAAC,OAAOG,aAAa,EAAE;UACtB/B,OAAO,CAACC,IAAI,CAAC,6DAA6D,EAAE8B,aAAa,CAAC;UAC1F;QACF;MACF,CAAC,CAAC,OAAOC,UAAU,EAAE;QACnB;QACA,MAAMA,UAAU;MAClB;;MAEA;MACA,IAAI,IAAI,CAAC5E,WAAW,EAAE;QACpB,IAAI,CAACI,gBAAgB,GAAG,IAAI9B,gBAAgB,CAAC,IAAI,CAAC0B,WAAW,EAAE;UAC7DuB,gBAAgB,EAAGsD,QAAQ,IAAK;YAC9B,IAAI,IAAI,CAACtD,gBAAgB,EAAE;cACzB,IAAI,CAACA,gBAAgB,CAACsD,QAAQ,CAAC;YACjC;;YAEA;YACA,IAAI,IAAI,CAACjG,MAAM,IAAI,IAAI,CAACA,MAAM,CAACkG,SAAS,EAAE;cACxC,IAAI,CAAClG,MAAM,CAACmG,IAAI,CAAC,UAAU,EAAE;gBAC3BhF,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnB8E;cACF,CAAC,CAAC;YACJ;UACF;QACF,CAAC,CAAC;QACF,IAAI,CAACzE,gBAAgB,CAAC4E,KAAK,CAAC,CAAC;MAC/B,CAAC,MAAM;QACL,MAAM,IAAIrB,KAAK,CAAC,mCAAmC,CAAC;MACtD;MAEAf,OAAO,CAACqC,GAAG,CAAC,8CAA8C,EAAElF,MAAM,CAAC;MACnE,OAAO,IAAI;IACb,CAAC,CAAC,OAAO4C,KAAK,EAAE;MACd,IAAI,CAACrC,qBAAqB,GAAG,KAAK;MAClC,MAAMoD,YAAY,GAAG,IAAI,CAAC3B,qBAAqB,CAACY,KAAK,CAAC;MACtD,MAAM,IAAIgB,KAAK,CAACD,YAAY,CAAC;IAC/B;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMwB,mBAAmBA,CAACnF,MAAM,EAAE;IAChC,IAAI;MACF;MACA,MAAMoF,gBAAgB,GAAG,MAAM,IAAI,CAAClB,UAAU,CAAClE,MAAM,CAAC;MACtD,IAAI,CAACoF,gBAAgB,EAAE;QACrB,OAAO,KAAK;MACd;;MAEA;MACA,IAAI,IAAI,CAACxE,sBAAsB,EAAE;QAC/B,IAAI,IAAI,CAACgB,cAAc,EAAE;UACvB,IAAI,CAACA,cAAc,CAACqC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QACnD;QACA,OAAO,KAAK;MACd;MAEA,IAAI,CAACtD,yBAAyB,GAAG,IAAI;MAErC,IAAI,IAAI,CAACiB,cAAc,EAAE;QACvB,IAAI,CAACA,cAAc,CAACqC,kBAAkB,CAAC,YAAY,CAAC,CAAC;MACvD;MAEA,IAAI;QACF;QACA,MAAMoB,WAAW,GAAG,MAAMf,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;UAC5DH,KAAK,EAAE,IAAI,CAAC3E;QACd,CAAC,CAAC;QAEF,IAAI,CAACgB,iBAAiB,GAAG,IAAI;QAC7B,IAAI,CAACG,YAAY,GAAG,IAAI;QAExB,IAAI,IAAI,CAACe,cAAc,EAAE;UACvB,IAAI,CAACA,cAAc,CAACqC,kBAAkB,CAAC,SAAS,CAAC,CAAC;QACpD;;QAEA;QACA,IAAI,CAAC/D,gBAAgB,GAAGmF,WAAW;;QAEnC;QACA,IAAI,IAAI,CAACxD,YAAY,EAAE;UACrB,IAAI,CAACA,YAAY,CAACwD,WAAW,CAAC;QAChC;;QAEA;QACA,IAAI,IAAI,CAACtD,mBAAmB,EAAE;UAC5B,IAAI,CAACA,mBAAmB,CAAC,IAAI,CAAC;QAChC;;QAEA;QACA,IAAI,IAAI,CAAC5B,eAAe,CAACmF,IAAI,GAAG,CAAC,EAAE;UACjC,KAAK,MAAM,CAACC,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAACrF,eAAe,CAACsF,OAAO,CAAC,CAAC,EAAE;YACrE;YACAJ,WAAW,CAAC5C,cAAc,CAAC,CAAC,CAACL,OAAO,CAACe,KAAK,IAAI;cAC5CqC,cAAc,CAACE,QAAQ,CAACvC,KAAK,EAAEkC,WAAW,CAAC;YAC7C,CAAC,CAAC;;YAEF;YACA,MAAM,IAAI,CAACM,mBAAmB,CAACJ,MAAM,CAAC;UACxC;QACF;QAEA,OAAO,IAAI;MACb,CAAC,CAAC,OAAO3C,KAAK,EAAE;QACd,IAAI,CAAClC,iBAAiB,GAAG,KAAK;QAC9B,IAAI,CAACG,YAAY,GAAG,KAAK;QACzB,MAAM8C,YAAY,GAAG,IAAI,CAACK,uBAAuB,CAACpB,KAAK,CAAC;QACxDC,OAAO,CAACD,KAAK,CAACe,YAAY,CAAC;QAC3B,OAAO,KAAK;MACd;IACF,CAAC,CAAC,OAAOf,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACtD,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMgD,qBAAqBA,CAAA,EAAG;IAC5B,IAAI;MACF;MACA,IAAI,CAACnF,gBAAgB,GAAG,KAAK;;MAE7B;MACA,IAAI,CAACkB,kBAAkB,CAAClD,sBAAsB,CAAC,YAAY,CAAC,CAAC;;MAE7D;MACA,IAAI,CAACwB,WAAW,GAAG,MAAMqE,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAC3DJ,KAAK,EAAE,IAAI,CAAChF,gBAAgB;QAC5BiF,KAAK,EAAE;MACT,CAAC,CAAC;;MAEF;MACA,IAAI,CAAC1C,kBAAkB,CAAClD,sBAAsB,CAAC,SAAS,CAAC,CAAC;;MAE1D;MACA,IAAI,IAAI,CAAC4B,gBAAgB,EAAE;QACzB,IAAI,CAACA,gBAAgB,CAACsE,IAAI,CAAC,CAAC;MAC9B;MAEA,IAAI,CAACtE,gBAAgB,GAAG,IAAI9B,gBAAgB,CAAC,IAAI,CAAC0B,WAAW,EAAE;QAC7DuB,gBAAgB,EAAGsD,QAAQ,IAAK;UAC9B,IAAI,CAACtD,gBAAgB,CAACsD,QAAQ,CAAC;;UAE/B;UACA,IAAI,IAAI,CAACjG,MAAM,IAAI,IAAI,CAACA,MAAM,CAACkG,SAAS,EAAE;YACxC,IAAI,CAAClG,MAAM,CAACmG,IAAI,CAAC,UAAU,EAAE;cAC3BhF,MAAM,EAAE,IAAI,CAACA,MAAM;cACnB8E;YACF,CAAC,CAAC;UACJ;QACF;MACF,CAAC,CAAC;MAEF,IAAI,CAACzE,gBAAgB,CAAC4E,KAAK,CAAC,CAAC;;MAE7B;MACA,IAAI,IAAI,CAACjF,MAAM,IAAI,IAAI,CAACnB,MAAM,IAAI,IAAI,CAACA,MAAM,CAACkG,SAAS,EAAE;QACvD,IAAI,CAAClG,MAAM,CAACmG,IAAI,CAAC,MAAM,EAAE;UAAEhF,MAAM,EAAE,IAAI,CAACA;QAAO,CAAC,CAAC;MACnD;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAO4C,KAAK,EAAE;MACd;MACA,IAAIA,KAAK,CAACmB,IAAI,KAAK,iBAAiB,IAAInB,KAAK,CAACmB,IAAI,KAAK,uBAAuB,EAAE;QAC9E,IAAI,CAACtD,gBAAgB,GAAG,IAAI,CAAC,CAAC;QAC9B,IAAI,CAACkB,kBAAkB,CAAClD,sBAAsB,CAAC,QAAQ,EAAEmE,KAAK,CAACiB,OAAO,CAAC,CAAC;QACxE,IAAI,CAACnC,OAAO,CAAC,oFAAoF,CAAC;MACpG,CAAC,MAAM,IAAIkB,KAAK,CAACmB,IAAI,KAAK,eAAe,IAAInB,KAAK,CAACmB,IAAI,KAAK,sBAAsB,EAAE;QAClF,IAAI,CAACpC,kBAAkB,CAAClD,sBAAsB,CAAC,aAAa,EAAEmE,KAAK,CAACiB,OAAO,CAAC,CAAC;QAC7E,IAAI,CAACnC,OAAO,CAAC,iEAAiE,CAAC;MACjF,CAAC,MAAM,IAAIkB,KAAK,CAACmB,IAAI,KAAK,kBAAkB,IAAInB,KAAK,CAACmB,IAAI,KAAK,iBAAiB,EAAE;QAChF,IAAI,CAACpC,kBAAkB,CAAClD,sBAAsB,CAAC,aAAa,EAAEmE,KAAK,CAACiB,OAAO,CAAC,CAAC;QAC7E,IAAI,CAACnC,OAAO,CAAC,uEAAuE,CAAC;MACvF,CAAC,MAAM;QACL,IAAI,CAACC,kBAAkB,CAAClD,sBAAsB,CAAC,OAAO,EAAEmE,KAAK,CAACiB,OAAO,CAAC,CAAC;QACvE,IAAI,CAACnC,OAAO,CAAC,qBAAqBkB,KAAK,CAACiB,OAAO,IAAI,eAAe,EAAE,CAAC;MACvE;MAEAhB,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEiD,qBAAqBA,CAACN,MAAM,EAAEO,WAAW,GAAG,KAAK,EAAE;IACjD,IAAI;MACFjD,OAAO,CAACqC,GAAG,CAAC,gCAAgCK,MAAM,kBAAkBO,WAAW,EAAE,CAAC;;MAElF;MACA,MAAMN,cAAc,GAAG,IAAIO,iBAAiB,CAAC,IAAI,CAAC/G,MAAM,CAAC;;MAEzD;MACA,IAAI,IAAI,CAACiB,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,CAACyE,SAAS,CAAC,CAAC,CAACtC,OAAO,CAACe,KAAK,IAAI;UAC5CN,OAAO,CAACqC,GAAG,CAAC,oCAAoC/B,KAAK,CAACC,IAAI,EAAE,CAAC;UAC7DoC,cAAc,CAACE,QAAQ,CAACvC,KAAK,EAAE,IAAI,CAAClD,WAAW,CAAC;QAClD,CAAC,CAAC;MACJ,CAAC,MAAM;QACL4C,OAAO,CAACD,KAAK,CAAC,yDAAyD,CAAC;QACxE,IAAI,IAAI,CAAClB,OAAO,EAAE;UAChB,IAAI,CAACA,OAAO,CAAC,2DAA2D,CAAC;QAC3E;MACF;;MAEA;MACA,IAAI,IAAI,CAACb,YAAY,IAAI,IAAI,CAACX,gBAAgB,EAAE;QAC9C,IAAI,CAACA,gBAAgB,CAACuC,cAAc,CAAC,CAAC,CAACL,OAAO,CAACe,KAAK,IAAI;UACtDN,OAAO,CAACqC,GAAG,CAAC,0CAA0C/B,KAAK,CAACC,IAAI,EAAE,CAAC;UACnEoC,cAAc,CAACE,QAAQ,CAACvC,KAAK,EAAE,IAAI,CAACjD,gBAAgB,CAAC;QACvD,CAAC,CAAC;MACJ;;MAEA;MACAsF,cAAc,CAACQ,cAAc,GAAIC,KAAK,IAAK;QACzC,IAAIA,KAAK,CAACC,SAAS,EAAE;UACnBrD,OAAO,CAACqC,GAAG,CAAC,gCAAgC,EAAEK,MAAM,CAAC;UACrD,IAAI,CAAC1G,MAAM,CAACmG,IAAI,CAAC,cAAc,EAAE;YAC/BmB,EAAE,EAAEZ,MAAM;YACVa,IAAI,EAAE,IAAI,CAACrH,MAAM;YACjBmH,SAAS,EAAED,KAAK,CAACC;UACnB,CAAC,CAAC;QACJ;MACF,CAAC;;MAED;MACAV,cAAc,CAACa,uBAAuB,GAAG,MAAM;QAC7CxD,OAAO,CAACqC,GAAG,CAAC,gCAAgCM,cAAc,CAACc,eAAe,aAAaf,MAAM,EAAE,CAAC;QAChG,QAAQC,cAAc,CAACc,eAAe;UACpC,KAAK,WAAW;YACdzD,OAAO,CAACqC,GAAG,CAAC,sBAAsBK,MAAM,EAAE,CAAC;;YAE3C;YACA,IAAI,IAAI,CAACxE,cAAc,EAAE;cACvB,IAAI,CAACA,cAAc,CAACwF,eAAe,CAACf,cAAc,EAAED,MAAM,CAAC;YAC7D;YACA;UACF,KAAK,cAAc;UACnB,KAAK,QAAQ;UACb,KAAK,QAAQ;YACX1C,OAAO,CAACqC,GAAG,CAAC,2BAA2BK,MAAM,EAAE,CAAC;YAChD,IAAI,IAAI,CAAChE,gBAAgB,EAAE;cACzB,IAAI,CAACA,gBAAgB,CAACgE,MAAM,CAAC;YAC/B;YACA,IAAI,CAACiB,sBAAsB,CAACjB,MAAM,CAAC;YACnC;UACF;YACE;QACJ;MACF,CAAC;;MAED;MACAC,cAAc,CAACiB,OAAO,GAAIR,KAAK,IAAK;QAClCpD,OAAO,CAACqC,GAAG,CAAC,4BAA4BK,MAAM,KAAKU,KAAK,CAAC9C,KAAK,CAACC,IAAI,EAAE,CAAC;QACtE,MAAMsD,MAAM,GAAGT,KAAK,CAACU,OAAO,CAAC,CAAC,CAAC;;QAE/B;QACA,IAAID,MAAM,EAAE;UACV7D,OAAO,CAACqC,GAAG,CAAC,6BAA6BK,MAAM,EAAE,CAAC;;UAElD;UACA,MAAMxE,cAAc,GAAG,IAAIvC,mBAAmB,CAACgH,cAAc,EAAE;YAC7DtE,eAAe,EAAEA,CAAC0F,OAAO,EAAEC,OAAO,KAAK;cACrC,IAAI,IAAI,CAACpF,oBAAoB,EAAE;gBAC7B,IAAI,CAACA,oBAAoB,CAAC8D,MAAM,EAAEqB,OAAO,EAAEC,OAAO,CAAC;cACrD;YACF;UACF,CAAC,CAAC;UACF9F,cAAc,CAACkE,KAAK,CAAC,CAAC;UACtB,IAAI,CAAC3E,oBAAoB,CAACwG,GAAG,CAACvB,MAAM,EAAExE,cAAc,CAAC;;UAErD;UACA,IAAIkF,KAAK,CAAC9C,KAAK,CAACC,IAAI,KAAK,OAAO,IAAI,IAAI,CAACtB,aAAa,EAAE;YACtD,IAAI,CAACA,aAAa,CAACyD,MAAM,EAAEmB,MAAM,CAAC;UACpC;;UAEA;UACA,IAAI,IAAI,CAACpF,aAAa,EAAE;YACtB,IAAI,CAACA,aAAa,CAACiE,MAAM,EAAEmB,MAAM,CAAC;UACpC;QACF;MACF,CAAC;;MAED;MACA,IAAI,CAACvG,eAAe,CAAC2G,GAAG,CAACvB,MAAM,EAAEC,cAAc,CAAC;;MAEhD;MACA,IAAIM,WAAW,EAAE;QACfjD,OAAO,CAACqC,GAAG,CAAC,sCAAsCK,MAAM,EAAE,CAAC;QAC3D,IAAI,CAACI,mBAAmB,CAACJ,MAAM,CAAC;MAClC;MAEA,OAAOC,cAAc;IACvB,CAAC,CAAC,OAAO5C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,gDAAgD,CAAC;MAChE;MACA,OAAO,IAAI;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMiE,mBAAmBA,CAACJ,MAAM,EAAE;IAChC,IAAI;MACF1C,OAAO,CAACqC,GAAG,CAAC,2BAA2BK,MAAM,EAAE,CAAC;MAChD,MAAMC,cAAc,GAAG,IAAI,CAACrF,eAAe,CAAC4G,GAAG,CAACxB,MAAM,CAAC;MACvD,IAAI,CAACC,cAAc,EAAE;QACnB3C,OAAO,CAACD,KAAK,CAAC,gCAAgC2C,MAAM,EAAE,CAAC;QACvD;MACF;;MAEA;MACA,MAAMyB,KAAK,GAAG,MAAMxB,cAAc,CAACyB,WAAW,CAAC;QAC7CC,mBAAmB,EAAE,IAAI;QACzBC,mBAAmB,EAAE,IAAI,CAACtG;MAC5B,CAAC,CAAC;;MAEF;MACA,MAAM2E,cAAc,CAAC4B,mBAAmB,CAACJ,KAAK,CAAC;MAC/CnE,OAAO,CAACqC,GAAG,CAAC,kCAAkCK,MAAM,EAAE,CAAC;;MAEvD;MACA,IAAI,CAAC1G,MAAM,CAACmG,IAAI,CAAC,OAAO,EAAE;QACxBmB,EAAE,EAAEZ,MAAM;QACVa,IAAI,EAAE,IAAI,CAACrH,MAAM;QACjBiI,KAAK,EAAExB,cAAc,CAAC6B;MACxB,CAAC,CAAC;MACFxE,OAAO,CAACqC,GAAG,CAAC,sBAAsBK,MAAM,EAAE,CAAC;IAC7C,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,sDAAsD,CAAC;MACtE;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAM4F,YAAYA,CAAC/B,MAAM,EAAEyB,KAAK,EAAE;IAChC,IAAI;MACFnE,OAAO,CAACqC,GAAG,CAAC,4BAA4BK,MAAM,EAAE,CAAC;;MAEjD;MACA,IAAIC,cAAc,GAAG,IAAI,CAACrF,eAAe,CAAC4G,GAAG,CAACxB,MAAM,CAAC;MACrD,IAAI,CAACC,cAAc,EAAE;QACnB3C,OAAO,CAACqC,GAAG,CAAC,oCAAoCK,MAAM,kBAAkB,CAAC;QACzEC,cAAc,GAAG,IAAI,CAACK,qBAAqB,CAACN,MAAM,CAAC;MACrD;MAEA,IAAI,CAACC,cAAc,EAAE;QACnB3C,OAAO,CAACD,KAAK,CAAC,wCAAwC2C,MAAM,EAAE,CAAC;QAC/D;MACF;;MAEA;MACA,MAAMC,cAAc,CAAC+B,oBAAoB,CAAC,IAAIC,qBAAqB,CAACR,KAAK,CAAC,CAAC;MAC3EnE,OAAO,CAACqC,GAAG,CAAC,mCAAmCK,MAAM,EAAE,CAAC;;MAExD;MACA,MAAMkC,MAAM,GAAG,MAAMjC,cAAc,CAACkC,YAAY,CAAC,CAAC;MAClD7E,OAAO,CAACqC,GAAG,CAAC,2BAA2BK,MAAM,EAAE,CAAC;;MAEhD;MACA,MAAMC,cAAc,CAAC4B,mBAAmB,CAACK,MAAM,CAAC;MAChD5E,OAAO,CAACqC,GAAG,CAAC,kCAAkCK,MAAM,EAAE,CAAC;;MAEvD;MACA,IAAI,CAAC1G,MAAM,CAACmG,IAAI,CAAC,QAAQ,EAAE;QACzBmB,EAAE,EAAEZ,MAAM;QACVa,IAAI,EAAE,IAAI,CAACrH,MAAM;QACjB0I,MAAM,EAAEjC,cAAc,CAAC6B;MACzB,CAAC,CAAC;MACFxE,OAAO,CAACqC,GAAG,CAAC,uBAAuBK,MAAM,EAAE,CAAC;IAC9C,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,0DAA0D,CAAC;MAC1E;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMiG,aAAaA,CAACpC,MAAM,EAAEkC,MAAM,EAAE;IAClC,IAAI;MACF5E,OAAO,CAACqC,GAAG,CAAC,6BAA6BK,MAAM,EAAE,CAAC;MAClD,MAAMC,cAAc,GAAG,IAAI,CAACrF,eAAe,CAAC4G,GAAG,CAACxB,MAAM,CAAC;MACvD,IAAIC,cAAc,EAAE;QAClB,MAAMA,cAAc,CAAC+B,oBAAoB,CAAC,IAAIC,qBAAqB,CAACC,MAAM,CAAC,CAAC;QAC5E5E,OAAO,CAACqC,GAAG,CAAC,mCAAmCK,MAAM,cAAc,CAAC;MACtE,CAAC,MAAM;QACL1C,OAAO,CAACD,KAAK,CAAC,gCAAgC2C,MAAM,uBAAuB,CAAC;MAC9E;IACF,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,mDAAmD,CAAC;MACnE;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMkG,mBAAmBA,CAACrC,MAAM,EAAEW,SAAS,EAAE;IAC3C,IAAI;MACFrD,OAAO,CAACqC,GAAG,CAAC,oCAAoCK,MAAM,EAAE,CAAC;MACzD,MAAMC,cAAc,GAAG,IAAI,CAACrF,eAAe,CAAC4G,GAAG,CAACxB,MAAM,CAAC;MACvD,IAAIC,cAAc,EAAE;QAClB,MAAMA,cAAc,CAACqC,eAAe,CAAC,IAAIC,eAAe,CAAC5B,SAAS,CAAC,CAAC;QACpErD,OAAO,CAACqC,GAAG,CAAC,6CAA6CK,MAAM,EAAE,CAAC;MACpE,CAAC,MAAM;QACL1C,OAAO,CAACC,IAAI,CAAC,4DAA4DyC,MAAM,EAAE,CAAC;MACpF;IACF,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;MACrD,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,mDAAmD,CAAC;MACnE;IACF;EACF;;EAEA;AACF;AACA;AACA;EACE8E,sBAAsBA,CAACjB,MAAM,EAAE;IAC7B,IAAI;MACF1C,OAAO,CAACqC,GAAG,CAAC,mCAAmCK,MAAM,EAAE,CAAC;MACxD,MAAMC,cAAc,GAAG,IAAI,CAACrF,eAAe,CAAC4G,GAAG,CAACxB,MAAM,CAAC;MACvD,IAAIC,cAAc,EAAE;QAClBA,cAAc,CAACQ,cAAc,GAAG,IAAI;QACpCR,cAAc,CAACiB,OAAO,GAAG,IAAI;QAC7BjB,cAAc,CAACa,uBAAuB,GAAG,IAAI;QAC7Cb,cAAc,CAACuC,KAAK,CAAC,CAAC;QACtB,IAAI,CAAC5H,eAAe,CAAC6H,MAAM,CAACzC,MAAM,CAAC;MACrC;;MAEA;MACA,MAAMxE,cAAc,GAAG,IAAI,CAACT,oBAAoB,CAACyG,GAAG,CAACxB,MAAM,CAAC;MAC5D,IAAIxE,cAAc,EAAE;QAClBA,cAAc,CAAC4D,IAAI,CAAC,CAAC;QACrB,IAAI,CAACrE,oBAAoB,CAAC0H,MAAM,CAACzC,MAAM,CAAC;MAC1C;MAEA1C,OAAO,CAACqC,GAAG,CAAC,uBAAuBK,MAAM,aAAa,CAAC;IACzD,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yCAAyC2C,MAAM,GAAG,EAAE3C,KAAK,CAAC;IAC1E;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMqF,kBAAkBA,CAAC1C,MAAM,EAAEyB,KAAK,EAAE;IACtC,IAAI;MACFnE,OAAO,CAACqC,GAAG,CAAC,gCAAgCK,MAAM,EAAE,CAAC;MACrD,MAAM,IAAI,CAAC+B,YAAY,CAAC/B,MAAM,EAAEyB,KAAK,CAAC;MACtC,OAAO,IAAI;IACb,CAAC,CAAC,OAAOpE,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,0CAA0C,CAAC;MAC1D;MACA,MAAMkB,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMsF,SAASA,CAAC3C,MAAM,EAAE;IACtB,IAAI;MACF,IAAI,CAAC,IAAI,CAAC/E,6BAA6B,EAAE;QACvC,MAAM,IAAI,CAAC0D,UAAU,CAAC,IAAI,CAAClE,MAAM,IAAI,SAAS,CAAC;MACjD;MAEA,IAAI,CAAC,IAAI,CAACC,WAAW,IAAI,CAAC,IAAI,CAACM,qBAAqB,EAAE;QACpD,MAAM,IAAIqD,KAAK,CAAC,2DAA2D,CAAC;MAC9E;;MAEA;MACA,MAAM4B,cAAc,GAAG,IAAI,CAACK,qBAAqB,CAACN,MAAM,EAAE,IAAI,CAAC;;MAE/D;MACA,IAAI,CAACtF,WAAW,CAACyE,SAAS,CAAC,CAAC,CAACtC,OAAO,CAACe,KAAK,IAAI;QAC5CqC,cAAc,CAACE,QAAQ,CAACvC,KAAK,EAAE,IAAI,CAAClD,WAAW,CAAC;MAClD,CAAC,CAAC;;MAEF;MACA,MAAM,IAAI,CAAC0F,mBAAmB,CAACJ,MAAM,CAAC;MAEtC,OAAOC,cAAc;IACvB,CAAC,CAAC,OAAO5C,KAAK,EAAE;MACd,IAAI,CAACX,YAAY,CAACW,KAAK,EAAE,sBAAsB,CAAC;MAChD,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMuF,YAAYA,CAAC5C,MAAM,EAAEkC,MAAM,EAAE;IACjC5E,OAAO,CAACqC,GAAG,CAAC,wBAAwBK,MAAM,mBAAmB,CAAC;IAC9D,OAAO,IAAI,CAACoC,aAAa,CAACpC,MAAM,EAAEkC,MAAM,CAAC;EAC3C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMI,eAAeA,CAACtC,MAAM,EAAEW,SAAS,EAAE;IACvCrD,OAAO,CAACqC,GAAG,CAAC,6BAA6BK,MAAM,mBAAmB,CAAC;IACnE,OAAO,IAAI,CAACqC,mBAAmB,CAACrC,MAAM,EAAEW,SAAS,CAAC;EACpD;;EAEA;AACF;AACA;EACEkC,SAASA,CAAA,EAAG;IACV;IACA,KAAK,MAAM7C,MAAM,IAAI,IAAI,CAACpF,eAAe,CAACkI,IAAI,CAAC,CAAC,EAAE;MAChD,IAAI,CAAC7B,sBAAsB,CAACjB,MAAM,CAAC;IACrC;;IAEA;IACA,IAAI,IAAI,CAACtF,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAACyE,SAAS,CAAC,CAAC,CAACtC,OAAO,CAACe,KAAK,IAAIA,KAAK,CAACwB,IAAI,CAAC,CAAC,CAAC;MAC3D,IAAI,CAAC1E,WAAW,GAAG,IAAI;IACzB;;IAEA;IACA,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACzB,IAAI,CAACA,gBAAgB,CAACwE,SAAS,CAAC,CAAC,CAACtC,OAAO,CAACe,KAAK,IAAIA,KAAK,CAACwB,IAAI,CAAC,CAAC,CAAC;MAChE,IAAI,CAACzE,gBAAgB,GAAG,IAAI;IAC9B;;IAEA;IACA,IAAI,IAAI,CAACG,gBAAgB,EAAE;MACzB,IAAI;QACF,IAAI,CAACA,gBAAgB,CAACsE,IAAI,CAAC,CAAC;MAC9B,CAAC,CAAC,OAAO/B,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MAC3D;IACF;;IAEA;IACA,IAAI,CAAC5C,MAAM,GAAG,IAAI;IAClB,IAAI,CAACG,eAAe,CAACmI,KAAK,CAAC,CAAC;IAC5B,IAAI,CAAChI,oBAAoB,CAACgI,KAAK,CAAC,CAAC;IACjC,IAAI,CAACjI,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACE,qBAAqB,GAAG,KAAK;IAClC,IAAI,CAACC,6BAA6B,GAAG,KAAK;IAC1C,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACC,yBAAyB,GAAG,KAAK;IACtC,IAAI,CAACC,sBAAsB,GAAG,KAAK;IACnC,IAAI,CAACC,YAAY,GAAG,KAAK;EAC3B;;EAEA;AACF;AACA;EACE0H,OAAOA,CAAA,EAAG;IACR1F,OAAO,CAACqC,GAAG,CAAC,0BAA0B,CAAC;IACvC,IAAI,CAACkD,SAAS,CAAC,CAAC;;IAEhB;IACA,IAAI,IAAI,CAACvJ,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAAC2J,GAAG,CAAC,YAAY,CAAC;MAC7B,IAAI,CAAC3J,MAAM,CAAC2J,GAAG,CAAC,UAAU,CAAC;MAC3B,IAAI,CAAC3J,MAAM,CAAC2J,GAAG,CAAC,OAAO,CAAC;MACxB,IAAI,CAAC3J,MAAM,CAAC2J,GAAG,CAAC,QAAQ,CAAC;MACzB,IAAI,CAAC3J,MAAM,CAAC2J,GAAG,CAAC,cAAc,CAAC;MAC/B,IAAI,CAAC3J,MAAM,CAAC2J,GAAG,CAAC,UAAU,CAAC;IAC7B;;IAEA;IACA,IAAI,IAAI,CAACzH,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAAC0H,cAAc,CAAC,CAAC;IACtC;IAEA5F,OAAO,CAACqC,GAAG,CAAC,yBAAyB,CAAC;EACxC;;EAEA;AACF;AACA;AACA;EACE,MAAMwD,WAAWA,CAAA,EAAG;IAClB,IAAI;MACF;MACA,IAAI,CAAC,IAAI,CAAChI,iBAAiB,EAAE;QAC3B,MAAMiI,WAAW,GAAG,MAAM,IAAI,CAACxD,mBAAmB,CAAC,IAAI,CAACnF,MAAM,CAAC;QAC/D,OAAO2I,WAAW;MACpB;;MAEA;MACA,IAAI,IAAI,CAACzI,gBAAgB,EAAE;QACzB,MAAM0I,WAAW,GAAG,IAAI,CAAC1I,gBAAgB,CAACuC,cAAc,CAAC,CAAC;QAC1D,IAAImG,WAAW,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK;QAE1C,MAAM1F,KAAK,GAAGyF,WAAW,CAAC,CAAC,CAAC;QAC5BzF,KAAK,CAAC2F,OAAO,GAAG,CAAC3F,KAAK,CAAC2F,OAAO;QAC9B,IAAI,CAACjI,YAAY,GAAGsC,KAAK,CAAC2F,OAAO;;QAEjC;QACA,IAAI,IAAI,CAAC/G,mBAAmB,EAAE;UAC5B,IAAI,CAACA,mBAAmB,CAAC,IAAI,CAAClB,YAAY,CAAC;QAC7C;QAEA,OAAO,IAAI,CAACA,YAAY;MAC1B;MAEA,OAAO,KAAK;IACd,CAAC,CAAC,OAAO+B,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;MAC7C,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMmG,YAAYA,CAACC,QAAQ,EAAE;IAC3B,IAAI;MACF,IAAI,CAAC,IAAI,CAACtI,iBAAiB,EAAE;QAC3B,OAAO,KAAK;MACd;;MAEA;MACA,IAAI,IAAI,CAACR,gBAAgB,EAAE;QACzB,IAAI,CAACA,gBAAgB,CAACuC,cAAc,CAAC,CAAC,CAACL,OAAO,CAACe,KAAK,IAAIA,KAAK,CAACwB,IAAI,CAAC,CAAC,CAAC;MACvE;;MAEA;MACA,MAAMjF,gBAAgB,GAAG;QACvB,GAAG,IAAI,CAACA,gBAAgB;QACxBsJ,QAAQ,EAAEA,QAAQ,GAAG;UAAEC,KAAK,EAAED;QAAS,CAAC,GAAGE;MAC7C,CAAC;MAED,MAAMC,cAAc,GAAG,MAAM7E,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAC/DH,KAAK,EAAE3E;MACT,CAAC,CAAC;;MAEF;MACA,IAAI,CAACQ,gBAAgB,GAAGiJ,cAAc;;MAEtC;MACA,IAAI,IAAI,CAACtH,YAAY,EAAE;QACrB,IAAI,CAACA,YAAY,CAACsH,cAAc,CAAC;MACnC;;MAEA;MACA,KAAK,MAAM,CAAC5D,MAAM,EAAEC,cAAc,CAAC,IAAI,IAAI,CAACrF,eAAe,CAACsF,OAAO,CAAC,CAAC,EAAE;QACrE,MAAM2D,OAAO,GAAG5D,cAAc,CAACxC,UAAU,CAAC,CAAC;QAC3C,MAAMqG,WAAW,GAAGD,OAAO,CAACnG,IAAI,CAACF,MAAM,IACrCA,MAAM,CAACI,KAAK,IAAIJ,MAAM,CAACI,KAAK,CAACC,IAAI,KAAK,OACxC,CAAC;QAED,IAAIiG,WAAW,EAAE;UACf,MAAMC,QAAQ,GAAGH,cAAc,CAAC1G,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;UACnD,MAAM4G,WAAW,CAACE,YAAY,CAACD,QAAQ,CAAC;QAC1C,CAAC,MAAM;UACL;UACAH,cAAc,CAAC1G,cAAc,CAAC,CAAC,CAACL,OAAO,CAACe,KAAK,IAAI;YAC/CqC,cAAc,CAACE,QAAQ,CAACvC,KAAK,EAAEgG,cAAc,CAAC;UAChD,CAAC,CAAC;;UAEF;UACA,MAAM,IAAI,CAACxD,mBAAmB,CAACJ,MAAM,CAAC;QACxC;MACF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAO3C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAM4G,eAAeA,CAAA,EAAG;IACtB,IAAI;MACF,MAAMC,OAAO,GAAG,MAAMnF,SAAS,CAACC,YAAY,CAACmF,gBAAgB,CAAC,CAAC;MAC/D,OAAOD,OAAO,CAACE,MAAM,CAACC,MAAM,IAAIA,MAAM,CAACxG,IAAI,KAAK,YAAY,CAAC;IAC/D,CAAC,CAAC,OAAOR,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,EAAE;IACX;EACF;;EAEA;AACF;AACA;AACA;EACEiH,eAAeA,CAAA,EAAG;IAChB,IAAI,CAAC,IAAI,CAAC3J,gBAAgB,EAAE,OAAO,KAAK;IAExC,MAAM0I,WAAW,GAAG,IAAI,CAAC1I,gBAAgB,CAACuC,cAAc,CAAC,CAAC;IAC1D,IAAImG,WAAW,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK;IAE1C,OAAOD,WAAW,CAAC,CAAC,CAAC,CAACE,OAAO;EAC/B;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMgB,eAAeA,CAACC,QAAQ,EAAE;IAC9B,IAAI;MACF,MAAM7H,eAAe,GAAG,IAAI,CAACnB,cAAc,CAACiJ,UAAU,CAACD,QAAQ,CAAC;MAChE,IAAI,CAACjJ,mBAAmB,GAAGiJ,QAAQ;MACnC,OAAO,IAAI;IACb,CAAC,CAAC,OAAOnH,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,IAAI,IAAI,CAAClB,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAAC,gCAAgCkB,KAAK,CAACiB,OAAO,EAAE,CAAC;MAC/D;MACA,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACEoG,sBAAsBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAACnJ,mBAAmB;EACjC;;EAEA;AACF;AACA;AACA;EACEoJ,iBAAiBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACnJ,cAAc,CAACmJ,iBAAiB,CAAC,CAAC;EAChD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}