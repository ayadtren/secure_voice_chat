{"ast":null,"code":"import{createEnhancedAudioStream,SpeakingDetector,AudioQualityMonitor}from'./audioProcessor';/**\n * WebRTC Connection Manager\n * \n * Manages WebRTC peer connections with enhanced audio processing,\n * connection resilience, and adaptive bitrate streaming.\n */export class WebRTCManager{constructor(socket){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.socket=socket;this.peerConnections=new Map();// Map of peer ID to RTCPeerConnection\nthis.localStream=null;this.roomId=null;this.userId=options.userId||`user_${Math.random().toString(36).substr(2,9)}`;this.speakingDetector=null;this.audioQualityMonitors=new Map();// Configuration\nthis.config={iceServers:options.iceServers||[{urls:'stun:stun.l.google.com:19302'},{urls:'stun:stun1.l.google.com:19302'}],iceTransportPolicy:options.iceTransportPolicy||'all',sdpSemantics:'unified-plan',// Enable DTLS-SRTP for end-to-end encryption\n// This is enabled by default in modern browsers\n// but we explicitly set it for clarity\nrtcpMuxPolicy:'require'};// Audio constraints\nthis.audioConstraints={echoCancellation:true,noiseSuppression:true,autoGainControl:true,// Prioritize voice clarity\nchannelCount:1,sampleRate:48000,sampleSize:16};// Event callbacks\nthis.onPeerConnect=options.onPeerConnect||null;this.onPeerDisconnect=options.onPeerDisconnect||null;this.onSpeakingChange=options.onSpeakingChange||null;this.onAudioQualityChange=options.onAudioQualityChange||null;this.onError=options.onError||null;}/**\n   * Initialize WebRTC with local audio stream\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */async initialize(roomId){try{// Store room ID\nthis.roomId=roomId;// Get user media with enhanced audio settings\nthis.localStream=await navigator.mediaDevices.getUserMedia({audio:this.audioConstraints,video:false});// Create speaking detector\nthis.speakingDetector=new SpeakingDetector(this.localStream,{onSpeakingChange:speaking=>{if(this.onSpeakingChange){this.onSpeakingChange(speaking);}// Emit speaking status to other users\nif(this.socket&&this.socket.connected){this.socket.emit('speaking',{roomId:this.roomId,speaking});}}});this.speakingDetector.start();// Bind socket events\nthis._bindSocketEvents();return true;}catch(error){console.error('Failed to initialize WebRTC:',error);if(this.onError){this.onError('Failed to access microphone. Please check your permissions.');}throw error;}}/**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */_createPeerConnection(peerId){let isInitiator=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{// Create new peer connection\nconst peerConnection=new RTCPeerConnection(this.config);// Add local stream tracks to peer connection\nif(this.localStream){this.localStream.getTracks().forEach(track=>{peerConnection.addTrack(track,this.localStream);});}// Handle ICE candidates\npeerConnection.onicecandidate=event=>{if(event.candidate){this.socket.emit('iceCandidate',{roomId:this.roomId,to:peerId,from:this.userId,candidate:event.candidate});}};// Handle connection state changes\npeerConnection.onconnectionstatechange=()=>{switch(peerConnection.connectionState){case'connected':console.log(`Connected to peer: ${peerId}`);if(this.onPeerConnect){this.onPeerConnect(peerId);}break;case'disconnected':case'failed':case'closed':console.log(`Disconnected from peer: ${peerId}`);if(this.onPeerDisconnect){this.onPeerDisconnect(peerId);}this._cleanupPeerConnection(peerId);break;default:console.log(`Connection state changed to: ${peerConnection.connectionState}`);break;}};// Handle incoming tracks\npeerConnection.ontrack=event=>{const stream=event.streams[0];// Store remote stream and create audio element\nif(stream){// Create audio quality monitor\nconst qualityMonitor=new AudioQualityMonitor(peerConnection,{onQualityChange:(quality,metrics)=>{if(this.onAudioQualityChange){this.onAudioQualityChange(peerId,quality,metrics);}}});qualityMonitor.start();this.audioQualityMonitors.set(peerId,qualityMonitor);// Notify about the new stream\nif(this.onPeerConnect){this.onPeerConnect(peerId,stream);}}};// Store peer connection\nthis.peerConnections.set(peerId,peerConnection);// If initiator, create and send offer\nif(isInitiator){this._createAndSendOffer(peerId);}return peerConnection;}catch(error){console.error('Error creating peer connection:',error);if(this.onError){this.onError('Failed to create connection. Please try again.');}return null;}}/**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */async _createAndSendOffer(peerId){try{const peerConnection=this.peerConnections.get(peerId);if(!peerConnection)return;// Create offer with audio preferences\nconst offer=await peerConnection.createOffer({offerToReceiveAudio:true,offerToReceiveVideo:false});// Set local description\nawait peerConnection.setLocalDescription(offer);// Send offer to peer\nthis.socket.emit('offer',{roomId:this.roomId,to:peerId,from:this.userId,offer:peerConnection.localDescription});}catch(error){console.error('Error creating offer:',error);if(this.onError){this.onError('Failed to create connection offer. Please try again.');}}}/**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */async _handleOffer(peerId,offer){try{// Get or create peer connection\nlet peerConnection=this.peerConnections.get(peerId);if(!peerConnection){peerConnection=this._createPeerConnection(peerId);}// Set remote description\nawait peerConnection.setRemoteDescription(new RTCSessionDescription(offer));// Create answer\nconst answer=await peerConnection.createAnswer();// Set local description\nawait peerConnection.setLocalDescription(answer);// Send answer to peer\nthis.socket.emit('answer',{roomId:this.roomId,to:peerId,from:this.userId,answer:peerConnection.localDescription});}catch(error){console.error('Error handling offer:',error);if(this.onError){this.onError('Failed to process incoming connection. Please try again.');}}}/**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   */async _handleAnswer(peerId,answer){try{const peerConnection=this.peerConnections.get(peerId);if(peerConnection){await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));}}catch(error){console.error('Error handling answer:',error);if(this.onError){this.onError('Failed to establish connection. Please try again.');}}}/**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   */async _handleIceCandidate(peerId,candidate){try{const peerConnection=this.peerConnections.get(peerId);if(peerConnection){await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));console.log('Successfully added ICE candidate');}else{console.warn('Received ICE candidate for non-existent peer connection');}}catch(error){console.error('Error handling ICE candidate:',error);if(this.onError){this.onError('Failed to establish connection. Please try again.');}}}/**\n   * Accept an incoming call\n   * @param {string} peerId - ID of the peer who initiated the call\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<void>}\n   */async acceptIncomingCall(peerId,offer){try{await this._handleOffer(peerId,offer);return true;}catch(error){console.error('Error accepting call:',error);if(this.onError){this.onError('Failed to accept call. Please try again.');}throw error;}}/**\n   * Handle an answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */async handleAnswer(peerId,answer){return this._handleAnswer(peerId,answer);}/**\n   * Add an ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */async addIceCandidate(peerId,candidate){return this._handleIceCandidate(peerId,candidate);}/**\n   * Bind socket event handlers\n   */_bindSocketEvents(){// We don't need to bind socket events here since we're handling them in App.js\n// This method is kept for future enhancements\n}/**\n   * Clean up peer connection\n   * @param {string} peerId - ID of the peer to clean up\n   */_cleanupPeerConnection(peerId){// Clean up quality monitor\nconst qualityMonitor=this.audioQualityMonitors.get(peerId);if(qualityMonitor){qualityMonitor.dispose();this.audioQualityMonitors.delete(peerId);}// Clean up peer connection\nconst peerConnection=this.peerConnections.get(peerId);if(peerConnection){peerConnection.onicecandidate=null;peerConnection.ontrack=null;peerConnection.onconnectionstatechange=null;// Close connection\npeerConnection.close();this.peerConnections.delete(peerId);}}/**\n   * Mute or unmute local audio\n   * @param {boolean} muted - Whether to mute audio\n   */setMuted(muted){if(this.localStream){this.localStream.getAudioTracks().forEach(track=>{track.enabled=!muted;});}}/**\n   * Check if local audio is muted\n   * @returns {boolean} Whether local audio is muted\n   */isMuted(){if(this.localStream){const audioTracks=this.localStream.getAudioTracks();if(audioTracks.length>0){return!audioTracks[0].enabled;}}return true;}/**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */getAudioLevel(){if(this.speakingDetector){return this.speakingDetector.getAudioLevel();}return 0;}/**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */async getConnectionQuality(peerId){const qualityMonitor=this.audioQualityMonitors.get(peerId);if(qualityMonitor){return await qualityMonitor.getQualityMetrics();}return{quality:'unknown',metrics:{}};}/**\n   * Leave the room and clean up all connections\n   */leaveRoom(){// Stop speaking detector\nif(this.speakingDetector){this.speakingDetector.dispose();this.speakingDetector=null;}// Clean up all peer connections\nfor(const peerId of this.peerConnections.keys()){this._cleanupPeerConnection(peerId);}// Stop local stream tracks\nif(this.localStream){this.localStream.getTracks().forEach(track=>{track.stop();});this.localStream=null;}// Leave room via socket\nif(this.socket&&this.socket.connected){this.socket.emit('leave',{roomId:this.roomId,userId:this.userId});}this.roomId=null;}/**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<void>}\n   */async startCall(peerId){try{// Create peer connection if it doesn't exist\nlet peerConnection=this.peerConnections.get(peerId);if(!peerConnection){peerConnection=this._createPeerConnection(peerId,true);}else{// If connection exists but we need to initiate a call\nthis._createAndSendOffer(peerId);}return peerConnection;}catch(error){console.error('Error starting call:',error);if(this.onError){this.onError('Failed to start call. Please try again.');}throw error;}}/**\n   * Dispose of all resources\n   */dispose(){this.leaveRoom();// Unbind socket events\nif(this.socket){this.socket.off('userJoined');this.socket.off('userLeft');this.socket.off('offer');this.socket.off('answer');this.socket.off('iceCandidate');this.socket.off('speaking');}}}","map":{"version":3,"names":["createEnhancedAudioStream","SpeakingDetector","AudioQualityMonitor","WebRTCManager","constructor","socket","options","arguments","length","undefined","peerConnections","Map","localStream","roomId","userId","Math","random","toString","substr","speakingDetector","audioQualityMonitors","config","iceServers","urls","iceTransportPolicy","sdpSemantics","rtcpMuxPolicy","audioConstraints","echoCancellation","noiseSuppression","autoGainControl","channelCount","sampleRate","sampleSize","onPeerConnect","onPeerDisconnect","onSpeakingChange","onAudioQualityChange","onError","initialize","navigator","mediaDevices","getUserMedia","audio","video","speaking","connected","emit","start","_bindSocketEvents","error","console","_createPeerConnection","peerId","isInitiator","peerConnection","RTCPeerConnection","getTracks","forEach","track","addTrack","onicecandidate","event","candidate","to","from","onconnectionstatechange","connectionState","log","_cleanupPeerConnection","ontrack","stream","streams","qualityMonitor","onQualityChange","quality","metrics","set","_createAndSendOffer","get","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","localDescription","_handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","_handleAnswer","_handleIceCandidate","addIceCandidate","RTCIceCandidate","warn","acceptIncomingCall","handleAnswer","dispose","delete","close","setMuted","muted","getAudioTracks","enabled","isMuted","audioTracks","getAudioLevel","getConnectionQuality","getQualityMetrics","leaveRoom","keys","stop","startCall","off"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/webrtcManager.js"],"sourcesContent":["import { createEnhancedAudioStream, SpeakingDetector, AudioQualityMonitor } from './audioProcessor';\n\n/**\n * WebRTC Connection Manager\n * \n * Manages WebRTC peer connections with enhanced audio processing,\n * connection resilience, and adaptive bitrate streaming.\n */\nexport class WebRTCManager {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.peerConnections = new Map(); // Map of peer ID to RTCPeerConnection\n    this.localStream = null;\n    this.roomId = null;\n    this.userId = options.userId || `user_${Math.random().toString(36).substr(2, 9)}`;\n    this.speakingDetector = null;\n    this.audioQualityMonitors = new Map();\n    \n    // Configuration\n    this.config = {\n      iceServers: options.iceServers || [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n      ],\n      iceTransportPolicy: options.iceTransportPolicy || 'all',\n      sdpSemantics: 'unified-plan',\n      // Enable DTLS-SRTP for end-to-end encryption\n      // This is enabled by default in modern browsers\n      // but we explicitly set it for clarity\n      rtcpMuxPolicy: 'require',\n    };\n    \n    // Audio constraints\n    this.audioConstraints = {\n      echoCancellation: true,\n      noiseSuppression: true,\n      autoGainControl: true,\n      // Prioritize voice clarity\n      channelCount: 1,\n      sampleRate: 48000,\n      sampleSize: 16,\n    };\n    \n    // Event callbacks\n    this.onPeerConnect = options.onPeerConnect || null;\n    this.onPeerDisconnect = options.onPeerDisconnect || null;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    this.onAudioQualityChange = options.onAudioQualityChange || null;\n    this.onError = options.onError || null;\n  }\n  \n  /**\n   * Initialize WebRTC with local audio stream\n   * @param {string} roomId - ID of the room to join\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize(roomId) {\n    try {\n      // Store room ID\n      this.roomId = roomId;\n      \n      // Get user media with enhanced audio settings\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioConstraints,\n        video: false\n      });\n      \n      // Create speaking detector\n      this.speakingDetector = new SpeakingDetector(this.localStream, {\n        onSpeakingChange: (speaking) => {\n          if (this.onSpeakingChange) {\n            this.onSpeakingChange(speaking);\n          }\n          \n          // Emit speaking status to other users\n          if (this.socket && this.socket.connected) {\n            this.socket.emit('speaking', {\n              roomId: this.roomId,\n              speaking\n            });\n          }\n        }\n      });\n      this.speakingDetector.start();\n      \n      // Bind socket events\n      this._bindSocketEvents();\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to initialize WebRTC:', error);\n      if (this.onError) {\n        this.onError('Failed to access microphone. Please check your permissions.');\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a new peer connection for a user\n   * @param {string} peerId - ID of the peer to connect to\n   * @param {boolean} isInitiator - Whether this peer is initiating the connection\n   * @returns {RTCPeerConnection} The created peer connection\n   */\n  _createPeerConnection(peerId, isInitiator = false) {\n    try {\n      // Create new peer connection\n      const peerConnection = new RTCPeerConnection(this.config);\n      \n      // Add local stream tracks to peer connection\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(track => {\n          peerConnection.addTrack(track, this.localStream);\n        });\n      }\n      \n      // Handle ICE candidates\n      peerConnection.onicecandidate = (event) => {\n        if (event.candidate) {\n          this.socket.emit('iceCandidate', {\n            roomId: this.roomId,\n            to: peerId,\n            from: this.userId,\n            candidate: event.candidate,\n          });\n        }\n      };\n      \n      // Handle connection state changes\n      peerConnection.onconnectionstatechange = () => {\n        switch (peerConnection.connectionState) {\n          case 'connected':\n            console.log(`Connected to peer: ${peerId}`);\n            if (this.onPeerConnect) {\n              this.onPeerConnect(peerId);\n            }\n            break;\n          case 'disconnected':\n          case 'failed':\n          case 'closed':\n            console.log(`Disconnected from peer: ${peerId}`);\n            if (this.onPeerDisconnect) {\n              this.onPeerDisconnect(peerId);\n            }\n            this._cleanupPeerConnection(peerId);\n            break;\n          default:\n            console.log(`Connection state changed to: ${peerConnection.connectionState}`);\n            break;\n        }\n      };\n      \n      // Handle incoming tracks\n      peerConnection.ontrack = (event) => {\n        const stream = event.streams[0];\n        // Store remote stream and create audio element\n        if (stream) {\n          // Create audio quality monitor\n          const qualityMonitor = new AudioQualityMonitor(peerConnection, {\n            onQualityChange: (quality, metrics) => {\n              if (this.onAudioQualityChange) {\n                this.onAudioQualityChange(peerId, quality, metrics);\n              }\n            }\n          });\n          qualityMonitor.start();\n          this.audioQualityMonitors.set(peerId, qualityMonitor);\n          \n          // Notify about the new stream\n          if (this.onPeerConnect) {\n            this.onPeerConnect(peerId, stream);\n          }\n        }\n      };\n      \n      // Store peer connection\n      this.peerConnections.set(peerId, peerConnection);\n      \n      // If initiator, create and send offer\n      if (isInitiator) {\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error creating peer connection:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection. Please try again.');\n      }\n      return null;\n    }\n  }\n  \n  /**\n   * Create and send an offer to a peer\n   * @param {string} peerId - ID of the peer to send offer to\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */\n  async _createAndSendOffer(peerId) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) return;\n      \n      // Create offer with audio preferences\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false,\n      });\n      \n      // Set local description\n      await peerConnection.setLocalDescription(offer);\n      \n      // Send offer to peer\n      this.socket.emit('offer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        offer: peerConnection.localDescription,\n      });\n    } catch (error) {\n      console.error('Error creating offer:', error);\n      if (this.onError) {\n        this.onError('Failed to create connection offer. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming offer from a peer\n   * @param {string} peerId - ID of the peer who sent the offer\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   */\n  async _handleOffer(peerId, offer) {\n    try {\n      // Get or create peer connection\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        peerConnection = this._createPeerConnection(peerId);\n      }\n      \n      // Set remote description\n      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n      \n      // Create answer\n      const answer = await peerConnection.createAnswer();\n      \n      // Set local description\n      await peerConnection.setLocalDescription(answer);\n      \n      // Send answer to peer\n      this.socket.emit('answer', {\n        roomId: this.roomId,\n        to: peerId,\n        from: this.userId,\n        answer: peerConnection.localDescription,\n      });\n    } catch (error) {\n      console.error('Error handling offer:', error);\n      if (this.onError) {\n        this.onError('Failed to process incoming connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   */\n  async _handleAnswer(peerId, answer) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Handle incoming ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   */\n  async _handleIceCandidate(peerId, candidate) {\n    try {\n      const peerConnection = this.peerConnections.get(peerId);\n      if (peerConnection) {\n        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        console.log('Successfully added ICE candidate');\n      } else {\n        console.warn('Received ICE candidate for non-existent peer connection');\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n      if (this.onError) {\n        this.onError('Failed to establish connection. Please try again.');\n      }\n    }\n  }\n  \n  /**\n   * Accept an incoming call\n   * @param {string} peerId - ID of the peer who initiated the call\n   * @param {RTCSessionDescription} offer - The offer from the peer\n   * @returns {Promise<void>}\n   */\n  async acceptIncomingCall(peerId, offer) {\n    try {\n      await this._handleOffer(peerId, offer);\n      return true;\n    } catch (error) {\n      console.error('Error accepting call:', error);\n      if (this.onError) {\n        this.onError('Failed to accept call. Please try again.');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Handle an answer from a peer\n   * @param {string} peerId - ID of the peer who sent the answer\n   * @param {RTCSessionDescription} answer - The answer from the peer\n   * @returns {Promise<void>}\n   */\n  async handleAnswer(peerId, answer) {\n    return this._handleAnswer(peerId, answer);\n  }\n\n  /**\n   * Add an ICE candidate from a peer\n   * @param {string} peerId - ID of the peer who sent the ICE candidate\n   * @param {RTCIceCandidate} candidate - The ICE candidate\n   * @returns {Promise<void>}\n   */\n  async addIceCandidate(peerId, candidate) {\n    return this._handleIceCandidate(peerId, candidate);\n  }\n  \n  /**\n   * Bind socket event handlers\n   */\n  _bindSocketEvents() {\n    // We don't need to bind socket events here since we're handling them in App.js\n    // This method is kept for future enhancements\n  }\n  \n  /**\n   * Clean up peer connection\n   * @param {string} peerId - ID of the peer to clean up\n   */\n  _cleanupPeerConnection(peerId) {\n    // Clean up quality monitor\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      qualityMonitor.dispose();\n      this.audioQualityMonitors.delete(peerId);\n    }\n    \n    // Clean up peer connection\n    const peerConnection = this.peerConnections.get(peerId);\n    if (peerConnection) {\n      peerConnection.onicecandidate = null;\n      peerConnection.ontrack = null;\n      peerConnection.onconnectionstatechange = null;\n      \n      // Close connection\n      peerConnection.close();\n      this.peerConnections.delete(peerId);\n    }\n  }\n  \n  /**\n   * Mute or unmute local audio\n   * @param {boolean} muted - Whether to mute audio\n   */\n  setMuted(muted) {\n    if (this.localStream) {\n      this.localStream.getAudioTracks().forEach(track => {\n        track.enabled = !muted;\n      });\n    }\n  }\n  \n  /**\n   * Check if local audio is muted\n   * @returns {boolean} Whether local audio is muted\n   */\n  isMuted() {\n    if (this.localStream) {\n      const audioTracks = this.localStream.getAudioTracks();\n      if (audioTracks.length > 0) {\n        return !audioTracks[0].enabled;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (this.speakingDetector) {\n      return this.speakingDetector.getAudioLevel();\n    }\n    return 0;\n  }\n  \n  /**\n   * Get connection quality for a peer\n   * @param {string} peerId - ID of the peer\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getConnectionQuality(peerId) {\n    const qualityMonitor = this.audioQualityMonitors.get(peerId);\n    if (qualityMonitor) {\n      return await qualityMonitor.getQualityMetrics();\n    }\n    return { quality: 'unknown', metrics: {} };\n  }\n  \n  /**\n   * Leave the room and clean up all connections\n   */\n  leaveRoom() {\n    // Stop speaking detector\n    if (this.speakingDetector) {\n      this.speakingDetector.dispose();\n      this.speakingDetector = null;\n    }\n    \n    // Clean up all peer connections\n    for (const peerId of this.peerConnections.keys()) {\n      this._cleanupPeerConnection(peerId);\n    }\n    \n    // Stop local stream tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => {\n        track.stop();\n      });\n      this.localStream = null;\n    }\n    \n    // Leave room via socket\n    if (this.socket && this.socket.connected) {\n      this.socket.emit('leave', {\n        roomId: this.roomId,\n        userId: this.userId,\n      });\n    }\n    \n    this.roomId = null;\n  }\n  \n  /**\n   * Start a call with a specific peer\n   * @param {string} peerId - ID of the peer to call\n   * @returns {Promise<void>}\n   */\n  async startCall(peerId) {\n    try {\n      // Create peer connection if it doesn't exist\n      let peerConnection = this.peerConnections.get(peerId);\n      if (!peerConnection) {\n        peerConnection = this._createPeerConnection(peerId, true);\n      } else {\n        // If connection exists but we need to initiate a call\n        this._createAndSendOffer(peerId);\n      }\n      \n      return peerConnection;\n    } catch (error) {\n      console.error('Error starting call:', error);\n      if (this.onError) {\n        this.onError('Failed to start call. Please try again.');\n      }\n      throw error;\n    }\n  }\n  \n  /**\n   * Dispose of all resources\n   */\n  dispose() {\n    this.leaveRoom();\n    \n    // Unbind socket events\n    if (this.socket) {\n      this.socket.off('userJoined');\n      this.socket.off('userLeft');\n      this.socket.off('offer');\n      this.socket.off('answer');\n      this.socket.off('iceCandidate');\n      this.socket.off('speaking');\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}