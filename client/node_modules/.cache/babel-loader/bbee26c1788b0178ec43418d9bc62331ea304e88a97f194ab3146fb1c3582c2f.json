{"ast":null,"code":"/**\n * Advanced Audio Processing Utility\n * \n * Provides enhanced audio processing capabilities for WebRTC voice chat:\n * - Noise suppression\n * - Echo cancellation\n * - Volume normalization\n * - Speaking detection\n * - Audio quality monitoring\n *//**\n * Creates an enhanced audio stream with noise suppression and echo cancellation\n * @param {MediaStream} originalStream - The original audio stream from getUserMedia\n * @returns {Promise<MediaStream>} - Enhanced audio stream\n */export async function createEnhancedAudioStream(originalStream){try{// Check if browser supports advanced audio processing\nconst supportsAudioWorklet='AudioWorklet'in window.AudioContext.prototype;// Create audio context\nconst audioContext=new(window.AudioContext||window.webkitAudioContext)();// Get audio track from original stream\nconst audioTrack=originalStream.getAudioTracks()[0];if(!audioTrack){console.warn('No audio track found in the stream');return originalStream;}// Create source from the original audio track\nconst source=audioContext.createMediaStreamSource(originalStream);// Create destination for processed audio\nconst destination=audioContext.createMediaStreamDestination();// Apply audio constraints for echo cancellation and noise suppression\n// Note: These constraints work in conjunction with getUserMedia constraints\ntry{await audioTrack.applyConstraints({echoCancellation:true,noiseSuppression:true,autoGainControl:true});}catch(err){console.warn('Could not apply audio constraints:',err);}// If browser supports AudioWorklet, use it for advanced processing\nif(supportsAudioWorklet){try{// Create gain node for volume control\nconst gainNode=audioContext.createGain();gainNode.gain.value=1.0;// Default gain\n// Connect the audio processing chain\nsource.connect(gainNode);gainNode.connect(destination);console.log('Enhanced audio stream created with AudioWorklet support');}catch(err){console.warn('Error setting up AudioWorklet processing:',err);// Fallback: direct connection\nsource.connect(destination);}}else{// Fallback for browsers without AudioWorklet support\nconsole.log('AudioWorklet not supported, using basic audio processing');source.connect(destination);}// Return the processed stream\nreturn destination.stream;}catch(error){console.error('Error creating enhanced audio stream:',error);// Return original stream as fallback\nreturn originalStream;}}/**\n * Audio level detector for speaking indication\n */export class SpeakingDetector{constructor(stream){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.audioContext=new(window.AudioContext||window.webkitAudioContext)();this.stream=stream;this.source=this.audioContext.createMediaStreamSource(stream);this.analyser=this.audioContext.createAnalyser();// Configure analyser\nthis.analyser.fftSize=256;this.analyser.smoothingTimeConstant=0.5;this.bufferLength=this.analyser.frequencyBinCount;this.dataArray=new Uint8Array(this.bufferLength);// Connect source to analyser\nthis.source.connect(this.analyser);// Speaking detection configuration\nthis.threshold=options.threshold||20;// Default threshold\nthis.speakingHistory=[];this.historyLength=options.historyLength||5;this.speaking=false;this.onSpeakingChange=options.onSpeakingChange||null;// Start detection\nthis.isRunning=false;}/**\n   * Start the speaking detection\n   */start(){if(this.isRunning)return;this.isRunning=true;this.detectSpeaking();}/**\n   * Stop the speaking detection\n   */stop(){this.isRunning=false;if(this.animationFrame){cancelAnimationFrame(this.animationFrame);this.animationFrame=null;}}/**\n   * Main detection loop\n   */detectSpeaking(){if(!this.isRunning)return;this.analyser.getByteFrequencyData(this.dataArray);// Calculate average volume\nlet sum=0;for(let i=0;i<this.bufferLength;i++){sum+=this.dataArray[i];}const average=sum/this.bufferLength;// Add to history\nthis.speakingHistory.push(average);if(this.speakingHistory.length>this.historyLength){this.speakingHistory.shift();}// Calculate average from history to reduce false positives\nconst historyAverage=this.speakingHistory.reduce((a,b)=>a+b,0)/this.speakingHistory.length;// Determine if speaking\nconst isSpeaking=historyAverage>this.threshold;// Notify if speaking state changed\nif(isSpeaking!==this.speaking){this.speaking=isSpeaking;if(this.onSpeakingChange){this.onSpeakingChange(this.speaking);}}// Continue detection loop\nthis.animationFrame=requestAnimationFrame(this.detectSpeaking.bind(this));}/**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */getAudioLevel(){if(!this.isRunning)return 0;this.analyser.getByteFrequencyData(this.dataArray);// Calculate average volume\nlet sum=0;for(let i=0;i<this.bufferLength;i++){sum+=this.dataArray[i];}const average=sum/this.bufferLength;// Convert to 0-100 scale\nreturn Math.min(100,Math.max(0,average*(100/256)));}/**\n   * Set speaking detection threshold\n   * @param {number} threshold - New threshold value (0-100)\n   */setThreshold(threshold){this.threshold=Math.min(100,Math.max(0,threshold));}/**\n   * Clean up resources\n   */dispose(){this.stop();if(this.source){this.source.disconnect();}}}/**\n * Audio quality monitor for adaptive streaming\n */export class AudioQualityMonitor{constructor(peerConnection){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};this.peerConnection=peerConnection;this.interval=options.interval||2000;// Check interval in ms\nthis.onQualityChange=options.onQualityChange||null;this.qualityThresholds={excellent:{packetLoss:0.01,jitter:10},good:{packetLoss:0.03,jitter:30},fair:{packetLoss:0.08,jitter:50},poor:{packetLoss:0.15,jitter:100}// Anything worse is considered \"bad\"\n};this.currentQuality='unknown';this.intervalId=null;}/**\n   * Start monitoring audio quality\n   */start(){if(this.intervalId)return;this.intervalId=setInterval(()=>this.checkQuality(),this.interval);}/**\n   * Stop monitoring audio quality\n   */stop(){if(this.intervalId){clearInterval(this.intervalId);this.intervalId=null;}}/**\n   * Check current audio quality\n   */async checkQuality(){if(!this.peerConnection)return;try{const stats=await this.peerConnection.getStats();let audioInboundStats=null;// Find audio inbound-rtp stats\nstats.forEach(stat=>{if(stat.type==='inbound-rtp'&&stat.kind==='audio'){audioInboundStats=stat;}});if(!audioInboundStats)return;// Calculate packet loss\nconst packetsLost=audioInboundStats.packetsLost||0;const packetsReceived=audioInboundStats.packetsReceived||1;// Avoid division by zero\nconst packetLossRate=packetsLost/(packetsLost+packetsReceived);// Get jitter (in milliseconds)\nconst jitter=(audioInboundStats.jitter||0)*1000;// Determine quality level\nlet quality='bad';if(packetLossRate<=this.qualityThresholds.excellent.packetLoss&&jitter<=this.qualityThresholds.excellent.jitter){quality='excellent';}else if(packetLossRate<=this.qualityThresholds.good.packetLoss&&jitter<=this.qualityThresholds.good.jitter){quality='good';}else if(packetLossRate<=this.qualityThresholds.fair.packetLoss&&jitter<=this.qualityThresholds.fair.jitter){quality='fair';}else if(packetLossRate<=this.qualityThresholds.poor.packetLoss&&jitter<=this.qualityThresholds.poor.jitter){quality='poor';}// Notify if quality changed\nif(quality!==this.currentQuality){this.currentQuality=quality;if(this.onQualityChange){this.onQualityChange(quality,{packetLossRate,jitter});}}}catch(error){console.error('Error checking audio quality:',error);}}/**\n   * Get current quality metrics\n   * @returns {Promise<Object>} Quality metrics\n   */async getQualityMetrics(){if(!this.peerConnection){return{quality:'unknown',metrics:{}};}try{const stats=await this.peerConnection.getStats();let audioInboundStats=null;let audioOutboundStats=null;// Find audio stats\nstats.forEach(stat=>{if(stat.type==='inbound-rtp'&&stat.kind==='audio'){audioInboundStats=stat;}if(stat.type==='outbound-rtp'&&stat.kind==='audio'){audioOutboundStats=stat;}});const metrics={inbound:audioInboundStats?{packetsReceived:audioInboundStats.packetsReceived||0,packetsLost:audioInboundStats.packetsLost||0,jitter:(audioInboundStats.jitter||0)*1000,// ms\nbytesReceived:audioInboundStats.bytesReceived||0}:null,outbound:audioOutboundStats?{packetsSent:audioOutboundStats.packetsSent||0,bytesSent:audioOutboundStats.bytesSent||0}:null,quality:this.currentQuality};return metrics;}catch(error){console.error('Error getting quality metrics:',error);return{quality:'unknown',metrics:{}};}}/**\n   * Clean up resources\n   */dispose(){this.stop();this.peerConnection=null;}}","map":{"version":3,"names":["createEnhancedAudioStream","originalStream","supportsAudioWorklet","window","AudioContext","prototype","audioContext","webkitAudioContext","audioTrack","getAudioTracks","console","warn","source","createMediaStreamSource","destination","createMediaStreamDestination","applyConstraints","echoCancellation","noiseSuppression","autoGainControl","err","gainNode","createGain","gain","value","connect","log","stream","error","SpeakingDetector","constructor","options","arguments","length","undefined","analyser","createAnalyser","fftSize","smoothingTimeConstant","bufferLength","frequencyBinCount","dataArray","Uint8Array","threshold","speakingHistory","historyLength","speaking","onSpeakingChange","isRunning","start","detectSpeaking","stop","animationFrame","cancelAnimationFrame","getByteFrequencyData","sum","i","average","push","shift","historyAverage","reduce","a","b","isSpeaking","requestAnimationFrame","bind","getAudioLevel","Math","min","max","setThreshold","dispose","disconnect","AudioQualityMonitor","peerConnection","interval","onQualityChange","qualityThresholds","excellent","packetLoss","jitter","good","fair","poor","currentQuality","intervalId","setInterval","checkQuality","clearInterval","stats","getStats","audioInboundStats","forEach","stat","type","kind","packetsLost","packetsReceived","packetLossRate","quality","getQualityMetrics","metrics","audioOutboundStats","inbound","bytesReceived","outbound","packetsSent","bytesSent"],"sources":["/Users/ayadyousifshahi/Documents/webchat app/client/src/utils/audioProcessor.js"],"sourcesContent":["/**\n * Advanced Audio Processing Utility\n * \n * Provides enhanced audio processing capabilities for WebRTC voice chat:\n * - Noise suppression\n * - Echo cancellation\n * - Volume normalization\n * - Speaking detection\n * - Audio quality monitoring\n */\n\n/**\n * Creates an enhanced audio stream with noise suppression and echo cancellation\n * @param {MediaStream} originalStream - The original audio stream from getUserMedia\n * @returns {Promise<MediaStream>} - Enhanced audio stream\n */\nexport async function createEnhancedAudioStream(originalStream) {\n  try {\n    // Check if browser supports advanced audio processing\n    const supportsAudioWorklet = 'AudioWorklet' in window.AudioContext.prototype;\n    \n    // Create audio context\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    \n    // Get audio track from original stream\n    const audioTrack = originalStream.getAudioTracks()[0];\n    \n    if (!audioTrack) {\n      console.warn('No audio track found in the stream');\n      return originalStream;\n    }\n    \n    // Create source from the original audio track\n    const source = audioContext.createMediaStreamSource(originalStream);\n    \n    // Create destination for processed audio\n    const destination = audioContext.createMediaStreamDestination();\n    \n    // Apply audio constraints for echo cancellation and noise suppression\n    // Note: These constraints work in conjunction with getUserMedia constraints\n    try {\n      await audioTrack.applyConstraints({\n        echoCancellation: true,\n        noiseSuppression: true,\n        autoGainControl: true,\n      });\n    } catch (err) {\n      console.warn('Could not apply audio constraints:', err);\n    }\n    \n    // If browser supports AudioWorklet, use it for advanced processing\n    if (supportsAudioWorklet) {\n      try {\n        // Create gain node for volume control\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0; // Default gain\n        \n        // Connect the audio processing chain\n        source.connect(gainNode);\n        gainNode.connect(destination);\n        \n        console.log('Enhanced audio stream created with AudioWorklet support');\n      } catch (err) {\n        console.warn('Error setting up AudioWorklet processing:', err);\n        // Fallback: direct connection\n        source.connect(destination);\n      }\n    } else {\n      // Fallback for browsers without AudioWorklet support\n      console.log('AudioWorklet not supported, using basic audio processing');\n      source.connect(destination);\n    }\n    \n    // Return the processed stream\n    return destination.stream;\n  } catch (error) {\n    console.error('Error creating enhanced audio stream:', error);\n    // Return original stream as fallback\n    return originalStream;\n  }\n}\n\n/**\n * Audio level detector for speaking indication\n */\nexport class SpeakingDetector {\n  constructor(stream, options = {}) {\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    this.stream = stream;\n    this.source = this.audioContext.createMediaStreamSource(stream);\n    this.analyser = this.audioContext.createAnalyser();\n    \n    // Configure analyser\n    this.analyser.fftSize = 256;\n    this.analyser.smoothingTimeConstant = 0.5;\n    this.bufferLength = this.analyser.frequencyBinCount;\n    this.dataArray = new Uint8Array(this.bufferLength);\n    \n    // Connect source to analyser\n    this.source.connect(this.analyser);\n    \n    // Speaking detection configuration\n    this.threshold = options.threshold || 20; // Default threshold\n    this.speakingHistory = [];\n    this.historyLength = options.historyLength || 5;\n    this.speaking = false;\n    this.onSpeakingChange = options.onSpeakingChange || null;\n    \n    // Start detection\n    this.isRunning = false;\n  }\n  \n  /**\n   * Start the speaking detection\n   */\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    this.detectSpeaking();\n  }\n  \n  /**\n   * Stop the speaking detection\n   */\n  stop() {\n    this.isRunning = false;\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n  \n  /**\n   * Main detection loop\n   */\n  detectSpeaking() {\n    if (!this.isRunning) return;\n    \n    this.analyser.getByteFrequencyData(this.dataArray);\n    \n    // Calculate average volume\n    let sum = 0;\n    for (let i = 0; i < this.bufferLength; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.bufferLength;\n    \n    // Add to history\n    this.speakingHistory.push(average);\n    if (this.speakingHistory.length > this.historyLength) {\n      this.speakingHistory.shift();\n    }\n    \n    // Calculate average from history to reduce false positives\n    const historyAverage = this.speakingHistory.reduce((a, b) => a + b, 0) / this.speakingHistory.length;\n    \n    // Determine if speaking\n    const isSpeaking = historyAverage > this.threshold;\n    \n    // Notify if speaking state changed\n    if (isSpeaking !== this.speaking) {\n      this.speaking = isSpeaking;\n      if (this.onSpeakingChange) {\n        this.onSpeakingChange(this.speaking);\n      }\n    }\n    \n    // Continue detection loop\n    this.animationFrame = requestAnimationFrame(this.detectSpeaking.bind(this));\n  }\n  \n  /**\n   * Get current audio level (0-100)\n   * @returns {number} Audio level\n   */\n  getAudioLevel() {\n    if (!this.isRunning) return 0;\n    \n    this.analyser.getByteFrequencyData(this.dataArray);\n    \n    // Calculate average volume\n    let sum = 0;\n    for (let i = 0; i < this.bufferLength; i++) {\n      sum += this.dataArray[i];\n    }\n    const average = sum / this.bufferLength;\n    \n    // Convert to 0-100 scale\n    return Math.min(100, Math.max(0, average * (100 / 256)));\n  }\n  \n  /**\n   * Set speaking detection threshold\n   * @param {number} threshold - New threshold value (0-100)\n   */\n  setThreshold(threshold) {\n    this.threshold = Math.min(100, Math.max(0, threshold));\n  }\n  \n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.stop();\n    if (this.source) {\n      this.source.disconnect();\n    }\n  }\n}\n\n/**\n * Audio quality monitor for adaptive streaming\n */\nexport class AudioQualityMonitor {\n  constructor(peerConnection, options = {}) {\n    this.peerConnection = peerConnection;\n    this.interval = options.interval || 2000; // Check interval in ms\n    this.onQualityChange = options.onQualityChange || null;\n    this.qualityThresholds = {\n      excellent: { packetLoss: 0.01, jitter: 10 },\n      good: { packetLoss: 0.03, jitter: 30 },\n      fair: { packetLoss: 0.08, jitter: 50 },\n      poor: { packetLoss: 0.15, jitter: 100 },\n      // Anything worse is considered \"bad\"\n    };\n    \n    this.currentQuality = 'unknown';\n    this.intervalId = null;\n  }\n  \n  /**\n   * Start monitoring audio quality\n   */\n  start() {\n    if (this.intervalId) return;\n    \n    this.intervalId = setInterval(() => this.checkQuality(), this.interval);\n  }\n  \n  /**\n   * Stop monitoring audio quality\n   */\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n  \n  /**\n   * Check current audio quality\n   */\n  async checkQuality() {\n    if (!this.peerConnection) return;\n    \n    try {\n      const stats = await this.peerConnection.getStats();\n      let audioInboundStats = null;\n      \n      // Find audio inbound-rtp stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\n          audioInboundStats = stat;\n        }\n      });\n      \n      if (!audioInboundStats) return;\n      \n      // Calculate packet loss\n      const packetsLost = audioInboundStats.packetsLost || 0;\n      const packetsReceived = audioInboundStats.packetsReceived || 1; // Avoid division by zero\n      const packetLossRate = packetsLost / (packetsLost + packetsReceived);\n      \n      // Get jitter (in milliseconds)\n      const jitter = (audioInboundStats.jitter || 0) * 1000;\n      \n      // Determine quality level\n      let quality = 'bad';\n      if (packetLossRate <= this.qualityThresholds.excellent.packetLoss && \n          jitter <= this.qualityThresholds.excellent.jitter) {\n        quality = 'excellent';\n      } else if (packetLossRate <= this.qualityThresholds.good.packetLoss && \n                jitter <= this.qualityThresholds.good.jitter) {\n        quality = 'good';\n      } else if (packetLossRate <= this.qualityThresholds.fair.packetLoss && \n                jitter <= this.qualityThresholds.fair.jitter) {\n        quality = 'fair';\n      } else if (packetLossRate <= this.qualityThresholds.poor.packetLoss && \n                jitter <= this.qualityThresholds.poor.jitter) {\n        quality = 'poor';\n      }\n      \n      // Notify if quality changed\n      if (quality !== this.currentQuality) {\n        this.currentQuality = quality;\n        if (this.onQualityChange) {\n          this.onQualityChange(quality, { packetLossRate, jitter });\n        }\n      }\n      \n    } catch (error) {\n      console.error('Error checking audio quality:', error);\n    }\n  }\n  \n  /**\n   * Get current quality metrics\n   * @returns {Promise<Object>} Quality metrics\n   */\n  async getQualityMetrics() {\n    if (!this.peerConnection) {\n      return { quality: 'unknown', metrics: {} };\n    }\n    \n    try {\n      const stats = await this.peerConnection.getStats();\n      let audioInboundStats = null;\n      let audioOutboundStats = null;\n      \n      // Find audio stats\n      stats.forEach(stat => {\n        if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\n          audioInboundStats = stat;\n        }\n        if (stat.type === 'outbound-rtp' && stat.kind === 'audio') {\n          audioOutboundStats = stat;\n        }\n      });\n      \n      const metrics = {\n        inbound: audioInboundStats ? {\n          packetsReceived: audioInboundStats.packetsReceived || 0,\n          packetsLost: audioInboundStats.packetsLost || 0,\n          jitter: (audioInboundStats.jitter || 0) * 1000, // ms\n          bytesReceived: audioInboundStats.bytesReceived || 0,\n        } : null,\n        outbound: audioOutboundStats ? {\n          packetsSent: audioOutboundStats.packetsSent || 0,\n          bytesSent: audioOutboundStats.bytesSent || 0,\n        } : null,\n        quality: this.currentQuality,\n      };\n      \n      return metrics;\n    } catch (error) {\n      console.error('Error getting quality metrics:', error);\n      return { quality: 'unknown', metrics: {} };\n    }\n  }\n  \n  /**\n   * Clean up resources\n   */\n  dispose() {\n    this.stop();\n    this.peerConnection = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}